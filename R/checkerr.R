# internals ####

.has_dots <- function(...) {uj::notND0()}
.pop_dots <- function(...) {base::all(uj::N(base::list(...)) > 0)}
.unq_named <- function(...) {uj::NEQ(uj::DN(), uj::U(uj::DN()))}
.all_named <- function(...) {uj::f0(uj::N0(uj::DN()), F, f0(uj::N(uj::DN()) != uj::ND(), F, uj::f0(uj::anyBL(uj::DN()), F, uj:::.unq_named(...))))}

.ox_vals <- function(x, join) {
  n <- uj::N(x)
  if (n == 1) {x}
  else if (n == 2) {uj::p0(x[1], " ", join, " ", x[2])}
  else {uj::p0(uj::g(", ", x[1:(n - 1)]), ", ", join, " ", x[n])}
}

.fun_pkg_stack <- function(fun, pkg, stack, caller, callers) {
  fun <- uj::f0(uj::cmp_chr_scl(uj::failsafe(fun)), fun, "")
  fun <- uj::f0(uj::N1(fun), fun, "{ command line }")
  fun <- uj::f0(fun != "", fun, uj:::.pkg_fun(caller, 100, F)$fun[1])
  pkg <- uj::f0(uj::cmp_chr_scl(uj::failsafe(pkg)), pkg, "")
  pkg <- uj::f0(uj::N1(pkg), pkg, "{ unknown }")
  pkg <- uj::f0(pkg != "", pkg, uj:::.pkg_fun(caller, 100, F)$pkg[1])
  stack <- uj::f0(uj::cmp_chr_scl(uj::failsafe(stack)), stack, "")
  stack <- uj::f0(stack != "", stack, uj:::.pkg_fun(uj::callers(), 35, T))
  stack <- uj::f0(uj::N3P(stack), uj::Nth_plus(stack, 2), "command line")
  stack <- uj::p0("callstack = { ", uj::g0(" > ", stack), " }")
  base::list(fun = fun, pkg = pkg, stack = stack)
}

# exported ####

#' @name checker
#' @encoding UTF-8
#' @family properties
#' @family errs
#' @title Error checking, banking, and processing
#' @description Bank error messages in the immediate environment of a function to allow for exhaustive error checking before throwing an exception. Results in a possibly multiple-error, accumulated message to be processed upon completion of error checking.
#' @details **Primary stopping functions**
#' \tabular{ll}{  `stopperr`        \tab Stops execution by:                                                                                                                                                                                                             \cr
#'                                  \tab \enumerate{\item Posting an \code{\link{alert}} header the console with the following components: an error `'ERROR'` title, a subheader identifying the function where the error originated (from `FUN`), and another subheader identifying the package that function belongs to (from `PKG`).
#'                                                  \item Posting one or more error message to the console following the header, each preceded by a bullet, where each element of each `...` arg is a separate error message.
#'                                                  \item Creating a \code{\link[base]{simpleError}} object with an error message consisting of an \link[=lineage]{abbreviated function call lineage} given as a vector in `STACK`.
#'                                                  \item Attaching the function identity, package identity, and associated message(s) to the `simpleError` object as attributes.
#'                                                  \item Archiving the `simpleError` object in the global variable `.last_UJ_error.` (which can be retrieved by calling `getter()` and can be purged by calling `purger()`). Allows for error tracing in the circumstance that R purges the last error in final error processing.
#'                                                  \item Calling `stop` with the `simpleError` object as the argument.                                                                                                                                   } \cr   \tab   \cr
#'                `checkerr`        \tab Calls `stopper` with any error messages banked by the functions described in sections *error banking* *utilities functions* and *condition-based error-checking functions*. If none are banked, does nothing.      \cr   \tab   \cr
#'                `purgerr`         \tab Purges the most recent \code{\link[base]{simpleError}} object generated by this family of functions.                                                                                                               \cr   \tab   \cr
#'                `getterr`         \tab Gets the most recent `simpleError` object generated by this family of functions.                                                                                                                                                  }
#' \cr Both `stopper` and `checker` can identify error-generating functions further up the call stack than the function in which they are called:
#' \itemize{\item `stopper` uses args `FUN`, `PKG`, and `STACK` to identify the error-generating function.
#'          \item `checker` uses args `GENS` and `PKG` to identify the error-generating function.}
#' \cr\cr **Secondary stopping functions**
#' \cr\cr These functions are designed to be called directly from the function where an error is generated. It gathers the name of the function generating the error rather than requiring the user to provide the function name. These functions operate as follows:
#' \tabular{ll}{  `errs`            \tab Calls `stopper` treating each element of each `...` arg as a separate error message, allowing for compiling multiple error message before processing.                                                              \cr   \tab   \cr
#'                `err`             \tab Calls `stopper` with a single error message constructed by \link[=collapse_dots]{collapsing} all elements of all `...` args into a character scalar error message before processing.                                              }
#' \cr\cr **Multiple-error conditional stopping functions**
#' \cr\cr These functions conditionally compile multiple errors, and if any are compiled, they notify the user and stop execution.
#' \tabular{ll}{  `errs_if_nots`    \tab Conditionally compiles errors, treating each odd-numbered `...` arg as a test and each even-numbered `...` arg as the corresponding error message if the test is `FALSE`, and calls `stopper` if any are compiled. \cr   \tab   \cr
#'                `errs_if_pop`     \tab Calls `stopper` if there are any `...` args, treating each `...` arg as a separate error message.                                                                                                                  \cr   \tab   \cr
#'                `errs_ifs`        \tab Conditionally compiles errors, treating each odd-numbered `...` arg as a test and each even-numbered `...` arg as the corresponding error message if the test is `TRUE`, and calls `stopper` if any are compiled.                 }
#' \cr\cr **Single-error conditional stopping functions**
#' \cr\cr These functions conditionally construct a single error, and if one is constructed, they notify the user and stop execution.
#' \tabular{ll}{  `err_if_pop`      \tab If there are any `...` args, collapsing them into a character scalar error message, and calls `stopper`.                                                                                                           \cr   \tab   \cr
#'                `err_if_not`      \tab If `TEST = FALSE`, collapses `...` args to a character scalar error message and calls `stopper`.                                                                                                                   \cr   \tab   \cr
#'                `err_if`          \tab If `TEST = TRUE`, collapses `...` args to a character scalar error message and calls `stopper`.                                                                                                                                   }
#' \cr\cr **Utility functions**
#' \cr\cr These functions purge and retrieve the most recent error generated by this family of functions.
#' \cr\cr **Primary error banking functions**
#' \cr\cr Error banking utility functions: These functions are utilities for banking user-defined error messages within a function to allow for checking for multiple errors in separate statements and banking those error messages as they are checked, waiting to process banked error messages until an error checking block is completed. These functions also allow for generating and checking for error messages further up the call stack than the function in which the error banking/processing occurs by specifying the number of generations back in the call stack where error banking/processing occurs in `GENS`:
#' \tabular{ll}{  `banked_errs`    \tab Retrieves the bank of error message stored in the environment of the function `GENS` generations back in the call stack.                                                                                            \cr   \tab   \cr
#'                `bankerrs`       \tab Banks each element of \link[=cmp_chr_vec]{complete character vec} as an individual error message.                                                                                                                   \cr   \tab   \cr
#'                `bankerr`        \tab Banks an arbitrary error message (built by \link[=collapse_dots]{collapsing} `...` args) in the environment of the function `GENS` generations back in the call stack.                                                            }
#' \cr\cr **Error checking / conditional error banking functions**
#' \cr\cr **`checkerr`** checks for any banked error messages. If there are any, processes them and stops execution. Otherwise, does nothing.
#' \cr\cr The remaining **`checkXXX`** functions in the following table check objects for specific properties and automatically generate errors only if those properties are not met:
#' \tabular{ll}{  `check_nas_or`    \tab A named `...` arg is neither `NULL` nor satisfies any property function named in `FUNS`.                                                                                                                           \cr   \tab   \cr
#'                `check_nll_or`    \tab A named `...` arg is neither scalar `NA` nor satisfies any property function named in `FUNS`.                                                                                                                      \cr   \tab   \cr
#'                `check_chars`     \tab A named `...` arg contains characters not supplied in `CHARS`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_when`      \tab The first named `...` arg *is* the `n`-th value in `WHENS`, but the second *is not* the `n`-th value in `VALS`.                                                                                                    \cr   \tab   \cr
#'                `check_dots`      \tab A `...` arg\eqn{^{(1)}} fails to satisfy the \link[=is_prop_spec]{property spec} in `SPEC`.                                                                                                                        \cr   \tab   \cr
#'                `check_spec`      \tab A named `...` arg fails to satisfy the \link[=is_prop_spec]{property spec} in `SPEC`\eqn{^{(2)}}.                                                                                                                  \cr   \tab   \cr
#'                `check_funs`      \tab A named `...` arg fails to satisfy *any* of the \link[=prop_funs]{property function(s)} named in `FUNS`.                                                                                                           \cr   \tab   \cr
#'                `check_vals`      \tab A named `...` arg contains values not supplied in `VALS`.                                                                                                                                                          \cr   \tab   \cr
#'                `check_fail`      \tab A named `...` arg produces an error when submitted to \code{\link[base]{identity}}.                                                                                                                                \cr   \tab   \cr
#'                `check_cls`       \tab A named `...` arg is not of any class named in `CLS`.                                                                                                                                                              \cr   \tab   \cr
#'                `check_lgl`       \tab A named `...` arg is neither `TRUE`, `FALSE`, `NA` (if `NAS = TRUE`), nor contained in `EXTRAS`.                                                                                                                   \cr   \tab   \cr
#'                `check_pop`       \tab A named `...` arg is either `NULL` or otherwise of length `0`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_tf`        \tab A named `...` arg is neither scalar `TRUE` nor scalar `FALSE`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_t`         \tab A named `...` arg is `FALSE`\eqn{^{(3)}}.                                                                                                                                                                          \cr   \tab   \cr
#'                                  \tab \eqn{^{(1)}} Named if `NAMED = TRUE`.                                                                                                                                                                              \cr   \tab   \cr
#'                                  \tab \eqn{^{(2)}} May be scalar `NA` if `NAS = TRUE`.                                                                                                                                                                   \cr   \tab   \cr
#'                                  \tab \eqn{^{(3)}} Collapses *unnamed* `...` args to an error message template, replacing the escape sequence `'{@@}'` with the *named* `...` arg's name.                                                                               }
#' @section The `...` arguments: Arguments supplied in `...` differ across functions in terms of whether they are named, how many named and/or unnamed `...` args there are, and their \link[=ppp]{property requirements} as follows:
#' \tabular{llll}{                  \tab    **Number of** `...` **args**          \tab                                            \tab           \cr
#'                  **Function**    \tab    *NAMED*                               \tab   *UNNAMED*                                \tab   *TOTAL* \cr
#'                  `check_chars`   \tab    `1+` (\code{\link{atm_str}})          \tab   `1+` (\code{\link{atm_chr}}\eqn{^{(1)}}) \tab   `2+`    \cr
#'                  `check_when`    \tab    `2 ` (\code{\link{atm_scl}})          \tab   `2 ` (\code{\link{atm_scl}})             \tab   `4`     \cr
#'                  `check_vals`    \tab    `1+` (\code{\link{ATM}}\eqn{^{(1)}})  \tab   `1+` (\code{\link{ATM}}\eqn{^{(1)}})     \tab   `2+`    \cr
#'                  `check_dots`    \tab    `1+` (any object\eqn{^{(2)}})         \tab   `0 ` (any object\eqn{^{(2)}})            \tab   `1+`    \cr
#'                  `check_fail`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_funs`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_spec`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_cls`     \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_lgl`     \tab    `1+` (\code{\link{atm_scl}})          \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_pop`     \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_tf`      \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_t`       \tab    `1+` (\code{\link{isTF1}})            \tab   `0`                                      \tab   `1+`    \cr
#'                  `stopperr`      \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`    \cr
#'                  `errs`          \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`    \cr
#'                  `err`           \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`      }
#'   \tabular{ll}{  `           `   \tab \eqn{^{(1)}} When `A = TRUE`.                                                                           \cr
#'                                  \tab \eqn{^{(2)}} When `NAMED = TRUE` (otherwise `0+`).                                                        }
#' @param ... Differs by function in terms of whether they are named, how many there are, and their \link[=ppp]{property requirements} as described in section *the* `...` *arguments*.
#' @param A `TRUE` or `FALSE` indicating whether to \link[=av]{atomize} `...` args.
#' @param D A non-`NA` character scalar delimiter for collapsing `...` into a an error message.
#' @param FUN A character scalar naming the function generating an error or errors.
#' @param NAS `TRUE` or `FALSE` indicating whether `NA` values qualify as `'logical'`.
#' @param PKG A character scalar naming the package `FUN` is a part of. The package is identified as `'unknown'` when `PKG = ""`.
#' @param ERRS A character vector of individual error messages.
#' @param GENS A \link[=cmp_nnw_scl]{complete non-negative whole-number scalar} indicating the number of generations back in the call stack in which to bank and/or check for error messages.
#' @param FUNS A \link[=cmp_chr_vec]{complete character vec} containing `1` or more \link[=prop_funs]{property function} names.
#' @param SPEC A \link[=cmp_chr_scl]{complete character scalar} containing a \link[=is_prop_spec]{property spec}.
#' @param NAMED `TRUE` or `FALSE` indicating whether `...` args must uniquely named without using `""`.
#' @param STACK An optional character vector naming the lineage of the function generating the error. If `NULL`, retrieves the stack under the assumption that the immediate calling function is where the error is generated.
#' @param WHENS A \link[=pop_atm]{populated atomic object} of length `length(VALS)`.
#' @param VALS A \link[=cmp_atm]{complete atomic object} of length `length(WHENS)`.
#' @param EXTRAS `NULL` or a \link[=cmp_atm]{complete atomic object} containing additional valid values.
#' @return **A **\code{\link[base]{simpleError}} **object** \cr `getterr`
#' \cr\cr  **A character vector**                           \cr `banked_errs`
#' \cr\cr  All others are called for their side effects.
#' @examples
#' egStopper <- function() {stopperr('stopper demo', PKG = 'uj')}
#' egErrs <- function() {errs('errs demo1', 'errs demo2', PKG = 'uj')}
#' egErr <- function() {err('err', 'demo', PKG = 'uj')}
#' egErrors <- function(..., tf = NA, lgl = 42, not = FALSE, pop = NULL,
#'                      fail = simpleError('error'), funs = 2:4, spec = 42,
#'                      vals = 42, class = 42, nas.or = NULL, nll.or = NA,
#'                      chars = '5', whenA = "errorA", whenB = "errorB") {
#'   bankerr(...elt(1))
#'   bankerrs(...elt(2), ...elt(3))
#'   check_tf(tf = tf)
#'   check_lgl(lgl = lgl)
#'   check_t(not = not)
#'   check_pop(pop = pop)
#'   check_fail(fail = fail)
#'   check_funs(c('cmp_ch1_vec', 'cmp_ngw_vec'), funs = funs)
#'   check_spec('cmp_ch1_vec|nll|nas', spec = spec)
#'   check_vals(letters, vals = vals)
#'   check_cls('data.frame', class)
#'   check_nas_or(c('cmp_ch1_vec', 'cmp_ngw_vec'), nas.or = nas.or)
#'   check_nll_or(c('cmp_ch1_vec', 'cmpNGWvec'), nll.or = nll.or)
#'   check_chars(letters, chars = chars)
#'   check_when(whenA = whenA, whenB = whenB, c('errorA', ''), c('errorB', ''))
#'   checkerr(PKG = 'uj')
#' }
#' \dontrun{
#'   egstopperr()
#'   getterr()
#'   purgerr()
#'   getter()
#'   egErrs()
#'   egErrs()
#'   egErrors()
#' }
#' @export
stopperr <- function(..., FUN = "", PKG = "", STACK = "") {
  errs <- uj::asCHR(uj::av(uj::failsafe(base::list(...))))
  errs[base::trimws(errs, which = "both") == ""] <- "{ unknown err }"
  errs <- uj::U(errs)
  where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
  .rwb <- function(x) {crayon::bgRed(crayon::white(crayon::bold(x)))}
  .bwp <- function(x) {crayon::bgBlack(crayon::white(x))}
  .byi <- function(x) {crayon::bgBlack(crayon::yellow(crayon::italic(x)))}
  err.lab <- base::gsub(" ", " ", .rwb("\n ERROR GENERATED IN"), fixed = T)
  fun.lab <- base::gsub(" ", " ", .byi("\n function:"         ), fixed = T)
  pkg.lab <- base::gsub(" ", " ", .byi("\n package: "         ), fixed = T)
  fun.val <- base::gsub(" ", " ", .bwp(FUN                    ), fixed = T)
  pkg.val <- base::gsub(" ", " ", .bwp(PKG                    ), fixed = T)
  pad.nch <- base::max(base::c(uj::LEN(fun.val), uj::LEN(pkg.val)))
  pad.val <- uj::g0(base::rep.int(" ", pad.nch))
  fun.val <- .bwp(base::substr(uj::p0(fun.val, pad.val), 1, pad.nch))
  pkg.val <- .bwp(base::substr(uj::p0(pkg.val, pad.val), 1, pad.nch))
  pad.val <- .rwb(pad.val)
  message <- uj::g0(uj::p0("\n  \u2022 ", errs))
  err.obj <- base::simpleError(where$stack, call = NULL)
  base::attr(err.obj, "function") <- where$fun
  base::attr(err.obj, "package") <- where$pkg
  base::attr(err.obj, "message") <- message
  base::cat(err.lab, pad.val)
  base::cat(fun.lab, fun.val)
  base::cat(pkg.lab, pkg.val)
  base::cat(message)
  base::assign(".last_UJ_error.", err.obj, envir = .GlobalEnv)
  stop(err.obj, call. = F)
}

#' @rdname checker
#' @export
getterr <- function() {uj::f0(base::exists(".last_UJ_error.", envir = .GlobalEnv), base::get(".last_UJ_error.", envir = .GlobalEnv), NULL)}

#' @rdname checker
#' @export
purgerr <- function() {if (base::exists(".last_UJ_error.", envir = .GlobalEnv)) {base::rm(".last_UJ_error.", envir = .GlobalEnv)}}

#' @rdname checker
#' @export
err_if <- function(TEST, ..., FUN = "", PKG = "", STACK = "", D = " ") {
  if (uj::isT1(TEST)) {
    err <- uj::g(uj::f0(uj::cmp_chr_scl(uj::failsafe(D)), D, " "), uj::av(uj::failsafe(base::list(...))))
    err <- uj::f0(base::trimws(err, which = "both") == "", "{ unknown }", err)
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(err, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}

#' @rdname checker
#' @export
err_if_not <- function(TEST, ..., FUN = "", PKG = "", STACK = "", D = " ") {
  if (uj::isF1(uj::failsafe(TEST))) {
    err <- uj::g(uj::f0(uj::cmp_chr_scl(uj::failsafe(D)), D, " "), uj::av(uj::failsafe(base::list(...))))
    err <- uj::f0(base::trimws(err, which = "both") == "", "{ unknown }", err)
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(err, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}

#' @rdname checker
#' @export
errs_ifs <- function(..., FUN = "", PKG = "", STACK = "", D = " ") {
  errs <- uj::nlls_if_nots(..., D = uj::f0(uj::cmp_chr_scl(uj::failsafe(D)), D, " "))
  if (uj::DEF(errs)) {
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(errs, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}

#' @rdname checker
#' @export
errs_if_nots <- function(..., FUN = "", PKG = "", STACK = "", D = " ") {
  errs <- uj::nll_ifs(..., D = uj::f0(uj::cmp_chr_scl(uj::failsafe(D)), D, " "))
  if (uj::DEF(errs)) {
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(errs, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}

#' @rdname checker
#' @export
err_if_pop <- function(ERR, FUN = "", PKG = "", STACK = "", D = " ") {
  ERR <- base::trimws(ERR, which = "both")
  if (ERR != "") {
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(ERR, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}

#' @rdname checker
#' @export
errs_if_pop <- function(ERRS, FUN = "", PKG = "", STACK = "") {
  ERRS <- base::trimws(ERRS, which = "both")
  ERRS <- ERRS[ERRS != ""]
  if (uj::N1P(ERRS)) {
    where <- uj:::.fun_pkg_stack(FUN, PKG, STACK, uj::caller(), uj::callers())
    uj::stopperr(ERRS, FUN = where$fun, PKG = where$pkg, STACK = where$stack)
  }
}


#' @rdname checker
#' @export
errs <- function(ERRS, PGK = "", STACK = NULL) {uj::stopperr(ERRS, FUN = uj::caller(), PGK = PGK, STACK = uj::callers())}

#' @rdname checker
#' @export
err <- function(..., PKG = "", D = " ") {uj::stopperr(uj::g(uj::f0(uj::cmp_chr_scl(D), D, " "), uj::av(...)), FUN = uj::caller(), PKG = PKG, STACK = uj::callers())}

#' @rdname checker
#' @export
banked_errs <- function(GENS = 0) {
  caller <- base::parent.frame(uj::f0(uj::cmp_nnw_scl(GENS), GENS, 0) + 1)
  if (base::exists(".uj_ERR_BANK_uj.", envir = caller, inherits = F)) {base::get(".uj_ERR_BANK_uj.", envir = caller, inherits = F)} else {NULL}
}

#' @rdname checker
#' @export
checkerr <- function(GENS = 0, PKG = "") {
  if (!uj::cmp_nnw_scl(GENS)) {GENS <- 0}
  GENS <- uj::f0(uj::cmp_nnw_scl(GENS), GENS, 0) + 1
  stack <- uj::callers()
  stack <- stack[GENS:uj::N(stack)]
  caller <- base::parent.frame(GENS)
  if (base::exists(".uj_ERR_BANK_uj.", envir = caller, inherits = F)) {
    fun <- uj::callerN(GENS + 1)
    errs <- base::get(".uj_ERR_BANK_uj.", envir = caller, inherits = F)
    base::rm(list = ".uj_ERR_BANK_uj.", envir = caller, inherits = F);
    uj::stopperr(errs, FUN = fun, PKG = PKG, STACK = stack)
  }
}

#' @rdname checker
#' @export
bankerr <- function(..., GENS = 0, D = "") {
  GENS <- uj::f0(uj::cmp_nnw_scl(GENS), GENS, 0) + 1
  caller <- base::parent.frame(GENS)
  errs <- base::c(uj::banked_errs(GENS), uj::g(uj::f0(uj::cmp_chr_scl(D), D, " "), uj::av(...)))
  base::assign(".uj_ERR_BANK_uj.", errs, envir = caller)
}

#' @rdname checker
#' @export
bankerrs <- function(..., GENS = 0) {
  GENS <- uj::f0(uj::cmp_nnw_scl(GENS), GENS, 0) + 1
  caller <- base::parent.frame(GENS)
  errs <- base::c(uj::banked_errs(GENS), uj::av(...))
  base::assign(".uj_ERR_BANK_uj.", errs, envir = caller)
}

#' @rdname checker
#' @export
check_t <- function(..., D = " ") {
  x <- uj::named_dots(...)
  anon <- uj::anon_dots(...)
  mssg <- uj::g(uj::f0(uj::cmp_chr_scl(D), D, " "), uj::av(anon))
  labs <- uj::EN(x)
  uj::errs_if_nots(uj::N1P(x)                                       , "There are no named [...] args."                                                                                 ,
                   uj::notUNQ(labs)                                 , "Named [...] args must be uniquely named."                                                                       ,
                   uj::N1P(anon)                                    , "There are no unnamed [...] args."                                                                               ,
                   base::any(base::grepl("{@}", mssg, fixed = TRUE)), "At least 1 unnamed [...] arg must contain the escape sequence '{@} for inserting the names of named [...] args.", PKG = "uj")
  for (i in 1:uj::N(x)) {if (!x[[1]]) {uj::bankerr(base::gsub("{@}", uj::p0("[", labs[i], "]"), mssg), GENS = 1)}}
}

#' @rdname checker
#' @export
check_tf <- function(...) {
  uj::errs_if_nots(uj:::.has_dots(...) , "There are no [...] args"                                  ,
                   uj:::.all_named(...), "All [...] args must be uniquely named without using \"\".", PKG = "uj")
  dots <- base::list(...)
  ok <- base::sapply(dots, base::isTRUE) | base::sapply(dots, base::isFALSE)
  for (i in 1:uj::N(ok)) {if (!ok[i]) {uj::bankerr("[", uj::DN()[i], "] must be scalar TRUE or scalar FALSE.", GENS = 1, D = "")}}
}

#' @rdname checker
#' @export
check_lgl <- function(..., NAS = FALSE, EXTRAS = NULL) {
  NAS <- uj::f0(uj::TF(NAS), NAS, F)
  EXTRAS <- uj::f0(uj::cmp_atm(EXTRAS), EXTRAS, NULL)
  uj::errs_if_nots(uj:::.has_dots(...) , "There are no [...] args"                                  ,
                   uj:::.all_named(...), "All [...] args must be uniquely named without using \"\".", PKG = "uj")
  x <- base::list(...)
  uj::err_if_not(base::all(base::sapply(x, uj::atm_scl)), "all [...] args must be atomic scalars.", PKG = "uj")
  ok <- base::sapply(x, base::isFALSE)
  ok <- ok & uj::f0(!NAS, TRUE, base::all(base::is.na(x)))
  ok <- ok & uj::f0(uj::NLL(EXTRAS), TRUE, base::sapply(x, uj::IN, EXTRAS))
  if (!base::all(ok)) {
    labs <- uj::p0("[", uj::DN()[!ok], "]")
    mult1 <- uj::f0(uj::N2P(labs), "s", "")
    mult2 <- uj::f0(uj::N2P(labs), "", "s")
    vals <- base::c("TRUE", "FALSE")
    vals <- base::c(vals, uj::f0(NAS, "NA", NULL))
    vals <- base::c(vals, uj::f0(uj::NLL(EXTRAS), NULL, uj::f0(uj::isCHR(EXTRAS), uj::p0("'", EXTRAS, "'"), uj::asCHR(EXTRAS))))
    err <- uj::p0("Argument", mult1, uj:::.ox_vals(labs, "and"), "contain", mult2, " one or more values not in {", uj:::.ox_vals(vals, "and"), "}.")
    uj::bankerr(err, GENS = 1)
  }
}

#' @rdname checker
#' @export
check_nll_or <- function(FUNS, ..., VALS = NULL) {
  ok.FUNS <- uj::cmp_chr_vec(FUNS)
  if (ok.FUNS) {
    FUNS <- uj::av(base::strsplit(FUNS, "|", TRUE))
    len3 <- uj::LEN(FUNS) == 3
    FUNS[len3] <- uj::p0("i", FUNS[len3])
    ok.FUNS <- base::all(base::sapply(FUNS, uj::is_prop_fun))
  }
  labs <- uj::DN()
  nx <- uj::ND()
  ok.x <- nx > 0
  uj::errs_if_nots(ok.x                                       , "[...] arguments must be supplied."                             ,
                   uj::f0(!ok.x, T , uj:::.all_named(...))    , "[...] args must be uniquely named without using blank strings.",
                   ok.FUNS                                    , "[FUNS] must contain 1+ function names found in prop_funs()."   ,
                   uj::f0(uj::NLL(VALS), T, uj::pop_atm(VALS)), "[VALS] must be NULL or complete and atomic (?cmp_atm)."        , PKG = "uj")
  errs <- uj::p0("[", labs, "] must be NULL or ", uj::spec_concise(FUNS))
  for (i in 1:nx) {if (uj::DEF(base::...elt(i))) {
    ok <- F
    for (fun in FUNS) {ok <- (ok | base::eval(uj::p0(text = uj::p0(fun, "(base::...elt(i))")))) & uj::f0(uj::NLL(VALS), T, uj::allIN(base::...elt(i), VALS))}
    if (!ok) {uj::bankerr(errs[i], GENS = 1)}
  }}
}

#' @rdname checker
#' @export
check_nas_or <- function(FUNS, ..., VALS = NULL) {
  uj::err_if_not(uj::cmp_chr_vec(FUNS), "[FUNS] must be a complete character vec (?cmp_chr_vec).", PKG = "uj")
  FUNS <- uj::av(base::strsplit(FUNS, "|", TRUE))
  len3 <- uj::LEN(FUNS) == 3
  FUNS[len3] <- uj::p0("i", FUNS[len3])
  labs <- uj::DN()
  nx <- uj::ND()
  uj::errs_if_nots(nx > 0                                        , "[...] arguments must be supplied."                             ,
                   uj::f0(!nx == 0, T, uj:::.all_named(...))     , "[...] args must be uniquely named without using blank strings.",
                   base::all(base::sapply(FUNS, uj::is_prop_fun)), "[FUNS] contains a function name not found in prop_funs()."     ,
                   uj::f0(uj::NLL(VALS), T, uj::pop_atm(VALS))   , "[VALS] must be NULL or complete and atomic (?cmp_atm)."        , PKG = "uj")
  errs <- uj::p0("[", labs, "] must be NULL or ", uj::spec_concise(FUNS))
  for (i in 1:nx) {if (uj::notNAS(base::...elt(i))) {
    ok <- F
    for (fun in FUNS) {ok <- (ok | base::eval(base::parse(text = uj::p0(fun, "(...elt(i))")))) & uj::f0(uj::NLL(VALS), T, uj::allIN(base::...elt(i), VALS))}
    if (!ok) {uj::bankerr(errs[i], GENS = 1)}
  }}
}

#' @rdname checker
#' @export
check_cls <- function(CLS, ...) {
  x <- uj::named_dots(...)
  anon <- uj::anon_dots(...)
  labs <- uj::EN(named)
  uj::errs_if_nots(0 < (uj::N(x) + uj::N(anon))             , "There are no [...] args."                              ,
                   uj::f0(uj::notN0(anon), T, uj::UNQ(labs)), "[...] arg names must be unique."                       ,
                   uj::cmp_chr_vec(CLS)                     , "[CLS] must be a complete character vec (?cmp_chr_vec).",
                   uj::N0(anon)                             , "All [...] args must be named."                         , PKG = "uj")
  CLS <- uj::av(base::strsplit(CLS, "|", fixed = T))
  err <- uj::p0("'", CLS, "'")
  n <- uj::N(err)
  err <- uj::f0(n == 1, uj::p0("class ", err), uj::f0(n == 2, uj::p0("class ", err[1], " or ", err[2]), uj::p0("any class in {", uj::g(", ", err), "}")))
  for (i in 1:uj::N(x)) {if (uj::noneIN(CLS, base::class(x[[i]]))) {uj::bankerr("[", labs[i], "] must be of ", err, ".", GENS = 1, D = "")}}
}

#' @rdname checker
#' @export
check_pop <- function(...) {
  named <- uj::named_dots(...)
  blank <- uj::anon_dots(...)
  labs <- base::names(named)
  ok.named <- uj::N0(blank)
  uj::errs_if_nots(0 < (uj::N(named) + uj::N(blank))     , "There are no [...] args."                        ,
                   ok.named                              , "All [...] args must be named."                   ,
                   uj::f0(!ok.named, T, uj::noneBL(labs)), "[...] arg names may not be blank strings (\"\").",
                   uj::f0(!ok.named, T, uj::UNQ(labs))   , "[...] arg names must be unique."                 , PKG = "uj")
  for (i in 1:uj::N(named)) {if (uj::N0(named[i])) {uj::uj("[", labs[i], "] is NULL or empty.", GENS = 1, D = "")}}
}

#' @rdname checker
#' @export
check_funs <- function(FUNS, ..., VALS = NULL) {
  uj::err_if_not(uj::cmp_chr_vec(FUNS), "[FUNS] must be a complete character vec (?cmp_chr_vec).", PKG = "uj")
  FUNS <- uj::av(base::strsplit(FUNS, "|", TRUE))
  len3 <- uj::LEN(FUNS) == 3
  FUNS[len3] <- uj::p0("i", FUNS[len3])
  labs <- uj::DN()
  nx <- uj::ND()
  ok.x <- nx > 0
  uj::errs_if_nots(ok.x                                          , "[...] arguments must be supplied."                             ,
                   uj::f0(!ok.x, T, uj:::.all_named(...))        , "[...] args must be uniquely named without using blank strings.",
                   base::all(base::sapply(FUNS, uj::is_prop_fun)), "[FUNS] contains a function name not found in prop_funs()."     ,
                   uj::f0(uj::NLL(VALS), T, uj::pop_atm(VALS))   , "[VALS] must be NULL or complete and atomic (?cmp_atm)."        , PKG = "uj")
  errs <- uj::p0("[", labs, "] must have the following properties: ", uj::spec_concise(FUNS))
  for (i in 1:nx) {
    ok <- FALSE
    for (fun in FUNS) {ok <- (ok | base::eval(base::parse(text = uj::p0(FUN, "(base::...elt(i))")))) & uj::f0(uj::NLL(VALS), T, uj::allIN(base::...elt(i), VALS))}
    if (!ok) {uj::bankerr(errs[i], GENS = 1)}
  }
}

#' @rdname checker
#' @export
check_spec <- function(SPEC, ..., NAS = F) {
  nx <- uj::ND()
  labs <- uj::DN()
  uj::errs_if_nots(uj:::.has_dots(...)                                      , "[...] is empty."                                                   ,
                   uj::TF(NAS)                                              , "[NAS] must be TRUE or FALSE."                                      ,
                   uj::f0(!uj::cmp_chr_scl(SPEC), F, uj::is_prop_spec(SPEC)), "[SPEC] is not a valid property specification (?is_prop_spec)."     ,
                   uj:::.all_named(...)                                     , "All [...] args must be uniquely named without using blank strings.", PKG = "uj")
  errs <- uj::p0("[", labs, "] must be ", uj::spec_concise(SPEC), ".")
  for (i in 1:nx) {
    val <- F
    if (NAS) {val <- uj::isNAS(base::...elt(i))}
    if (!val) {val <- uj::PPP(base::...elt(i), SPEC)}
    if (!val) {uj::bankerr(errs[i], GENS = 1)}
  }
}

#' @rdname checker
#' @export
check_vals <- function(VALS, ..., A = TRUE, NAS = FALSE) {
  valid <- function(y) {
    uj::f0(uj::isATM(y), base::all(base::sapply(uj::av(y), uj::IN, VALS)),
            uj::f0(uj::isDTF(y), base::all(base::apply(y, 2, valid)),
              base::all(base::sapply(y, valid))))
  }
  nx <- uj::ND()
  labs <- uj::DN()
  uj::errs_if_nots(uj::cmp_lgl_scl(A)  , "[A] must be TRUE or FALSE."                                        ,
                   uj:::.has_dots(...) , "[...] is empty."                                                   ,
                   uj::cmp_lgl_scl(NAS), "[NAS] must be TRUE or FALSE."                                      ,
                   uj::cmp_atm(VALS)   , "[VALS] must be complete and atomic (?cmp_atm)."                    ,
                   uj:::.all_named(...), "All [...] args must be uniquely named without using blank strings.", PKG = "uj")
  x <- base::list(...)
  atm <- base::sapply(x, uj::pop_atm)
  uj::err_if_not(!A | base::all(atm), "When [A = TRUE], all [...] args must be populated and atomic (?pop_atm).", PKG = "uj")
  if (!A) {
    vls <- base::sapply(x, atm_vls)
    dtf <- base::sapply(x, atm_dtf)
    uj::err_if_not(base::all(atm | vls | dtf), "All [...] args must be populated and atomic (?pop_atm), atomic vlists (?atm_vls), or atomic data.frames (?atm_dtf).", PKG = "uj")
  }
  for (i in 1:nx) {if (!valid(x[[i]])) {uj::bankerr("[", labs[i], "] contains 1 or more values not in [VALS].", GENS = 1, D = "")}}
}

#' @rdname checker
#' @export
check_chars <- function(CHARS, ..., A = TRUE) {
  valid <- function(y) {
    if (uj::isATM(y)) {base::allIN(uj::av(base::strsplit(uj::g0(uj::av(y)), "", fixed = T)), CHARS)}
    else if (uj::isDTF(y)) {base::all(base::apply(y, 2, valid))}
    else {base::all(base::sapply(y, valid))}
  }
  labs <- uj::DN()
  nx <- uj::ND()
  uj::errs_if_nots(uj::cmp_chr(CHARS)  , "[CHARS] must be complete and character (?cmp_chr)."                ,
                   uj:::.has_dots(...) , "[...] is empty."                                                   ,
                   uj:::.all_named(...), "All [...] args must be uniquely named without using blank strings.",
                   uj::cmp_lgl_scl(A)  , "[A] must be TRUE or FALSE."                                        , PKG = "uj")
  x <- base::list(...)
  atm <- base::sapply(x, pop_atm)
  uj::err_if_not(!A | base::all(atm), "When [A = TRUE], all [...] args must be populated and atomic (?pop_atm).", PKG = 'uj')
  if (!A) {uj::err_if_not(base::all(atm | base::sapply(x, atm_vls) | base::sapply(x, atm_dtf)), "All [...] args must be populated and atomic (?pop_atm), atomic vlists (?atm_vls), or atomic data.frames (?atm_dtf).", PKG = "uj")}
  chars.scl <- uj::g0(uj::u(uj::av(CHARS)))
  chars <- uj::av(base::strsplit(chars.scl, "", fixed = T))
  for (i in 1:nx) {if (!valid(x[[i]])) {uj::uj("[", labs[i], "] contains 1 or more characters not in { ", chars, " }.", GENS = 1, D = "")}}
}

#' @rdname checker
#' @export
check_dots <- function(SPEC, ..., NAMED = FALSE) {
  ok.NAMED <- uj::isTF1(NAMED)
  uj::errs_if_nots(ok.NAMED                                                     , "[NAMED] must be TRUE or FALSE."                                    ,
                   uj:::.has_dots(...)                                          , "[...] is empty."                                                   ,
                   uj::f0(!uj::cmp_chr_scl(SPEC) , F, uj::is_prop_spec(SPEC))   , "[SPEC] must be complete and character (?cmp_chr)."                 ,
                   uj::f0(!ok.NAMED | uj::isT1(NAMED) , T, uj:::.all_named(...)), "All [...] args must be uniquely named without using blank strings.", PKG = "uj")
  if (!base::all(base::sapply(base::list(...), uj::iPPP, spec = SPEC))) {uj::uj("All [...] args must be ", uj::spec_concise(SPEC), ".", GENS = 1, D = "")}
}

#' @rdname checker
#' @export
check_when <- function(WHENS, VALS, ...) {
  labs <- uj::DN()
  ok.n <- uj::ND2()
  ok.WHENS <- uj::POP(WHENS) & uj::ATM(WHENS)
  ok.VALS <- uj::POP(VALS) & uj::POP(VALS)
  uj::errs_if_nots(ok.n                                                                                     , "There must be two args in [...]"                               ,
                   ok.VALS                                                                                  , "[VALS] must be non-empty and atomic."                          ,
                   ok.WHENS                                                                                 , "[WHENS] must be non-empty and atomic."                         ,
                   uj::N(WHENS) == uj::N(VALS)                                                              , "[WHENS] and [VALS] must be of the same length."                ,
                   uj::SCL(..1) & uj::SCL(..2)                                                              , "Both args in [...] must be atomic and scalar (?atm_scl)."      ,
                   uj::f0(ok.WHENS & ok.VALS, uj::compatible(VALS, ..2), T)                                 , "[VALS] and [..2] are of incompatible (?compatible) modes."     ,
                   uj::f0(ok.WHENS & ok.VALS, uj::compatible(WHENS, ..1), T)                                , "[WHENS] and [..1] are of incompatible (?compatible) modes."    ,
                   uj::f0(!ok.n, T, uj::f0(uj::N2(labs), F, uj::f0(uj::anyBL(labs), F, labs[1] != labs[2]))), "[...] args must be uniquely named without using blank strings.", PKG = "uj")
  labs1 <- uj::p0("[", labs[1], "]")
  labs2 <- uj::p0("[", labs[2], "]")
  when <- ..1
  val <- ..2
  i <- uj::W(base::sapply(WHENS, uj::EQ, y = when))
  if (uj::N1P(i)) {
    match <- VALS[i[1]]
    if (uj::notEQ1(val, match)) {
      if (uj::isCHR(match)) {match <- uj::p0("'", match, "'")}
      uj::bankerr("When ", labs1, " is ", when, ", ", labs2, " must be ", match, ".", GENS = 1, D = "")
  }}
}

#' @rdname checker
#' @export
check_fail <- function(...) {
  labs <- uj::DN()
  n <- uj::ND()
  uj::errs_if_nots(n > 0, "[...] is empty.", uj::NU(labs) == uj::N(labs) & uj::MF("", labs), "All args in [...] must be uniquely named without using blank strings.", PKG = "uj")
  for (i in 1:n) {if (uj::isERR(uj::failsafe(base::...elt(i)))) {uj::uj("evaluating arg [", labs[i], "] produced an error: ", uj::av(x), GENS = 1, D = "")}}
}
