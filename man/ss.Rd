% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ss.R
\encoding{UTF-8}
\name{ss}
\alias{ss}
\alias{ch}
\alias{chars}
\alias{ss0}
\alias{ss_tb}
\alias{ss1}
\alias{ss_p}
\alias{ss_d}
\alias{ss_b}
\alias{ss_pd}
\alias{ss_pb}
\alias{ss_db}
\alias{ss_pdb}
\alias{uss}
\alias{uch}
\alias{uchars}
\alias{uss0}
\alias{uss_tb}
\alias{uss1}
\alias{uss_p}
\alias{uss_d}
\alias{uss_b}
\alias{uss_pd}
\alias{uss_pb}
\alias{uss_db}
\alias{uss_pdb}
\title{Split strings and select/check for elements}
\usage{
ss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, u = FALSE, n = NULL)

ch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

chars(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_tb(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  u = FALSE,
  n = NULL
)

ss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_p(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_d(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_b(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_pd(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_pb(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_db(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss_pdb(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

uss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uchars(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_tb(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  n = NULL
)

uss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_p(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_d(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_b(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_pd(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_pb(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_db(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss_pdb(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)
}
\arguments{
\item{d}{A complete character vec of a delimiter or delimiters to use in splitting strings.}

\item{...}{An arbitrary number of objects to be \link[=av]{atomized} before splitting.}

\item{trm}{\code{TRUE} or \code{FALSE} indicating whether to trim white space from each side of each element of the result.}

\item{sqz}{\code{TRUE} or \code{FALSE} indicating whether to squeeze the result by removing extra internal whitespace.}

\item{drop}{\code{TRUE} or \code{FALSE}. For functions associated character-wise splitting (i.e., ending in \code{0} or \code{ch}), indicates whether to drop resulting values that are not letters, digits, or spaces. For all others, indicates whether to drop resulting blank string values.}

\item{u}{complete non-\code{NA} scalar indicating whether to reduce the result to unique values.}

\item{n}{An optional \link[=cmp_psw_scl]{complete positive whole-number vec} specifying one or more elements to be extracted from the result.}

\item{name}{A \link[=cmp_chr_scl]{complete character scalar} name of the variable to hold the original strings.}

\item{part}{A complete character scalar prefix for labeling components of vectors resulting from split strings.}

\item{x}{A \link[=chr_vec]{character vec} of string(s) to be split.}
}
\value{
\strong{A character vector}            \cr\cr \verb{s_pdb uss_pdb} \cr \verb{ss_db, uss_db} \cr \verb{ss_pb, uss_pb} \cr \verb{ss_pd, uss_pd} \cr \verb{ss_b, uss_b} \cr \verb{ss_d, uss_d} \cr \verb{ss_p, uss_p} \cr \verb{ss1, uss1} \cr \verb{ss, uss}
\cr\cr  \strong{A \link[=CH1]{onechar} vector} \cr\cr \verb{ss0 uss0}      \cr \verb{ch, chars, uch, uchars}
\cr\cr  **A data.frame **                 \cr\cr \verb{ss_tb, uss_tb}
}
\description{
\emph{Order of operations}
\cr\cr All functions in this family follow the same order of operations when performing string splitting:
\itemize{\item \link[=av]{Atomize} \code{...}, collapsing it to a simple atomic vector.
\item Coerce the result to a character vector.
\item Split each element of the vector along the delimiter(s) in \code{d}, producing a potentially longer character vector.
\item If \code{n} is not \code{NULL}, extract the \code{n}-th elements(s) from the result.
\item If \code{trm = TRUE}, trim white space (i.e., spaces, tabs, newlines) from both ends of each element of the result.
\item If \code{sqz = TRUE}, remove leading and trailing white space and replace any multi character interior white-space sequences inside the result with a single space.
\item If \code{u = TRUE}, reduce the result to unique values.}
}
\details{
\strong{The function} \code{ss}
\cr\cr Performs the operations as described in the \emph{order of operations} section.
\cr\cr \strong{The functions} \code{ch/chars}
\cr\cr Split strings in constituent characters (by using a blank-string delimiter).
\cr\cr \strong{The function} \code{sstb}
\cr\cr Requires that splitting each element of \code{x} along the delimiter \code{d} and post-processing the results based on optional args \code{trm}, \code{sqz}, \code{drop}, \code{n}, and \code{u} will result in vectors of the same length. Those resulting same-length vectors are then placed into a data.frame. For example, the following console excerpt demonstrates a call to \code{ss_tb} and its result.

\if{html}{\out{<div class="sourceCode">}}\preformatted{> sstb('|', 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')

  original letter.1 letter.2 letter.3 letter.4
1  a|b|c|d        a        b        c        d
2  e|f|g|h        e        f        g        h
3  i|j|k|l        i        j        k        l
4  m|n|o|p        m        n        o        p
}\if{html}{\out{</div>}}

\cr \strong{Functions extending} \code{ss} ** for common delimiters**
\cr\cr Extension functions are supplied for common delimiters, signified by codes appended to \code{ss} function names:
\tabular{lll}{  \strong{Code}   \tab \strong{name}            \tab \strong{Common delimiter}                                                              \cr
  \code{'0'}      \tab blank\eqn{^{(1)}}   \tab \code{''}                                                                              \cr
  \code{'1'}      \tab space               \tab \code{' '}                                                                             \cr
  \code{'_p'}     \tab pipe                \tab \code{'|'}                                                                             \cr
  \code{'_d'  }   \tab dot                 \tab \code{'.'}                                                                             \cr
  \code{'_b'}     \tab broken pipe         \tab \code{'¦'}                                                                               }
\tabular{ll}{  \verb{     }    \tab \eqn{^{(1)}} Splits strings into constituent characters, making \code{ss0(.)} functionally equivalent to \code{ch(.)}. }
\cr \strong{Functions filtering for unique values}
\cr\cr Prepending \code{u} to a function name reduces the result of calling the original function to unique values.
}
\examples{
ss("", "super-cooled")
ss("|", "super||cooled", "super|heated")
ss_0("super-cooled", "super-heated")
ss_1("super cooled", "super heated")
ss_p("super|cooled", "super|heated", u = TRUE)
ss_d("super.cooled", "super.heated")
ss_b("super¦cooled", "super¦heated")
ss_pd("super|cooled", "super.heated")
ss_pb("super|cooled", "super¦heated")
ss_db("super.cooled", "super¦heated")
ss_pdb("super|cooled¦|super|heated", u = TRUE)
ss_pdb(" super|cooled  ¦super..  heated", n = 3)
ss_pdb(" super|cooled  ¦super..  heated", trm = F, sqz = F, drop = F, n = 3)
uss("", "super-cooled")
uss("|", "super|cooled", "super|heated")
uss_0("super-cooled", "super-heated")
uss_1("super cooled", "super heated")
uss_p("super|cooled", "super|heated")
uss_p("super|cooled", "super|heated")
uss_d("super.cooled", "super.heated")
uss_b("super¦cooled", "super¦heated")
uss_pd("super|cooled", "super.heated")
uss_pb("super|cooled", "super¦heated")
uss_db("super.cooled", "super¦heated")
uss_pdb("super|cooled¦super|heated")
ss_tb("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p')
ss_tb("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}()},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}()},
\code{\link{markdown}()},
\code{\link{maxnch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{tocase}()},
\code{\link{weave}()}

Other chars: 
\code{\link{chn}()},
\code{\link{maxnch}()},
\code{\link{revstr}()},
\code{\link{spaces}()}
}
\concept{chars}
\concept{strings}
