% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ss.R
\name{ss}
\alias{ss}
\alias{ss1}
\alias{ssP}
\alias{ssD}
\alias{ssB}
\alias{ssPD}
\alias{ssPB}
\alias{ssDB}
\alias{ssPDB}
\alias{ch}
\alias{uch}
\alias{sstb}
\title{Split Strings and Select/Check for Elements}
\usage{
ss(d, ..., trm = T, sqz = T, u = F, n = NULL)

ss1(..., trm = T, sqz = T, n = NULL, u = F)

ssP(..., trm = T, sqz = T, n = NULL, u = F)

ssD(..., trm = T, sqz = T, n = NULL, u = F)

ssB(..., trm = T, sqz = T, n = NULL, u = F)

ssPD(..., trm = T, sqz = T, n = NULL, u = F)

ssPB(..., trm = T, sqz = T, n = NULL, u = F)

ssDB(..., trm = T, sqz = T, n = NULL, u = F)

ssPDB(..., trm = T, sqz = T, n = NULL, u = F)

ch(..., trm = T, sqz = T, n = NULL, u = F)

uch(..., trm = T, sqz = T, n = NULL)

sstb(x, d, name = "string", parts = "part")
}
\arguments{
\item{d}{A \link[=cmp_chr_vec]{complete character vec} delimiter or
delimiters to use in splitting strings.}

\item{...}{An arbitrary number of objects to be \link[=av]{atomized} before
splitting.}

\item{trm}{A \link[=cmp_lgl_scl]{complete logical scalar} indicating whether
to trim white space from each side of each element of the result.}

\item{sqz}{A link[=cmp_lgl_scl]{complete logical scalar} indicating whether
to squeeze the result by removing either empty strings (for \code{ss} functions)
or characters that are neither letters, digits, nor spaces (for \code{ch}).}

\item{u}{\link[=cmp_lgl_scl]{Complete logical scalar} indicating whether to
reduce the result to unique values.}

\item{n}{An optional \link[=cmp_psw_scl]{complete positive whole-number
scalar} specifying an element to be extracted from the result.}

\item{x}{A \link[=chr_vec]{character vec} of string(s) to be split.}

\item{name}{A \link[=cmp_chr_scl]{complete character scalar} name of the
variable to hold the original strings.}

\item{part}{A \link[=cmp_chr_scl]{complete character scalar} prefix for
labeling components of vectors resulting from split strings.}
}
\value{
Either a \link[=chr_vec]{character vector}, a
\link[=chr_vls]{character vlist}, or a \link[=chr_dtf]{character
data.frame}.
}
\description{
\strong{Function \code{ss}}
\cr splits strings using the delimiter(s) in \code{d} following this sequence:
\enumerate{
\item Reduce \code{...} to one atomic vector of constituent atomic values.
\item Convert the result to mode character.
\item Replace each element of the result with that element's constituent
parts as delimited by \code{d}, producing a potentially longer
character vector.
\item If \code{n} is not \code{NULL}, extracts the \code{n}-th elements(s) from the
result.
\item If \code{trm} is \code{TRUE}, trims white space (i.e., spaces, tabs, newlines)
from both ends of each element of the result.
\item If \code{sqz} is \code{TRUE}, removes leading and trailing white
space and replaces any multi-character strings of white-space
strings inside the result with a single space.
\item If \code{u} is \code{TRUE}, reduces the result to unique values.              }
\strong{\code{ch}} does the same, with the exception that the delimiter is a
blank string, resulting in a vector of single characters; and (if
\code{sqz = TRUE}) removing blank strings from the result.
\strong{Extension} functions are supplied for common delimiters, signified
by the following suffixes on function names:\tabular{lll}{
SUFFIX      \tab SUFFIX        \tab DELIMITER                           \cr
CHARACTER   \tab NAME          \tab INVOKED                             \cr
\code{'1'}       \tab Space         \tab \code{' '}                               \cr
\code{'P'}       \tab Pipe          \tab \code{'|'}                               \cr
\code{'D'}       \tab Dot           \tab \code{'.'}                               \cr
\code{'B'}       \tab Broken pipe   \tab \code{'¦'}                                 }
\strong{Function \code{uch}}
\cr Does the same as \code{ch} with the exception of reducing the result to
unique single characters.
\cr\cr
\strong{Function \code{sstb}}
\cr assumes that splitting each element of \code{x} along the delimiter \code{d}
results vectors of the same length, which are placed into a data.frame. For
example, the following console excerpt demonstrates a call to \code{sstb} and
its result.

\if{html}{\out{<div class="sourceCode">}}\preformatted{> sstb(x = c('a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p'),
+      d = '|'
+      name = 'original',
+      part = 'letter')

  original letter.1 letter.2 letter.3 letter.4
1  a|b|c|d        a        b        c        d
2  e|f|g|h        e        f        g        h
3  i|j|k|l        i        j        k        l
4  m|n|o|p        m        n        o        p
}\if{html}{\out{</div>}}
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{charn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{ipat}()},
\code{\link{max_nch}()},
\code{\link{mkstr}},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spacing}},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
