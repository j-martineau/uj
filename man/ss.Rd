% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ss.R
\encoding{UTF-8}
\name{ss}
\alias{ss}
\alias{ch}
\alias{chars}
\alias{ss0}
\alias{ssTB}
\alias{ss1}
\alias{ssP}
\alias{ssD}
\alias{ssB}
\alias{ssPD}
\alias{ssPB}
\alias{ssDB}
\alias{ssPDB}
\alias{uss}
\alias{uch}
\alias{uss0}
\alias{ussTB}
\alias{uss1}
\alias{ussP}
\alias{ussD}
\alias{ussB}
\alias{ussPD}
\alias{ussPB}
\alias{ussDB}
\alias{ussPDB}
\title{Split strings and select/check for elements}
\usage{
ss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, u = FALSE, n = NULL)

ch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

chars(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssTB(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  u = FALSE,
  n = NULL
)

ss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssP(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

uss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussTB(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  n = NULL
)

uss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussP(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)
}
\arguments{
\item{d}{A complete character vec of a delimiter or delimiters to use in splitting strings.}

\item{...}{An arbitrary number of objects to be \link[=av]{atomized} before splitting.}

\item{trm}{\code{TRUE} or \code{FALSE} indicating whether to trim white space from each side of each element of the result.}

\item{sqz}{\code{TRUE} or \code{FALSE} indicating whether to squeeze the result by removing extra internal whitespace.}

\item{drop}{\code{TRUE} or \code{FALSE}. For functions associated character-wise splitting (i.e., ending in \code{0} or \code{ch}), indicates whether to drop resulting values that are not letters, digits, or spaces. For all others, indicates whether to drop resulting blank string values.}

\item{u}{complete non-\code{NA} scalar indicating whether to reduce the result to unique values.}

\item{n}{An optional \link[=cmp_psw_scl]{complete positive whole-number vec} specifying one or more elements to be extracted from the result.}

\item{name}{A \link[=cmp_chr_scl]{complete character scalar} name of the variable to hold the original strings.}

\item{part}{A complete character scalar prefix for labeling components of vectors resulting from split strings.}

\item{x}{A \link[=chr_vec]{character vec} of string(s) to be split.}
}
\value{
\strong{A character vector}            \cr\cr \verb{ssPDB ussPDB} \cr \verb{ssDB, ussDB} \cr \verb{ssPB, ussPB} \cr \verb{ssPD, ussPD} \cr \verb{ssB, ussB} \cr \verb{ssD, ussD} \cr \verb{ssP, ussP} \cr \verb{ss1, uss1} \cr \verb{ss, uss}
\cr\cr  \strong{A \link[=CH1]{onechar} vector} \cr\cr \verb{ss0 uss0}     \cr \verb{ch, uch}
\cr\cr  **A data.frame **                 \cr\cr \verb{ssTB, ussTB}
}
\description{
\emph{Order of operations}
\cr All functions in this family follow the same order of operations when performing string splitting:
\itemize{\item \link[=av]{Atomize} \code{...}, collapsing it to a simple atomic vector.
\item Coerce the result to a character vector.
\item Split each element of the vector along the delimiter(s) in \code{d}, producing a potentially longer character vector.
\item If \code{n} is not \code{NULL}, extract the \code{n}-th elements(s) from the result.
\item If \code{trm = TRUE}, trim white space (i.e., spaces, tabs, newlines) from both ends of each element of the result.
\item If \code{sqz = TRUE}, remove leading and trailing white space and replace any multi character interior white-space sequences inside the result with a single space.
\item If \code{u = TRUE}, reduce the result to unique values.}
}
\details{
\strong{The function} \code{ss}
\cr Performs the operations as described in the \emph{order of operations} section.
\cr\cr \strong{The functions} \code{ch/chars}
\cr Split strings in constituent characters (by using a blank-string delimiter).
\cr\cr \strong{The function} \code{sstb}
\cr Requires that splitting each element of \code{x} along the delimiter \code{d} and post-processing the results based on optional args \code{trm}, \code{sqz}, \code{drop}, \code{n}, and \code{u} will result in vectors of the same length. Those resulting same-length vectors are then placed into a data.frame. For example, the following console excerpt demonstrates a call to \code{sstb} and its result.

\if{html}{\out{<div class="sourceCode">}}\preformatted{> sstb('|', 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')

  original letter.1 letter.2 letter.3 letter.4
1  a|b|c|d        a        b        c        d
2  e|f|g|h        e        f        g        h
3  i|j|k|l        i        j        k        l
4  m|n|o|p        m        n        o        p
}\if{html}{\out{</div>}}

\cr \strong{Functions extending} \code{ss} ** for common delimiters**
\cr Extension functions are supplied for common delimiters, signified by codes appended to \code{ss} function names:
\tabular{lll}{  \strong{Code}   \tab \strong{Name}            \tab \strong{Common delimiter}                                                              \cr
  \code{'0'}      \tab blank\eqn{^{(1)}}   \tab \code{''}                                                                              \cr
  \code{'1'}      \tab space               \tab \code{' '}                                                                             \cr
  \code{'P'}      \tab pipe                \tab \code{'|'}                                                                             \cr
  \code{'D'  }    \tab dot                 \tab \code{'.'}                                                                             \cr
  \code{'B'}      \tab broken pipe         \tab \code{'¦'}                                                                               }
\tabular{ll}{  \verb{     }    \tab \eqn{^{(1)}} Splits strings into constituent characters, making \code{ss0(.)} functionally equivalent to \code{ch(.)}. }
\cr
\cr \strong{Functions filtering for unique values}
\cr Prepending \code{u} to a function name reduces the result of calling the original function to unique values.
}
\examples{
ss("", "super-cooled")
ss("|", "super||cooled", "super|heated")
ss0("super-cooled", "super-heated")
ss1("super cooled", "super heated")
ssP("super|cooled", "super|heated", u = TRUE)
ssD("super.cooled", "super.heated")
ssB("super¦cooled", "super¦heated")
ssPD("super|cooled", "super.heated")
ssPB("super|cooled", "super¦heated")
ssDB("super.cooled", "super¦heated")
ssPDB("super|cooled¦|super|heated", u = TRUE)
ssPDB(" super|cooled  ¦super..  heated", n = 3)
ssPDB(" super|cooled  ¦super..  heated", trm = F, sqz = F, drop = F, n = 3)

uss("", "super-cooled")
uss("|", "super|cooled", "super|heated")
uss0("super-cooled", "super-heated")
uss1("super cooled", "super heated")
ussP("super|cooled", "super|heated")
ussP("super|cooled", "super|heated")
ussD("super.cooled", "super.heated")
ussB("super¦cooled", "super¦heated")
ussPD("super|cooled", "super.heated")
ussPB("super|cooled", "super¦heated")
ussDB("super.cooled", "super¦heated")
ussPDB("super|cooled¦super|heated")

ssTB("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p')
ssTB("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}()},
\code{\link{markdown}()},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{tocase}()},
\code{\link{weave}()}

Other chars: 
\code{\link{chn}()},
\code{\link{max_nch}()},
\code{\link{revstr}()},
\code{\link{spaces}()}
}
\concept{chars}
\concept{strings}
