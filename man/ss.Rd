% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ss.R
\encoding{UTF-8}
\name{ss}
\alias{ss}
\alias{ch}
\alias{chars}
\alias{ss0}
\alias{sstb}
\alias{ss1}
\alias{ssP}
\alias{ssD}
\alias{ssB}
\alias{ssPD}
\alias{ssPB}
\alias{ssDB}
\alias{ssPDB}
\alias{uss}
\alias{uch}
\alias{uss0}
\alias{usstb}
\alias{uss1}
\alias{ussP}
\alias{ussD}
\alias{ussB}
\alias{ussPD}
\alias{ussPB}
\alias{ussDB}
\alias{ussPDB}
\title{Split strings and select/check for elements}
\usage{
ss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, u = FALSE, n = NULL)

ch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

chars(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

sstb(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  u = FALSE,
  n = NULL
)

ss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssP(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

ssPDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL, u = FALSE)

uss(d, ..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uch(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

uss0(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

usstb(
  d,
  ...,
  name = "string",
  part = "part",
  trm = TRUE,
  sqz = TRUE,
  drop = TRUE,
  n = NULL
)

uss1(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussP(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPD(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)

ussPDB(..., trm = TRUE, sqz = TRUE, drop = TRUE, n = NULL)
}
\arguments{
\item{d}{A complete character vec of delimiter or delimiters to use in splitting strings.}

\item{...}{An arbitrary number of objects to be \link[=av]{atomized} before splitting.}

\item{trm}{A non-\code{NA} logical scalar indicating whether to trim white space from each side of each element of the result.}

\item{sqz}{A non-\code{NA} logical scalar indicating whether to squeeze the result by removing extra internal whitespace.}

\item{drop}{A non-\code{NA} logical scalar. For functions associated character-wise splitting (i.e., ending in \code{0} or \code{ch}), indicates whether to drop resulting values that are not letters, digits, or spaces. For all others, indicates whether to drop resulting blank string values.}

\item{u}{complete non-\code{NA} scalar indicating whether to reduce the result to unique values.}

\item{n}{An optional \link[=cmp_psw_scl]{complete positive whole-number vec} specifying one or more elements to be extracted from the result.}

\item{name}{A \link[=cmp_chr_scl]{complete character scalar} name of the variable to hold the original strings.}

\item{part}{A complete character scalar prefix for labeling components of vectors resulting from split strings.}

\item{x}{A \link[=chr_vec]{character vec} of string(s) to be split.}
}
\value{
\emph{A character vector}
\cr   \verb{ssPDB ussPDB}
\cr   \verb{ssDB, ussDB}
\cr   \verb{ssPB, ussPB}
\cr   \verb{ssPD, ussPD}
\cr   \verb{ssB, ussB}
\cr   \verb{ssD, ussD}
\cr   \verb{ssP, ussP}
\cr   \verb{ss1, uss1}
\cr   \verb{ss, uss}
\cr\cr \emph{A} \link[=ich1]{1-char} \emph{vector}
\cr   \verb{ss0 uss0}
\cr   \verb{ch, uch}
\cr\cr *A data.frame *
\cr   \verb{sstb, usstb}
}
\description{
All functions in this family follow the same order of operations when performing string splitting:
\cr\cr \emph{Order of operations} \itemize{
\item \link[=av]{Atomize} \code{...}, collapsing it to a simple atomic vector.
\item Coerce the result to a character vector.
\item Split each element of the vector along the delimiter(s) in \code{d}, producing a potentially longer character vector.
\item If \code{n} is not \code{NULL}, extract the \code{n}-th elements(s) from the result.
\item If \code{trm = TRUE}, trim white space (i.e., spaces, tabs, newlines) from both ends of each element of the result.
\item If \code{sqz = TRUE}, remove leading and trailing white space and replace any multi character interior white-space sequences inside the result with a single space.
\item If \code{u = TRUE}, reduce the result to unique values.
}
\cr \emph{The function} \code{ss} \cr\cr Performs the operations as described in the \emph{order of operations} section.
\cr\cr \emph{The functions} \code{ch/chars} \cr\cr Split strings in constituent characters (by using a blank-string delimiter).
\cr\cr \emph{The function} \code{sstb} \cr\cr Requires that splitting each element of \code{x} along the delimiter \code{d} and post-processing the results based on optional args \code{trm}, \code{sqz}, \code{drop}, \code{n}, and \code{u} will result in vectors of the same length. Those resulting same-length vectors are then placed into a data.frame. For example, the following console excerpt demonstrates a call to \code{sstb} and its result.

\if{html}{\out{<div class="sourceCode">}}\preformatted{> sstb('|', 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')

  original letter.1 letter.2 letter.3 letter.4
1  a|b|c|d        a        b        c        d
2  e|f|g|h        e        f        g        h
3  i|j|k|l        i        j        k        l
4  m|n|o|p        m        n        o        p
}\if{html}{\out{</div>}}

\cr \emph{Functions extending} \code{ss} * for common delimiters* \cr\cr Extension functions are supplied for common delimiters, signified by codes appended to \code{ss} function names:
\tabular{cll}{
  \emph{Code}   \tab \emph{Name}      \tab   \emph{Common delimiter}
\cr \code{'0'} \tab blank\code{*}    \tab   \code{''}
\cr \code{'1'} \tab space       \tab   \code{' '}
\cr \code{'P'} \tab pipe        \tab   \code{'|'}
\cr \code{'D'} \tab dot         \tab   \code{'.'}
\cr \code{'B'} \tab broken pipe \tab   \code{'¦'}
}
\code{*} Splits strings into constituent characters, making \code{ss0(.)} functionally equivalent to \code{ch(.)}.
\cr\cr \strong{Functions filtering for unique values}
\cr\cr Prepending \code{u} to a function name reduces the result of calling the original function to unique values.
}
\examples{
ss("", "super-cooled")
ss("|", "super||cooled", "super|heated")
ss0("super-cooled", "super-heated")
ss1("super cooled", "super heated")
ssP("super|cooled", "super|heated", u = TRUE)
ssD("super.cooled", "super.heated")
ssB("super¦cooled", "super¦heated")
ssPD("super|cooled", "super.heated")
ssPB("super|cooled", "super¦heated")
ssDB("super.cooled", "super¦heated")
ssPDB("super|cooled¦|super|heated", u = TRUE)
ssPDB(" super|cooled  ¦super..  heated", n = 3)
ssPDB(" super|cooled  ¦super..  heated", trm = F, sqz = F, drop = F, n = 3)

uss("", "super-cooled")
uss("|", "super|cooled", "super|heated")
uss0("super-cooled", "super-heated")
uss1("super cooled", "super heated")
ussP("super|cooled", "super|heated")
ussP("super|cooled", "super|heated")
ussD("super.cooled", "super.heated")
ussB("super¦cooled", "super¦heated")
ussPD("super|cooled", "super.heated")
ussPB("super|cooled", "super¦heated")
ussDB("super.cooled", "super¦heated")
ussPDB("super|cooled¦super|heated")

sstb("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p')
sstb("|", 'a|b|c|d', 'e|f|g|h', 'i|j|k|l', 'm|n|o|p', name = 'original', part = 'letter')
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}},
\code{\link{markdown}},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{tocase}()},
\code{\link{weave}()}

Other chars: 
\code{\link{chn}()},
\code{\link{max_nch}()},
\code{\link{revstr}()},
\code{\link{spaces}()}
}
\concept{chars}
\concept{strings}
