% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fx.R
\docType{data}
\name{fx.}
\alias{fx.}
\alias{f0.}
\alias{f1.}
\alias{ff.}
\title{Bare-bones wrappers for \code{\link[base]{ifelse}}.}
\format{
An object of class \code{NULL} of length 0.
}
\usage{
fx.

f0.(test, yes, no)

f1.(test, yes, no)

ff.(test, yes, no)
}
\arguments{
\item{test}{A logical scalar (\code{f0.}) or a logical vector (\code{f1.} and
\code{ff.}).}

\item{yes, no}{Any object (\code{f0.}), an atomic scalar \code{f1.}, or an
atomic vector of the same length as \code{test}.}
}
\value{
An arbitrary type of object (\code{f0.}) or an atomic vector
(\code{f1.} and \code{ff.}).
}
\description{
Functions wrapping \code{\link[base]{ifelse}}, expecting (but
not checking for) characteristics of \code{test}, \code{yes}, and
\code{no}.
}
\section{Functions}{
\itemize{
\item \code{f0.}: If \code{test} is logical scalar \code{TRUE}, return
\code{yes} (all of it), otherwise return \code{no} (all of it).

\item \code{f1.}: Create a new vector the same length as \code{test}, placing
the atomic scalar value \code{yes} into the elements of the new vector
corresponding to the \code{TRUE} elements of \code{test} and placing the
atomic scalar value in \code{no} into elements of the new vector
corresponding to \code{FALSE} elements of \code{test}.

\item \code{ff.}: Create a new vector the same length as \code{test}, placing
values of atomic vector \code{yes} corresponding to \code{TRUE} elements of
\code{test} into those same elements of the new vector and placing values
of atomic vector \code{no} corresponding to \code{FALSE} elements of
\code{test} into those same elements of the new vector.
}}

\keyword{datasets}
