% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ss.R
\name{ss.}
\alias{ss.}
\alias{ss}
\alias{ss1}
\alias{ssP}
\alias{ssD}
\alias{ssB}
\alias{ssPD}
\alias{ssPB}
\alias{ssDB}
\alias{ssPDB}
\alias{ch}
\alias{uch}
\alias{sstb}
\title{Split strings and select/check for elements}
\usage{
ss.()

ss(d, ..., trm = T, sqz = T, u = F, n = NULL)

ss1(..., trm = T, sqz = T, n = NULL, u = F)

ssP(..., trm = T, sqz = T, n = NULL, u = F)

ssD(..., trm = T, sqz = T, n = NULL, u = F)

ssB(..., trm = T, sqz = T, n = NULL, u = F)

ssPD(..., trm = T, sqz = T, n = NULL, u = F)

ssPB(..., trm = T, sqz = T, n = NULL, u = F)

ssDB(..., trm = T, sqz = T, n = NULL, u = F)

ssPDB(..., trm = T, sqz = T, n = NULL, u = F)

ch(..., trm = T, sqz = T, n = NULL, u = F)

uch(..., trm = T, sqz = T, n = NULL)

sstb(x, d, name = "string", parts = "part")
}
\arguments{
\item{d}{\link[cmp_chr_vec]{Complete character vec} delimiter or
delimiters to use in splitting strings.}

\item{...}{An arbitrary number of objects to be \link[a]{atomized}
before splitting.}

\item{trm}{\link[cmp_lgl_scl]{Complete logical scalar} indicating whether to
trim white space from each side of each element of the result.}

\item{sqz}{link[cmp_lgl_scl]{Complete logical scalar} indicating whether to
squeeze the result by removing either empty strings (for \code{ss}
functions) or characters that are neither letters, digits, nor spaces (for
\code{ch}).}

\item{u}{\link[cmp_lgl_scl]{Complete logical scalar} indicating whether to
reduce the result to unique values.}

\item{n}{An optional \link[cmp_psw_scl]{complete positive-valued whole-number
scalar} specifying an element to be extracted from the result.}

\item{x}{\link[chr_vec]{character vec} of
string(s) to be split.}

\item{name}{\link[cmp_scl_scl]{Complete character scalar} name of the
variable to hold the original strings.}

\item{part}{\link[cmp_chr_vec]{Complete character vec}
with as many elements as each string will be split into for naming
variables containing a part of each string.}
}
\value{
Either a \link[chr_vec]{character vector}, a \link{chr_vls}{character
  vlist}, or a \link[chr_dtf]{character dtf}.
}
\description{
\strong{\code{ss}} splits strings using the delimiter(s) in
\code{d} following these sequential steps:\enumerate{
\item Reduce \code{...} to an atomic vector containing the constituent
atomic elements of each argument in \code{...}.
\item Convert the result to mode character.
\item Replace each element of the result with that element's constituent
parts as delimited by \code{d.}, producing a potentially longer
character vector.
\item If \code{n} is not \code{NULL}, extracts the \code{n}-th
elements(s) from the result.
\item If \code{trm} is \code{TRUE}, trims white space (i.e., spaces,
tabs, newlines) from both ends of each element of the result.
\item If \code{sqz} is \code{TRUE}, removes leading and trailing white
space and replaces any multi-character strings of white-space
strings inside the result with a single space.
\item If \code{u} is \code{TRUE}, reduces the result to unique values.    }
\strong{\code{ch}} splits strings into their constituent characters
following these sequential steps:\enumerate{
\item Reduce \code{...} to an atomic vector containing the constituent
atomic elements of each argument in \code{...}.
\item Convert the result to mode character.
\item Replace each element of the result with a character vector of that
element's constituent characters, producing a potentially longer
character vector.
\item If \code{trm} is \code{TRUE}, trims white space (i.e., spaces,
tabs, newlines) from both ends of each element of the result.
\item If \code{sqz} is \code{TRUE}, removes leading and trailing white
space and replaces any multi-character strings of white-space
strings inside the result with a single spac\
\item If \code{n} is not \code{NULL}, extracts the \code{n}-th
elements(s) from the result.
\item If \code{u} is \code{TRUE}, reduces the result to unique values.    }
\strong{Extensions}
\cr Functions are extended for specific delimiters, signified by the
following suffixes on function names:\tabular{lll}{
SUFFIX      \tab SUFFIX        \tab DELIMITER                           \cr
CHARACTER   \tab NAME          \tab INVOKED                             \cr
\code{'1'}  \tab Space         \tab \code{" "}                          \cr
\code{'P'}  \tab Pipe          \tab \code{"|"}                          \cr
\code{'D'}  \tab Dot           \tab \code{"."}                          \cr
\code{'B'}  \tab Broken pipe   \tab \code{"¦"}                            }
}
\section{Functions}{
\itemize{
\item \code{ss()}: Flexible fixed-string string splitting function.

\item \code{ss1()}: Split strings using a pipe (\code{'|'}) delimiter.

\item \code{ssP()}: Split strings using a pipe (\code{'|'}) delimiter.

\item \code{ssD()}: Split strings using a dot/period (\code{'.'}) delimiter.

\item \code{ssB()}: Split strings using a broken pipe (\code{'¦'}) delimiter.

\item \code{ssPD()}: Split a string using pipe and dot delimiters.

\item \code{ssPB()}: Split a string using pipe and broken pipe delimiters.

\item \code{ssDB()}: Split a string using dot and broken pipe delimiters.

\item \code{ssPDB()}: Split a string using pipe, dot, and broken pipe delimiters.

\item \code{ch()}: Split a string into constituent characters.

\item \code{uch()}: Split a string into unique constituent characters.

\item \code{sstb()}: Split strings and place results in a tibble, including
original values

}}
\seealso{
Other strings: 
\code{\link{blank.}()},
\code{\link{charn.}()},
\code{\link{delim.}()},
\code{\link{fsub.}()},
\code{\link{ipat.}()},
\code{\link{max_nch.}()},
\code{\link{mkstr.}()},
\code{\link{ox.}()},
\code{\link{pgrid.}()},
\code{\link{rev_str.}()},
\code{\link{spacing.}()},
\code{\link{tocase.}()},
\code{\link{weave.}()},
\code{\link{xpr.}()}
}
\concept{strings}
