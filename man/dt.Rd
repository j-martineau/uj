% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dt.R
\encoding{UTF-8}
\name{dt}
\alias{dt}
\alias{asdt}
\alias{isdt}
\alias{iedt}
\alias{dtsub}
\alias{dtcols}
\alias{dtmerge}
\alias{dtrows}
\alias{dtwide}
\title{Wrappers of \code{data.table} functions}
\usage{
asdt(x, keep.rownames = FALSE, ..., say = TRUE)

isdt(...)

iedt(x, say = TRUE)

dtsub(x, ir, ic)

dtcols(x, ic)

dtmerge(
  x,
  y,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  all = FALSE,
  all.x = all,
  all.y = all,
  sort = TRUE,
  suffixes = c(".x", ".y"),
  no.dups = TRUE,
  allow.cartesian = base::getOption("datatable.allow.cartesian"),
  say = TRUE
)

dtrows(x, ir)

dtwide(
  data,
  formula,
  fun.aggregate = NULL,
  sep = "_",
  ...,
  margins = NULL,
  subset = NULL,
  fill = NULL,
  drop = TRUE,
  value.var = data.table:::guess(data),
  verbose = base::getOption("datatable.verbose"),
  say = TRUE
)
}
\arguments{
\item{x}{An object for \code{asdt}, \code{isdt}, and \code{iedt}. A \code{\link[data.table]{data.table}} for all others.}

\item{keep.rownames}{Default is \code{FALSE}. If \code{TRUE}, adds the input object's names as a separate column named \code{"rn"}. \code{keep.rownames = "id"} names the column \code{"id"} instead.}

\item{...}{Additional arguments to be passed to or from other methods.}

\item{say}{\code{TRUE} or \code{FALSE} indicating whether to notify user of starting a potentially time-consuming process (converting to \code{data.table}, joining two large \code{data.table}s, and reshaping from long to wide).}

\item{ir, ic}{\link[=cmp_ind_vec]{Complete indexer vecs} or \link[=cmp_chr_vec]{complete character vecs} identifying rows and columns of \code{x}, respectively.}

\item{by}{A vector of shared column names in \code{x} and \code{y} to merge on.
This defaults to the shared key columns between the two tables.
If \code{y} has no key columns, this defaults to the key of \code{x}.}

\item{by.x, by.y}{Vectors of column names in \code{x} and \code{y} to merge on.}

\item{all}{logical; \code{all = TRUE} is shorthand to save setting both
\code{all.x = TRUE} and \code{all.y = TRUE}.}

\item{all.x}{logical; if \code{TRUE}, then extra rows will be added to the
output, one for each row in \code{x} that has no matching row in \code{y}.
These rows will have 'NA's in those columns that are usually filled with values
from \code{y}.  The default is \code{FALSE}, so that only rows with data from both
\code{x} and \code{y} are included in the output.}

\item{all.y}{logical; analogous to \code{all.x} above.}

\item{sort}{logical. If \code{TRUE} (default), the merged \code{data.table} is
sorted by setting the key to the \code{by / by.x} columns. If \code{FALSE}, the
result is not sorted.}

\item{suffixes}{A \code{character(2)} specifying the suffixes to be used for
making non-\code{by} column names unique. The suffix behaviour works in a similar
fashion as the \code{\link{merge.data.frame}} method does.}

\item{no.dups}{logical indicating that \code{suffixes} are also appended to
non-\code{by.y} column names in \code{y} when they have the same column name
as any \code{by.x}.}

\item{allow.cartesian}{See \code{allow.cartesian} in \code{\link[data.table]{[.data.table}}.}

\item{data}{ A \code{data.table}.}

\item{formula}{A formula of the form LHS ~ RHS to cast, see Details.}

\item{fun.aggregate}{Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to \code{length} with a message.

  To use multiple aggregation functions, pass a \code{list}; see Examples. }

\item{sep}{Character vector of length 1, indicating the separating character in variable names generated during casting. Default is \code{_} for backwards compatibility. }

\item{margins}{Not implemented yet. Should take variable names to compute margins on. A value of \code{TRUE} would compute all margins.}

\item{subset}{Specified if casting should be done on a subset of the data. Ex: \code{subset = .(col1 <= 5)} or \code{subset = .(variable != "January")}.}

\item{fill}{Value with which to fill missing cells. If \code{fun.aggregate} is present, takes the value by applying the function on a 0-length vector.}

\item{drop}{\code{FALSE} will cast by including all missing combinations.

  \code{c(FALSE, TRUE)} will only include all missing combinations of formula \code{LHS}; \code{c(TRUE, FALSE)} will only include all missing combinations of formula RHS. See Examples.}

\item{value.var}{Name of the column whose values will be filled to cast. Function \code{guess()} tries to, well, guess this column automatically, if none is provided.

  Cast multiple \code{value.var} columns simultaneously by passing their names as a \code{character} vector. See Examples. }

\item{verbose}{Not used yet. May be dropped in the future or used to provide informative messages through the console.}
}
\value{
A data.table.
}
\description{
Functions to check if an object is \code{data.table}, or coerce it if possible.
}
\details{
\tabular{ll}{  \code{dtmerge}   \tab Thinly wraps \code{\link[data.table]{merge}}.         \cr
  \code{dtwide}    \tab Thinly wraps \code{\link[data.table]{dcast}}.         \cr
  \code{dtrows}    \tab Selects rows.                                         \cr
  \code{dtcols}    \tab Selects columns without \code{x[ , ..var]}.                \cr
  \code{dtsub}     \tab Selects a subtable without \code{x[row.var, ..col.var]}.   \cr
  \code{asdt}      \tab Thinly wraps \code{\link[data.table]{as.data.table}}. \cr
  \code{isdt}      \tab Thinly wraps \code{\link[data.table]{is.data.table}}. \cr
  \code{iedt}      \tab Convert to \code{data.table}, if needed.                     }
}
\examples{
nn = c(a=0.1, b=0.2, c=0.3, d=0.4)
as.data.table(nn)
as.data.table(nn, keep.rownames=TRUE)
as.data.table(nn, keep.rownames="rownames")

# char object not converted to factor
cc = c(X="a", Y="b", Z="c")
as.data.table(cc)
as.data.table(cc, keep.rownames=TRUE)
as.data.table(cc, keep.rownames="rownames")

mm = matrix(1:4, ncol=2, dimnames=list(c("r1", "r2"), c("c1", "c2")))
as.data.table(mm)
as.data.table(mm, keep.rownames=TRUE)
as.data.table(mm, keep.rownames="rownames")
as.data.table(mm, key="c1")

ll = list(a=1:2, b=3:4)
as.data.table(ll)
as.data.table(ll, keep.rownames=TRUE)
as.data.table(ll, keep.rownames="rownames")

DF = data.frame(x=rep(c("x","y","z"),each=2), y=c(1,3,6), row.names=LETTERS[1:6])
as.data.table(DF)
as.data.table(DF, keep.rownames=TRUE)
as.data.table(DF, keep.rownames="rownames")

DT = data.table(x=rep(c("x","y","z"),each=2), y=c(1:6))
as.data.table(DT)
as.data.table(DT, key='x')

ar = rnorm(27)
ar[sample(27, 15)] = NA
dim(ar) = c(3L,3L,3L)
as.data.table(ar)
}
\seealso{
Other wraps: 
\code{\link{basics}()},
\code{\link{dp}},
\code{\link{ggp}()},
\code{\link{gr}},
\code{\link{rd}},
\code{\link{sca}()},
\code{\link{tb}()}
}
\concept{wraps}
