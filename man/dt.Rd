% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dt.R
\encoding{UTF-8}
\name{dt}
\alias{dt}
\alias{as_dt}
\alias{is_dt}
\alias{ie_dt}
\alias{dt_sub}
\alias{dt_cols}
\alias{dt_merge}
\alias{dt_rows}
\alias{dt_wide}
\title{Wrappers of \code{data.table} functions}
\usage{
as_dt(x, keep.rownames = FALSE, ...)

is_dt(x)

ie_dt(x)

dt_sub(x, row, col)

dt_cols(x, col)

dt_merge(
  x,
  y,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  all = FALSE,
  all.x = all,
  all.y = all,
  sort = TRUE,
  suffixes = c(".x", ".y"),
  no.dups = TRUE,
  allow.cartesian = base::getOption("datatable.allow.cartesian"),
  .SAY = TRUE
)

dt_rows(x, r)

dt_wide(
  data,
  formula,
  fun.aggregate = NULL,
  sep = "_",
  ...,
  margins = NULL,
  subset = NULL,
  fill = NULL,
  drop = TRUE,
  value.var = data.table:::guess(data),
  verbose = base::getOption("datatable.verbose"),
  .SAY = TRUE
)
}
\arguments{
\item{x}{Any object for \code{as_dt}, \code{is_dt}, and \code{ie_dt}. A \code{\link[data.table]{data.table}} for all others.}

\item{...}{Not used at this time.}

\item{row, col}{\link[=cmp_ind_vec]{Complete indexer vecs} or \link[=cmp_chr_vec]{complete character vecs} identifying rows and columns of \code{x}, respectively.}

\item{y}{A data.table to be merged with \code{x}.}

\item{by}{A vector of shared column names in \code{x} and \code{y} to merge on.
This defaults to the shared key columns between the two tables.
If \code{y} has no key columns, this defaults to the key of \code{x}.}

\item{by.x, by.y}{Vectors of column names in \code{x} and \code{y} to merge on.}

\item{all}{logical; \code{all = TRUE} is shorthand to save setting both
\code{all.x = TRUE} and \code{all.y = TRUE}.}

\item{all.x}{logical; if \code{TRUE}, then extra rows will be added to the
output, one for each row in \code{x} that has no matching row in \code{y}.
These rows will have 'NA's in those columns that are usually filled with values
from \code{y}.  The default is \code{FALSE}, so that only rows with data from both
\code{x} and \code{y} are included in the output.}

\item{all.y}{logical; analogous to \code{all.x} above.}

\item{sort}{logical. If \code{TRUE} (default), the merged \code{data.table} is
sorted by setting the key to the \code{by / by.x} columns. If \code{FALSE}, the
result is not sorted.}

\item{suffixes}{A \code{character(2)} specifying the suffixes to be used for
making non-\code{by} column names unique. The suffix behaviour works in a similar
fashion as the \code{\link{merge.data.frame}} method does.}

\item{no.dups}{logical indicating that \code{suffixes} are also appended to
non-\code{by.y} column names in \code{y} when they have the same column name
as any \code{by.x}.}

\item{allow.cartesian}{See \code{allow.cartesian} in \code{\link[data.table]{[.data.table}}.}

\item{.SAY}{Logical scalar indicating whether to update user on progress.}

\item{data}{ A \code{data.table}.}

\item{formula}{A formula of the form LHS ~ RHS to cast, see Details.}

\item{fun.aggregate}{Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to \code{length} with a message.

  To use multiple aggregation functions, pass a \code{list}; see Examples. }

\item{sep}{Character vector of length 1, indicating the separating character in variable names generated during casting. Default is \code{_} for backwards compatibility. }

\item{margins}{Not implemented yet. Should take variable names to compute margins on. A value of \code{TRUE} would compute all margins.}

\item{subset}{Specified if casting should be done on a subset of the data. Ex: \code{subset = .(col1 <= 5)} or \code{subset = .(variable != "January")}.}

\item{fill}{Value with which to fill missing cells. If \code{fun.aggregate} is present, takes the value by applying the function on a 0-length vector.}

\item{drop}{\code{FALSE} will cast by including all missing combinations.

  \code{c(FALSE, TRUE)} will only include all missing combinations of formula \code{LHS}; \code{c(TRUE, FALSE)} will only include all missing combinations of formula RHS. See Examples.}

\item{value.var}{Name of the column whose values will be filled to cast. Function \code{guess()} tries to, well, guess this column automatically, if none is provided.

  Cast multiple \code{value.var} columns simultaneously by passing their names as a \code{character} vector. See Examples. }

\item{verbose}{Not used yet. May be dropped in the future or used to provide informative messages through the console.}
}
\value{
A data.table.
}
\description{
Fast merge of two \code{data.table}s. The \code{data.table} method behaves
very similarly to that of \code{data.frame}s except that, by default, it attempts to merge

\itemize{
  \item at first based on the shared key columns, and if there are none,
  \item then based on key columns of the first argument \code{x}, and if there
  are none,
  \item then based on the common columns between the two \code{data.table}s.
}

Set the \code{by}, or \code{by.x} and \code{by.y} arguments explicitly to override this default.
}
\details{
\tabular{ll}{  \code{dt_merge}   \tab Thinly wraps \code{\link[data.table]{merge}}.         \cr
  \code{dt_wide}    \tab Thinly wraps \code{\link[data.table]{dcast}}.         \cr
  \code{dt_rows}    \tab Selects rows.                                         \cr
  \code{dt_cols}    \tab Selects columns without \code{x[ , ..var]}.                \cr
  \code{dt_sub}     \tab Selects a subtable without \code{x[row.var, ..col.var]}.   \cr
  \code{as_dt}      \tab Thinly wraps \code{\link[data.table]{as.data.table}}. \cr
  \code{is_dt}      \tab Thinly wraps \code{\link[data.table]{is.data.table}}. \cr
  \code{ie_dt}      \tab Convert to \code{data.table}, if needed.                     }
}
\examples{
(dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))
(dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))
merge(dt1, dt2)
merge(dt1, dt2, all = TRUE)

(dt1 <- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A"))
(dt2 <- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A"))
merge(dt1, dt2, allow.cartesian=TRUE)

(dt1 <- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(1:3, 2)], X = 1:6, key = "A,B"))
(dt2 <- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(2:4, 2)], Y = 6:1, key = "A,B"))
merge(dt1, dt2)
merge(dt1, dt2, by="B", allow.cartesian=TRUE)

# test it more:
d1 <- data.table(a=rep(1:2,each=3), b=1:6, key="a,b")
d2 <- data.table(a=0:1, bb=10:11, key="a")
d3 <- data.table(a=0:1, key="a")
d4 <- data.table(a=0:1, b=0:1, key="a,b")

merge(d1, d2)
merge(d2, d1)
merge(d1, d2, all=TRUE)
merge(d2, d1, all=TRUE)

merge(d3, d1)
merge(d1, d3)
merge(d1, d3, all=TRUE)
merge(d3, d1, all=TRUE)

merge(d1, d4)
merge(d1, d4, by="a", suffixes=c(".d1", ".d4"))
merge(d4, d1)
merge(d1, d4, all=TRUE)
merge(d4, d1, all=TRUE)

# new feature, no need to set keys anymore
set.seed(1L)
d1 <- data.table(a=sample(rep(1:3,each=2)), z=1:6)
d2 <- data.table(a=2:0, z=10:12)
merge(d1, d2, by="a")
merge(d1, d2, by="a", all=TRUE)

# new feature, using by.x and by.y arguments
setnames(d2, "a", "b")
merge(d1, d2, by.x="a", by.y="b")
merge(d1, d2, by.x="a", by.y="b", all=TRUE)
merge(d2, d1, by.x="b", by.y="a")
}
\seealso{
Other wraps: 
\code{\link{basics}()},
\code{\link{dp}()},
\code{\link{ggp}()},
\code{\link{gr}},
\code{\link{rd}()},
\code{\link{sca}()},
\code{\link{tb}()}
}
\concept{wraps}
