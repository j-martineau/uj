% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uj_logicals.R
\name{uj_logicals}
\alias{uj_logicals}
\alias{not}
\alias{and}
\alias{or}
\alias{nor}
\alias{one}
\alias{TEST}
\alias{ANY}
\alias{ALL}
\alias{NOR}
\alias{ONE}
\alias{TWO}
\alias{tests}
\alias{w}
\alias{nors}
\alias{anys}
\alias{alls}
\alias{ones}
\alias{twos}
\alias{is_in}
\alias{not_in}
\alias{has}
\alias{lacks}
\title{Extended and Error-Checked Logical Functions}
\usage{
not(x, na = "err")

and(x, y, na = "err")

or(x, y, na = "err")

nor(x, y, na = "err")

one(x, y, na = "err")

TEST(x, na = FALSE, err = NA)

ANY(..., err = NA)

ALL(..., err = NA)

NOR(..., err = NA)

ONE(..., err = NA)

TWO(..., err = NA)

tests(..., na = F, a = F, not = F, across = NA, within = NA)

w(..., not = F, na = F, a = F)

nors(..., na = F, a = F, across = T, within = F)

anys(..., na = F, a = F, across = T, within = F)

alls(..., na = F, a = F, across = T, within = F)

ones(..., na = F, a = F, across = T, within = F)

twos(..., na = F, a = F, across = T, within = F)

is_in(x, y, not = F, na = F, agg = NA)

not_in(x, y, na = F, agg = NA)

has(x, y, na = T, agg = NA)

lacks(x, y, na = T, agg = NA)
}
\arguments{
\item{x}{\link[=atm_lgl]{Atomic logical object} for all functions other than
\code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an
atomic object.}

\item{na}{A non-\code{NA} logical scalar indicating what value should replace
\code{NA} values.}

\item{y}{\link[=atm_lgl]{Atomic logical object} for all functions other than
\code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an
atomic object \link[=compatible]{compatible} with \code{x}.}

\item{err}{A non-\code{NA} logical scalar. \code{err = TRUE} indicates
\code{TRUE} should be substituted for non-logical values, \code{err =
  FALSE} indicates \code{FALSE} should be substituted for non-logical values,
\code{err = NA} indicates an error should be thrown if a non-logical value
is encountered.}

\item{...}{An arbitrary number of \link[=lgl_vec]{logical vecs} to be
processed.}

\item{a}{A non-\code{NA} logical scalar indicating whether to atomize
\code{...} before processing. This creates a single atomic vector of all
atomic elements contained in all \code{...} arguments and effectively
changes the behavior of \code{or} to \code{any}, \code{and} to \code{all},
\code{not} to \code{!any}, and \code{some} and \code{most} to count the
total number of \code{TRUE} values rather than the number of \code{TRUE}
values in the same location of recycled arguments from \code{...} (but with
error checking and flexible \code{NA} value handling.)}

\item{not}{A non-\code{NA} logical scalar indicating whether to negate values
in arguments supplied in \code{...} before processing.}

\item{across, within}{\link[=cmp_chr_scl]{Complete character scalars} in
\code{c('', 'none', 'one', 'any', 'some', 'all')} indicating no across or
within argument counting of \code{TRUE} values.}

\item{agg}{\link[=cmp_chr_scl]{Complete character scalar} in \code{c('nor',
  'one', 'any', 'two', 'all')} used to specify, respectively, that 0, 1, any,
2 or more, and all arguments must be \code{TRUE}.}
}
\description{
This family of functions extends base logical functions as
described in the following table.\tabular{lll}{
\strong{FUNCTION}   \tab \strong{ACTION}  \tab \strong{NOTES}           \cr
\code{not}      \tab \code{!x}                      \tab \code{..C.E....}              \cr
\code{and}      \tab \code{x & y}                   \tab \code{..CDE....}              \cr
\code{or}       \tab \code{x | y}                   \tab \code{..CDE....}              \cr
\code{nor}      \tab \code{!(x | y)}                \tab \code{..CDE....}              \cr
\code{one}      \tab \code{xor(x, y)}               \tab \code{..CDE....}              \cr
\code{is_in}    \tab \code{x \%in\% y}                \tab \code{A...E..H.}              \cr
\code{not_in}   \tab \code{!(x \%in\% y)}             \tab \code{A...E..H.}              \cr
\code{has}      \tab \code{y \%in\% x}                \tab \code{A...E..H.}              \cr
\code{lacks}    \tab \code{!(y \%in\% x)}             \tab \code{A...E..H.}              \cr
\code{TEST}     \tab \code{isTRUE(.)}               \tab \code{.B..EF...}              \cr
\code{ANY}      \tab \code{any(.)}                  \tab \code{.B.DEF..I}              \cr
\code{ALL}      \tab \code{all(.)}                  \tab \code{.B.DEF..I}              \cr
\code{NOR}      \tab \verb{length(which(.)) == 0}   \tab \code{.B.DEF..I}              \cr
\code{ONE}      \tab \verb{length(which(.)) == 1}   \tab \code{.B.DEF..I}              \cr
\code{TWO}      \tab \verb{length(which(.)) > 1}    \tab \code{.B.DEF..I}              \cr
\code{tests}    \tab generalized \code{isTRUE(.)}   \tab \code{..CDEFG..}              \cr
\code{w}        \tab generalized \code{which(.)}    \tab \code{..CDEFGH.}              \cr
\code{nors}     \tab generalized \code{NOR(.)}      \tab \code{..CDEFGH.}              \cr
\code{anys}     \tab generalized \code{ANY(.)}      \tab \code{..CDEFGH.}              \cr
\code{alls}     \tab generalized \code{ALL(.)}      \tab \code{..CDEFGH.}              \cr
\code{ones}     \tab generalized \code{ONE(.)}      \tab \code{..CDEFGH.}              \cr
\code{twos}     \tab generalized \code{TWO(.)}      \tab \code{..CDEFGH.}                }
NOTES
\cr \code{A. }Expects \link[=compatible]{compatible} atomic vector \code{x} & \code{y}.
\cr \code{B. }Expects logical scalar \code{x} or \code{...} arguments.
\cr \code{C. }Expects logical \code{x}, \code{y}, and/or \code{...} arguments.
\cr \code{D. }Expects conformable \code{x}, \code{y}, and/or \code{...} arguments.
\cr \code{E. }Has options for handling \code{NA} values.
\cr \code{F. }Has options for handling unexpected \code{...} arguments.
\cr \code{G. }Has options for across vs. within testing of \code{...} arguments.
\cr \code{H. }Has aggregation options.
\cr \code{I. }Operates left to right, returning a result as soon as confirmed.
}
\seealso{
Other extensions: 
\code{\link{atomize}},
\code{\link{binfuns}},
\code{\link{callers}()},
\code{\link{case}()},
\code{\link{dots_uj}},
\code{\link{envir_vals}},
\code{\link{ex}()},
\code{\link{failsafe}()},
\code{\link{files_uj}},
\code{\link{fork}()},
\code{\link{fsub}()},
\code{\link{is_failsafe}},
\code{\link{is_unq}()},
\code{\link{make_uj}},
\code{\link{n_is}()},
\code{\link{n_th}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{os}()},
\code{\link{pause}()},
\code{\link{ply}()},
\code{\link{put}()},
\code{\link{reclass}()},
\code{\link{recycling}},
\code{\link{removal}},
\code{\link{run}()},
\code{\link{stats0}},
\code{\link{swap}()},
\code{\link{xb}()}

Other logicals: 
\code{\link{binfuns}},
\code{\link{is_failsafe}}
}
\concept{extensions}
\concept{logicals}
