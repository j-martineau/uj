% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppp.R
\encoding{UTF-8}
\name{PROPS}
\alias{PROPS}
\alias{ppp}
\alias{ppp_or_funs}
\alias{all_props}
\alias{prop_funs}
\alias{is_prop_fun}
\alias{is_prop}
\alias{is_prop_combo}
\alias{is_prop_spec}
\alias{props_from_spec}
\alias{combos_from_spec}
\alias{props_from_combo}
\alias{PPP}
\alias{nll_or}
\alias{na0_or}
\alias{prop_defs}
\alias{prop_verbose}
\alias{combo_concise}
\alias{spec_concise}
\title{All purpose property checking}
\usage{
PROPS()

ppp(x)

ppp_or_funs()

all_props(as.dtf = F)

prop_funs(as.dtf = F)

is_prop_fun(x)

is_prop(x)

is_prop_combo(x)

is_prop_spec(x)

props_from_spec(x, valid = all_props())

combos_from_spec(x)

props_from_combo(x)

PPP(x, spec, ...)

nll_or(x, spec, ...)

na0_or(x, spec, ...)

prop_defs()

prop_verbose(x, print = TRUE)

combo_concise(x)

spec_concise(x)
}
\arguments{
\item{x}{An R object.}

\item{as.dtf}{\code{TRUE} or \code{FALSE} indicating whether to return the result as a data.frame with column \code{1} containing property values and column \code{2} containing the property families.}

\item{valid}{A \link[=cmp_chr_vec]{complete character vec} containing all properties considered valid.}

\item{spec}{A \link[=cmp_chr_scl]{complete character scalar} containing one or more values from \code{ppp_vals()} separated by pipes and/or underscores. Combinations of properties can be specified by separating them with underscores. Separating properties or combinations of properties with pipes will result in a value of \code{TRUE} if any of them applies to \code{x}.}

\item{...}{
  Arguments passed on to \code{\link[=meets]{meets}}
  \describe{
    \item{\code{}}{}
  }}

\item{print}{\code{TRUE} or \code{FALSE} indicating whether to print the property definition to the console.}
}
\description{
This family of functions brings together a variety of families defined in this and gives users the ability to manage object properties in a granular and concise manner.
\cr\cr \strong{Property families defined by this package}
\tabular{ll}{  \code{\link{bbb}}   \tab basic properties                       \cr
  \code{\link{ccc}}   \tab xclass (extended class)                \cr
  \code{\link{ddd}}   \tab defined.D (defined dimensionality)     \cr
  \code{\link{eee}}   \tab effective.D (effective dimensionality) \cr
  \code{\link{iii}}   \tab integrity (completeness, uniqueness)   \cr
  \code{\link{mmm}}   \tab xmode (extended modes)                 \cr
  \code{\link{sss}}   \tab shape (geometric shape)                  }
This family uses concise and flexible \emph{property specs} as defined in the following table.
\tabular{ll}{  \emph{single}   \tab \link[=CH3]{3-char} scalars (i.e., \code{all(nchar(.) == 3)} with all values in \code{all_props()}. For example, \verb{'ord', 'dtf', 'd2d',} and \code{'rct'} are \emph{single} property specs.                                                                                                                                                                 \cr   \tab   \cr
  \emph{combo}    \tab Character scalars containing multiple underscore-delimited \emph{single} properties, indicating that those \emph{single} properties must co-occur. For example, the \emph{combo} property spec \code{'ord_dtf_d2d_rct'} (or an equivalent underscore-delimited permutation) indicates that all four \emph{single} properties must co-occur to satisfy the spec. \cr   \tab   \cr
  \emph{option}   \tab Character scalars containing multiple pipe-delimited \emph{combo} and/or \emph{single} property specs. For example, the \emph{option} property spec \code{'ord|dtf_d2d|dtf_rct'} would be satisfied by an object with \emph{single} property \code{'ord'}, \emph{combo} property \code{'dtf_d2d'}, \strong{or} \emph{combo} property \code{'dtf_rct'}.                                        \cr   \tab   \cr
  \emph{flex}     \tab A \emph{single}, \emph{combo}, or \emph{option} property spec as defined above.                                                                                                                                                                                                                                                                                      }
}
\details{
\strong{Functions for property spec decomposition}
\tabular{ll}{  \code{props_from_combo}   \tab What are the constituent \emph{single} properties of a \emph{combo} property spec? \cr   \tab   \cr
  \code{combo_from_spec}    \tab What are the constituent \emph{combo} properties in a \emph{flex} property spec?   \cr   \tab   \cr
  \code{props_from_spec}    \tab What are the \emph{unique} constituent \emph{single} properties in a \emph{flex} property spec?        }
\strong{Functions to check whether a value is a valid property spec}
\tabular{ll}{  \code{is_prop_combo}   \tab Is \code{combo} a valid \emph{combo} property spec?                    \cr   \tab   \cr
  \code{is_prop_spec}    \tab Is \code{spec} a valid \emph{flex} property spec?                      \cr   \tab   \cr
  \code{is_prop_fun}     \tab Is \code{fun} the name of a dedicated property checking function? \cr   \tab   \cr
  \code{is_prop}         \tab Is \code{prop} a valid \emph{single} property?                                        }
\strong{Functions to define properties and property specs}
\tabular{ll}{  \code{combo_concise}   \tab How is a \emph{combo} property spec (concisely) defined?                       \cr   \tab   \cr
  \code{spec_concise}    \tab How is an \emph{options} property spec (concisely) defined?                    \cr   \tab   \cr
  \code{prop_verbose}    \tab How is a \emph{single} property (verbosely) defined?                           \cr   \tab   \cr
  \code{prop_defs}       \tab What are the definitions of all possible \emph{single} properties (returned as a data.frame)? }
\strong{Functions to list names of dedicated property-checking functions}
\tabular{ll}{  \code{ppp_or_funs}   \tab What dedicated functions check \code{x} for either special values or a match to a \emph{flex} property spec? \cr   \tab   \cr
  \code{prop_funs}     \tab What dedicated functions check \code{x} for a match to a specific \emph{single} or \emph{combo} property?         \cr   \tab   \cr
  \code{all_props}     \tab What is the complete set of all possible \emph{single} properties?                                                     }
\strong{Functions to check object against arbitrary property specs}
\tabular{ll}{  \code{nas_or}   \tab Is \code{x} either \code{NA} or a match to the \emph{flex} property spec in \code{Spec}?  \cr   \tab   \cr
  \code{nll_or}   \tab Is \code{x} either \code{NULL} or a match to the \emph{flex} property spec in \code{Spec} \cr   \tab   \cr
  \code{ppp}      \tab Is \code{x} a match to the \emph{flex} property spec in \code{Spec}?                                }
\strong{Function to list all of an object's} single \strong{properties across property families}
\tabular{ll}{  \code{ppp}   \tab What are all of \code{x}'s \emph{single} properties compiled from all property families? }
For convenience, property functions from other function families are also described below.
\cr\cr \strong{Functions to list all} single \strong{properties in a property family}
\tabular{ll}{  \code{bbb_props}   \tab \link[=bbb]{basic}                    \cr
  \code{ccc_props}   \tab \link[=ccc]{extended class}           \cr
  \code{ddd_props}   \tab \link[=ddd]{defined dimensionality}   \cr
  \code{eee_props}   \tab \link[=eee]{effective dimensionality} \cr
  \code{iii_props}   \tab \link[=iii]{integrity}                \cr
  \code{mmm_props}   \tab \link[=mmm]{extended mode}            \cr
  \code{sss_props}   \tab \link[=sss]{shape}                      }
\strong{Functions to list names of dedicated property-checking functions}
\tabular{ll}{  \code{cmp_mmm_ccc_funs}   \tab integrity = \code{'cmp'} + extended mode + extended class \cr
  \code{unq_mmm_ccc_funs}   \tab integrity = \code{'unq'} + extended mode + extended class \cr   \tab  }
\tabular{ll}{  \code{cmp_ccc_funs}   \tab integrity = \code{'cmp'} + extended class \cr
  \code{cmp_mmm_funs}   \tab integrity = \code{'cmp'} + extended mode  \cr
  \code{unq_ccc_funs}   \tab integrity = \code{'unq'} + extended class \cr
  \code{unq_mmm_funs}   \tab integrity = \code{'unq'} + extended mode  \cr
  \code{bbb_ccc_funs}   \tab basic + extended class               \cr
  \code{bbb_mmm_funs}   \tab basic + extended mode                \cr
  \code{mmm_ccc_funs}   \tab extended mode + extended class       \cr   \tab  }
\tabular{ll}{  \code{bbb_funs}   \tab \link[=bbb]{basic}                    \cr
  \code{ccc_funs}   \tab \link[=ccc]{extended class}           \cr
  \code{ddd_funs}   \tab \link[=ddd]{defined dimensionality}   \cr
  \code{eee_funs}   \tab \link[=eee]{effective dimensionality} \cr
  \code{iii_funs}   \tab \link[=iii]{integrity}                \cr
  \code{mmm_funs}   \tab \link[=mmm]{extended mode}            \cr
  \code{sss_funs}   \tab \link[=sss]{shape}                      }
\strong{Dedicated functions to check an object for a specific} combo \strong{or} single \strong{property}
\cr\cr For these functions, \code{{bbb}}, \code{{ccc}}, \code{{ddd}}, \code{{eee}}, \code{{iii}}, \code{{mmm}}, and \code{{sss}} are placeholders for any given basic, extended class, defined.D, effective.D, integrity, xmode, and shape properties, respectively.
\tabular{ll}{  \code{{bbb}}   \tab \link[=bbb]{basic} = \code{'{bbb}'}                    \cr
  \code{{ccc}}   \tab \link[=ccc]{extended class} = \code{'{ccc}'}           \cr
  \code{{ddd}}   \tab \link[=ddd]{defined dimensionality} = \code{'{ddd}'}   \cr
  \code{{eee}}   \tab \link[=eee]{effective dimensionality} = \code{'{eee}'} \cr
  \code{{iii}}   \tab \link[=iii]{integrity} = \code{'{iii}'}                \cr
  \code{{mmm}}   \tab \link[=mmm]{extended mode} = \code{'{mmm}'}            \cr
  \code{{sss}}   \tab \link[=sss]{shape} = \code{'{sss}'}                    \cr   \tab  }
\tabular{ll}{  \verb{cmp_\{ccc\}}   \tab integrity = \code{'cmp'} + extended class = \code{'{ccc}'} \cr
  \verb{cmp_\{mmm\}}   \tab integrity = \code{'cmp'} + extended mode = \code{'{mmm}'}  \cr
  \verb{unq_\{ccc\}}   \tab integrity = \code{'unq'} + extended class = \code{'{ccc}'} \cr
  \verb{unq_\{mmm\}}   \tab integrity = \code{'unq'} + extended mode = \code{'{mmm}'}          \cr   \tab  }
\tabular{ll}{  \verb{\{bbb\}_\{ccc\}}   \tab basic = \code{'{bbb}'} + extended class = \code{'{ccc}'}         \cr
  \verb{\{bbb\}_\{mmm\}}   \tab basic = \code{'{bbb}'} + extended mode = \code{'{mmm}'}          \cr
  \verb{\{mmm\}_\{ccc\}}   \tab extended mode = \code{'{mmm}'} + extended class = \code{'{ccc}'} \cr
  \verb{\{sss\}_\{ccc\}}   \tab shape = \code{'{sss}'} + extended class = \code{'{ccc}'}         \cr   \tab  }
\tabular{ll}{  \verb{cmp_\{mmm\}_\{ccc\}}   \tab integrity = \code{'cmp'} + extended mode = \code{'{mmm}'} + extended class = \code{'{ccc}'} \cr
  \verb{unq_\{mmm\}_\{ccc\}}   \tab integrity = \code{'unq'} + extended mode = \code{'{mmm}'} + extended class = \code{'{ccc}'}   }
\emph{\emph{Functions to check an object against an arbitrary} combo \emph{property spec}}
\cr\cr For these functions, an uppercase letter repeated three times is a placeholder for the value of an arbitrary single property from the associated property family.
\tabular{ll}{  \code{bbb_ccc}   \tab basic property in arg \code{bbb} + extended class property in arg \code{ccc}         \cr
  \code{mmm_ccc}   \tab extended mode property in arg \code{mmm} + extended class property in arg \code{ccc} \cr
  \code{cmp_ccc}   \tab integrity = \code{'cmp'} + extended class property in arg \code{ccc}                 \cr
  \code{sss_ccc}   \tab shape property in arg \code{sss} + extended class property in arg \code{ccc}         \cr
  \code{unq_ccc}   \tab integrity = \code{'unq'} + extended class property in arg \code{ccc}                 \cr
  \code{bbb_mmm}   \tab basic property in arg \code{bbb} + extended mode property in arg \code{mmm}          \cr
  \code{cmp_mmm}   \tab integrity = \code{'cmp'} + extended mode property in arg \code{mmm}                  \cr
  \code{unq_mmm}   \tab integrity = \code{'unq'} + extended mode property in arg \code{mmm}                  \cr   \tab  }
\tabular{ll}{  \code{cmp_mmm_ccc}   \tab integrity = \code{'cmp'} + extended mode property in arg \code{mmm} + extended class property in arg \code{ccc} \cr   \tab   \cr
  \code{unq_mmm_ccc}   \tab integrity = \code{'unq'} + extended mode property in arg \code{mmm} + extended class property in arg \code{ccc} }
\emph{\emph{Functions to check objects against} flex \emph{property specs in a single family}}
\tabular{ll}{  \code{BBB}   \tab \link[=bbb]{basic}                    \cr
  \code{CCC}   \tab \link[=ccc]{extended class}           \cr
  \code{DDD}   \tab \link[=ddd]{defined dimensionality}   \cr
  \code{EEE}   \tab \link[=eee]{effective dimensionality} \cr
  \code{III}   \tab \link[=iii]{integrity}                \cr
  \code{MMM}   \tab \link[=mmm]{extended mode}            \cr
  \code{SSS}   \tab \link[=sss]{shape}                      }
\emph{\emph{Functions to retrieve all of an object's} single \emph{properties of a specific family}}
\tabular{ll}{  \code{bbb}   \tab \link[=bbb]{basic}                    \cr
  \code{ccc}   \tab \link[=ccc]{extended class}           \cr
  \code{ddd}   \tab \link[=ddd]{defined dimensionality}   \cr
  \code{eee}   \tab \link[=eee]{effective dimensionality} \cr
  \code{iii}   \tab \link[=iii]{integrity}                \cr
  \code{mmm}   \tab \link[=mmm]{extended mode}            \cr
  \code{sss}   \tab \link[=sss]{shape}                      }
}
\section{Functions}{
\itemize{
\item \code{ppp()}: Lists all properties of \code{x}. Returns a sorted, lowercase, character vector.

\item \code{ppp_or_funs()}: Lists all property-or functions. Returns a sorted, lowercase, two-element, character vector.

\item \code{all_props()}: Lists all possible properties. Returns a sorted, lowercase, character vector.

\item \code{prop_funs()}: Lists all possible property checking functions. Includes both single-property and combination property checking functions. Returns a sorted, lowercase, character vector.

\item \code{is_prop_fun()}: Checks whether \code{x} is the name of a property checking function. Returns a logical scalar.

\item \code{is_prop()}: Checks whether \code{x} is a single property. Returns a logical scalar.

\item \code{is_prop_combo()}: Checks whether \code{x} is a combination property spec. Returns a logical scalar. A combination property spec is two or more unique, valid, single properties separated by underscores.

\item \code{is_prop_spec()}: Checks whether \code{x} is a valid property spec. Returns a logical scalar. A valid property spec must be a character scalar containing either a single property from \code{all_props()}, a combination property spec (two or more unique, valid, single properties separated by underscores), or a flexible property spec (two or more single properties or combination property specs separated by pipes).

\item \code{props_from_spec()}: Converts a property spec to a unique list of its constituent single properties by splitting \code{x} along pipes and underscores, removing any blank values, sorting the remaining values, and returning the unique set of remaining values.

\item \code{combos_from_spec()}: Converts a property spec into a vector of combination properties. Returns a character vector.

\item \code{props_from_combo()}: Converts a combined property spec into a vector of single properties. Returns a character vector.

\item \code{PPP()}: Checks \code{x} against the property spec \code{spec} subject to any count or value restrictions in \code{...}. Returns a logical scalar.

\item \code{nll_or()}: Checks \code{x} against null-ness or the property spec \code{spec} subject to any count or value restrictions in \code{...}. Returns a logical scalar.

\item \code{na0_or()}: Checks \code{x} against scalar missingness-ness or the property spec \code{spec} subject to any count or value restrictions in \code{...}. Returns a logical scalar.

\item \code{prop_defs()}: Produces a data frame containing all properties with columns indicating property family, the value of the property, a short description of the property, and a long description of the property. Returns a tibble/data frame.

\item \code{prop_verbose()}: Converts the property spec \code{x} into a verbose description of each constituent (combo) property, identifying each constituent (combo) property as an alternative to the others. Returns a character scalar.

\item \code{combo_concise()}: Converts the (combo) property \code{x} to a concise description.

\item \code{spec_concise()}: Converts the property spec \code{x} to a concise description.

}}
\section{Specifying count and value restrictions}{
 Specifying restrictions in \code{...} is optional. The full set of recognized arguments names are defined in the following table along with the properties each specifies:
\tabular{ll}{  \verb{.max, .maxr, .maxc}   \tab Scalar maximum valid numbers of elements, rows, and columns, respectively.                                                                 \cr   \tab   \cr
  \verb{.min, .minr, .minc}   \tab Scalar minimum valid numbers of elements, rows, and columns, respectively.                                                                 \cr   \tab   \cr
  \verb{.lt, .le, .ge, .gt}   \tab \link[=cmp_srt_scl]{Complete sortable scalar} less-than, less-than-or-equal, greater-than-or-equal, and greater-than bounds, respectively. \cr   \tab   \cr
  \verb{.n, .nr, .nc}         \tab A vector of valid numbers of elements, rows, and columns, respectively.                                                                    \cr   \tab   \cr
  \code{.vals}                \tab A vector of valid values.                                                                                                                                 }
}

\examples{
na0_or("5", "ch1")
na0_or(NA, "ch1")

nll_or(NULL, "ch1")
nll_or("1", "ch1")
nll_or(7, "ch1")

all_props()
prop_funs()

spec_concise("nll|cmp_psw_vls|ch1_scl")
combo_concise("cmp_psw_vls")
prop_verbose("srt")
prop_verbose("nnw")

combos_from_spec("nll|cmp_psw_vls|ch1_scl")
props_from_spec("nll|cmp_psw_vls|ch1_scl")
props_from_combo("cmp_psw_vls")

PPP("7", "nll|cmp_psw_vls|ch1_scl")
PPP(NULL, "nll|cmp_psw_vls|ch1_scl")
PPP("35", "nll|cmp_psw_vls|ch1_scl")

is_prop_combo("letter")
is_prop_combo("cmp_psw_vls")
is_prop_spec("nll|cmp_psw_vls|ch1_scl")

is_prop("vls")
is_prop("18")

is_prop_fun("cmp_psw_vls")
is_prop_fun("18")

ppp(letters)
prop_defs()
}
