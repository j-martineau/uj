% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is_failsafe.R
\name{is_failsafe}
\alias{is_failsafe}
\alias{isIN}
\alias{isID}
\alias{isEQ}
\alias{isT}
\alias{isF}
\alias{isNa}
\alias{isOk}
\alias{isTF}
\alias{isLG}
\alias{isBL}
\alias{notIN}
\alias{notID}
\alias{notEQ}
\alias{notBL}
\alias{norIN}
\alias{norID}
\alias{norEQ}
\alias{norT}
\alias{norF}
\alias{norNa}
\alias{norOk}
\alias{norTF}
\alias{norLG}
\alias{norBL}
\alias{anyIN}
\alias{anyID}
\alias{anyEQ}
\alias{anyT}
\alias{anyF}
\alias{anyNa}
\alias{anyOk}
\alias{anyTF}
\alias{anyLG}
\alias{anyBL}
\alias{allIN}
\alias{allID}
\alias{allEQ}
\alias{allT}
\alias{allF}
\alias{allNa}
\alias{allOk}
\alias{allTF}
\alias{allLG}
\alias{allBL}
\alias{oneIN}
\alias{oneID}
\alias{oneEQ}
\alias{oneT}
\alias{oneF}
\alias{oneNa}
\alias{oneOk}
\alias{oneTF}
\alias{oneLG}
\alias{oneBL}
\alias{twoIN}
\alias{twoID}
\alias{twoEQ}
\alias{twoT}
\alias{twoF}
\alias{twoNa}
\alias{twoOk}
\alias{twoTF}
\alias{twoLG}
\alias{twoBL}
\title{Failsafe \code{is} functions}
\usage{
isIN(x, ...)

isID(x, y)

isEQ(x, y)

isT(x)

isF(x)

isNa(x)

isOk(x)

isTF(x)

isLG(x)

isBL(x)

notIN(x, ...)

notID(x, y)

notEQ(x, y)

notBL(x)

norIN(x, ...)

norID(x, y)

norEQ(x, y)

norT(x)

norF(x)

norNa(x)

norOk(x)

norTF(x)

norLG(x)

norBL(x)

anyIN(x, ...)

anyID(x, y)

anyEQ(x, y)

anyT(x)

anyF(x)

anyNa(x)

anyOk(x)

anyTF(x)

anyLG(x)

anyBL(x)

allIN(x, ...)

allID(x, y)

allEQ(x, y)

allT(x)

allF(x)

allNa(x)

allOk(x)

allTF(x)

allLG(x)

allBL(x)

oneIN(x, ...)

oneID(x, y)

oneEQ(x, y)

oneT(x)

oneF(x)

oneNa(x)

oneOk(x)

oneTF(x)

oneLG(x)

oneBL(x)

twoIN(x, ...)

twoID(x, y)

twoEQ(x, y)

twoT(x)

twoF(x)

twoNa(x)

twoOk(x)

twoTF(x)

twoLG(x)

twoBL(x)
}
\arguments{
\item{x, y}{any object.}

\item{...}{objects to check for containing \code{x}.}
}
\value{
\code{TRUE} or \code{FALSE}.
}
\description{
Functions that produce a \code{TRUE} or \code{FALSE} result as
long as identity-evaluating their arguments (i.e.,
\code{identity(arg_name)}) does not itself produce an error.
}
\details{
\strong{\code{isIN, notIN}}
\cr The first determines whether \code{x} is an atomic scalar and if so,
whether \code{y} is a non-empty atomic object, and if so, whether \code{x}
is contained in any argument in \code{...}. Arguments in \code{...} are
evaluated left to right, and does not evaluate returning \code{TRUE} as
soon as it finds an argument containing \code{x}. Returns \code{FALSE} in
the following special cases: \code{x} is not atomic, \code{x} is not of
length \code{1}, a non-atomic argument is encountered in \code{...}, or an
error is generated in evaluating \code{x} or any argument in \code{...}.
The second returns the opposite of the first.
\cr\cr
\strong{\code{norIN, anyIN, allIN, oneIN, twoIN}}
\cr These functions call \code{isIN(x, ...)} for every element of \code{x}
and evaluate, respectively, whether \code{0}, \code{1} or more, all,
exactly \code{1}, and \code{2} or more of the results were \code{TRUE}.
\cr\cr
\strong{\code{isID, notID}}
\cr Thin wrappers for \code{identical} and \code{!identical}, respectively.
\cr\cr
\strong{\code{isEQ, notEQ}}
\cr Thin wrappers for \code{setequal} and \code{!setequal}, respectively,
but for atomic arguments only, meaning that if \code{x} and/or \code{y} are
not atomic, they are considered not set equal.
\cr\cr
\strong{\code{isT, isF, isTF}}
\cr Thin wrappers for \code{isTRUE}, \code{isFALSE}, and \code{(isTRUE |
  isFALSE)}, respectively, evaluating whether \code{x} is an atomic scalar
\code{TRUE}, an atomic scalar \code{FALSE}, or either, respectively.
\cr\cr
\strong{\code{isNa, isOk}}
\cr Evaluates, respectively, whether or not
\code{x} is an atomic scalar \code{NA} (includes \code{NA_character_},
\code{NA_complex_}, \code{NA_integer_}, and \code{NA_real_}).
\cr\cr
\strong{\code{isLG}}
\cr Evaluates whether \code{x} is an effectively logical scalar (i.e.,
\code{isT | isF | isNa}, because \code{NA} is coerceable to any
atomic mode).
\cr\cr
\strong{\code{isBL, notBL}}
\cr Evaluates whether \code{x} is a character scalar, and if so, whether
it is a blank string, or \code{""}.
\cr\cr
\emph{From here on}, \strong{\code{X}} \emph{and} \strong{\code{XX}}
\emph{are placeholders for properties incorporated into the names of
functions defined above such as the properties} \strong{\code{T}},
\strong{\code{F}}, \emph{or} \strong{\code{TF}}.
\cr\cr
\code{nor\strong{X}, nor\strong{XX}}
\cr Calls \code{is\strong{X}(x)} or \code{is\strong{XX}(x, y)}  for each
element of \code{x} and returns \code{TRUE} if the number of \code{TRUE}
values returned is \code{0}.
\cr\cr
\code{any\strong{X}, any\strong{XX}}
\cr Calls \code{is\strong{X}(x)} or \code{is\strong{XX}(x, y)} for each
element of \code{x} and returns \code{TRUE} if any \code{TRUE} values were
returned.
\cr\cr
\code{all\strong{X}, all\strong{XX}}
\cr Calls \code{is\strong{X}(x)} or \code{is\strong{XX}(x, y)} for each
element of \code{x} and returns \code{TRUE} if the number of \code{TRUE}
values returned is positive and equal to the length of \code{x}.
\cr\cr
\code{one\strong{X}, one\strong{XX}}
\cr Calls \code{is\strong{X}(x)} or \code{is\strong{XX}(x, y)} for each
element of \code{x} and returns \code{TRUE} if the number of \code{TRUE}
values returned is
\code{1}.
\cr\cr
\code{two\strong{X}, two\strong{XX}}
\cr Calls \code{is\strong{X}(x)} or \code{is\strong{XX}(x, y)} for each
element of \code{x} and returns \code{TRUE} if the number of \code{TRUE}
values returned is
\code{2} or greater.
}
\seealso{
Other failsafe: 
\code{\link{failsafe}()}

Other is_functions: 
\code{\link{is_color}()},
\code{\link{is_sortable}()},
\code{\link{is_unique}()},
\code{\link{is_xxx_array}},
\code{\link{is_xxx_generic}},
\code{\link{is_xxx_matrix}},
\code{\link{is_xxx_mvect}},
\code{\link{is_xxx_scalar}},
\code{\link{is_xxx_tibble}},
\code{\link{is_xxx_vect}},
\code{\link{is_xxx_vlist}},
\code{\link{is_xxx_vtype}},
\code{\link{logicals}}
}
\concept{failsafe}
\concept{is_functions}
