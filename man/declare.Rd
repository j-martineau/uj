% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/declare.R
\encoding{UTF-8}
\name{declare}
\alias{declare}
\alias{dtf}
\alias{dtf.}
\alias{dtf0}
\alias{dtfNA}
\alias{mat}
\alias{matd}
\alias{vec}
\alias{vec.}
\alias{vecNA}
\alias{vls}
\alias{vls.}
\title{Declare basic .R objects with extended functionality}
\usage{
dtf(..., .CN = NULL)

dtf.(...)

dtf0(.CN)

dtfNA(.CN, .NR)

mat(..., .R = 1, .NR = NULL, .NC = NULL, .BR = F, .RN = NULL, .CN = NULL)

matd(x = 1, .R = 1)

vec(..., .R = 1, .VN = NULL)

vec.(...)

vecNA(.R)

vls(..., .VN = NULL)

vls.(...)
}
\arguments{
\item{...}{Objects to placed in an atomic vec, atomic matrix, atomic data.frame, vlist, or square atomic diagonal matrix. \link[=a]{Atomized} for vec and matrix creation.}

\item{.CN}{Possibly pipe-delimited complete character vec of matrix/data.frame column names.}

\item{.NR}{Complete positive whole-number scalars giving number of matrix rows.}

\item{.R}{A non-\code{NA} numeric scalar number of replications.}

\item{.NC}{Complete positive whole-number scalars giving number of matrix columns.}

\item{.BR}{\code{TRUE} or \code{FALSE} indicating whether to fill matrices by row.}

\item{.RN}{Possibly pipe-delimited complete character vec of matrix row names.}

\item{x}{A non-empty vector of mode \code{'numeric'}, \code{'character'}, or \code{'logical'}.}

\item{.VN}{A possibly pipe-delimited, \link[=cmp_chr_vec]{complete character vec} of names to apply to vector or list elements}
}
\value{
\strong{An atomic data.frame}  \cr\cr \verb{dtf, dtf., dtf0, dtfNA}
\cr\cr  \strong{An atomic vector}      \cr\cr \verb{vec, vec., vecNA}
\cr\cr  \strong{A \link[=VLS]{vlist}}  \cr\cr \verb{vls, vls.}
\cr\cr  \strong{A square matrix}       \cr\cr \code{dmat}
\cr\cr  \strong{A matrix}              \cr\cr \code{mat}
}
\description{
This family of functions enforces the restrictions that names must (a) contain only ASCII letters, numerals, \code{'.'}, and \code{'_'}; (b) begin with a letter or \code{'.'} followed by a letter; and (c) end with a letter or numeral.
\cr\cr \strong{Functions declaring \link[=atm_dtf]{atomic data.frames}:}
\tabular{ll}{  \code{dtf}     \tab Declares a \code{data.frame.}                                                                                          \cr   \tab   \cr
  \code{dtf.}    \tab Declares a \code{data.frame} concisely: \code{dtf.(a, b)} is identical to \code{data.frame(a = a, b = b, stringsAsFactors = F)}. \cr   \tab   \cr
  \code{dtf0}    \tab Declares a \code{0}-row \code{data.frame.}                                                                                  \cr   \tab   \cr
  \code{dtfNA}   \tab Declares a \code{data.frame} of \code{NA} values.                                                                                          }
\cr\cr \strong{Functions declaring matrices:}
\tabular{ll}{  \code{mat}     \tab Declares a matrix.                                                                                                                  \cr   \tab   \cr
  \code{matd}    \tab Declares a square diagonal matrix: off-diags are \code{0}, \code{FALSE}, and \code{""} for \code{x} of mode \code{'numeric'}, \code{'logical'}, and \code{'character'}, respectively. }
\cr\cr \strong{Functions declaring atomic vectors:}
\tabular{ll}{  \code{vec}     \tab Declares a vector.                                                                       \cr   \tab   \cr
  \code{vec.}    \tab Declares a named atomic vector concisely: \code{vec.(a, b)} is identical to \code{c(a = a, b = b)} \cr   \tab   \cr
  \code{vecNA}   \tab Declares a vector of \code{NA} values.                                                                       }
\cr\cr \strong{Functions declaring \link[=iVLS]{vlists}:}
\tabular{ll}{  \code{vls}     \tab Declares a \link[=VLS]{vlist}.                                                     \cr   \tab   \cr
  \code{vls.}    \tab Declares a named \link[=VLS]{vlist} concisely: \code{vls.(a, b)} is identical to \code{list(a = a, b = b)}. }
}
\examples{
egA <- "a"
egB <- "b"
egC <- "c"
egNA <- NA
egABC <- c(a, b, c)
egNums <- 0:9
egNUMS <- 1:9
egLabs1 <- c("abc", "nums", "na")
egLabs2 <- c("abc", "NUMS", "na")

vec(egA, egB, egC)
vec(egA, egB, egC, .VN = abc)
vec(egA, egB, egC, .VN = "a|b|c")
vec(egA = egA, egB = egB, egC = egC)
vec.(egA, egB, egC)
vecNA(3)

mat(1:9)
mat(1:9, .NR = 3)
mat(1:9, .NC = 3)
mat(1:9, .NR = 3, .RN = "a|b|c", .CN = egABC, .BR = TRUE)
dmat(egABC)
dmat(1, 3)
dmat(TRUE, 3)

vls(egABC, egNums, egNA)
vls(egABC, egNums, egABC, .VN = Labs1)
vls(egABC = egABC, egNums = egNums, egNA = egNA)
vls(egABC, egNums, egNA, .VN = "egABC|egNums|egNA")
vls.(egABC, egNums, egNA)

dtf(egABC, egNUMS, egNA, .CN = Labs2)
dtf(egABC = egABC, egNUMS = egNUMS, egNA = egNA)
dtf(egABC, egNUMS, egNA, .CN = "egABC|egNUMS|egNA")
dtf.(egABC, egNUMS, egNA)
dtf0(egABC)
dtf0("egA|egB|egC")
dtfNA(egABC, 3)
}
\seealso{
Other extensions: 
\code{\link{N}()},
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{dups}()},
\code{\link{failsafe}()},
\code{\link{flex_rbind}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}()},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}
}
\concept{extensions}
