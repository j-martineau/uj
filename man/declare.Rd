% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/declare.R
\encoding{UTF-8}
\name{declare}
\alias{declare}
\alias{dtf}
\alias{dtf.}
\alias{dtf0}
\alias{dtf_na}
\alias{mat}
\alias{matd}
\alias{vec}
\alias{vec.}
\alias{vec_na}
\alias{vls}
\alias{vls.}
\title{Declare basic R objects with extended functionality}
\usage{
dtf(..., cn. = NULL)

dtf.(...)

dtf0(cn)

dtf_na(cn, nr)

mat(..., r = 1, nr = NULL, nc = NULL, br = F, rn = NULL, cn = NULL)

matd(x = 1, r = 1)

vec(..., r. = 1, en. = NULL)

vec.(...)

vec_na(r)

vls(..., en. = NULL)

vls.(...)
}
\arguments{
\item{...}{Objects to placed in an atomic vec, atomic matrix, atomic data.frame, vlist, or square atomic diagonal matrix. \link[=a]{Atomized} for vec and matrix creation.}

\item{cn.}{A possibly pipe-delimited complete character vec of column names (respectively) for a data.frame.}

\item{cn}{Possibly pipe-delimited complete character vec of matrix column names.}

\item{nr}{Complete positive whole-number scalars giving number of matrix rows.}

\item{r}{A non-\code{NA} numeric scalar number of replications.}

\item{nc}{Complete positive whole-number scalars giving number of matrix columns.}

\item{br}{A non-\code{NA} logical scalar indicating whether to fill matrices by row.}

\item{rn}{Possibly pipe-delimited complete character vec of matrix row names.}

\item{x}{A non-empty vector of mode \code{'numeric'}, \code{'character'}, or \code{'logical'}.}

\item{en.}{A possibly pipe-delimited, \link[=cmp_chr_vec]{complete character vec} of names to apply to vector or list elements}
}
\value{
\emph{An atomic data.frame}
\cr   \code{dtf}
\cr   \code{dtf.}
\cr   \code{dtf0}
\cr   \code{dtf_na}
\cr
\cr \emph{An atomic vector}
\cr   \code{vec}
\cr   \code{vec.}
\cr   \code{vec_na}
\cr
\cr \emph{A square matrix}
\cr   \code{dmat}
\cr
\cr \emph{A matrix}
\cr   \code{mat}
\cr
\cr \emph{A \link[=ivls]{vlist}}
\cr   \code{vls.}
\cr   \code{vls}
}
\description{
This family of functions enforces the restrictions that names must (a) contain only ASCII letters, numerals, \code{'.'}, and \code{'_'}; (b) begin with a letter or \code{'.'} followed by a letter; and (c) end with a letter or numeral.
\cr
\cr Functions declaring \link[=atm_dtf]{atomic data.frames}:\tabular{rl}{
\code{dtf} \tab   Declares a data.frame.
\cr     \code{dtf.} \tab   Declares a data.frame concisely\eqn{^a}.
\cr     \code{dtf0} \tab   Declares a \code{0}-row data.frame.
\cr   \code{dtf_na} \tab   Declares a data.frame of \code{NA} values.
}
Functions declaring matrices:\tabular{rl}{
\code{mat} \tab   Declares a matrix.
\cr   \code{matd} \tab   Declares a square diagonal matrix\eqn{^b}.
}
Functions declaring atomic vectors:\tabular{rl}{
\code{vec} \tab   Declares a vector.
\cr     \code{vec.} \tab   Declares a named atomic vector concisely\eqn{^c}.
\cr   \code{vec_na} \tab   Declares a vector of \code{NA} values.
}
Functions declaring \link[=ivls]{vlists}:\tabular{rl}{
\code{vls} \tab   Declares a \link[=ivls]{vlist}.
\cr   \code{vls.} \tab   Declares a named \link[=ivls]{vlist} concisely\eqn{^d}.
}
   \eqn{^{a.}} \code{dtf.(a, b)} is identical to \code{data.frame(a = a, b = b, stringsAsFactors = F)}.
\cr
\cr    \eqn{^{b.}} Off-diags are \code{0}, \code{FALSE}, \code{""} for \code{x} of mode \code{'numeric'}, \code{'logical'}, \code{'character'}, respectively.
\cr
\cr    \eqn{^{c.}} \code{vec.(a, b)} is identical to \code{c(a = a, b = b)}.
\cr
\cr    \eqn{^{d.}} \code{vls.(a, b)} is identical to \code{list(a = a, b = b)}.
}
\examples{
a <- "a"
b <- "b"
c <- "c"
na <- NA
abc <- c(a, b, c)
nums <- 0:9
NUMS <- 1:9
labs1 <- c("abc", "nums", "na")
labs2 <- c("abc", "NUMS", "na")

vec(a, b, c)
vec(a, b, c, en. = abc)
vec(a = a, b = b, c = c)
vec(a, b, c, en. = "a|b|c")
vec.(a, b, c)

mat(1:9)
mat(1:9, nr = 3)
mat(1:9, nc = 3)
mat(1:9, nr = 3, rn = "a|b|c", cn = abc, br = TRUE)

vls(abc, nums, na)
vls(abc, nums, na, en. = labs1)
vls(abc = abc, nums = nums, na = na)
vls(abc, nums, na, en. = "abc|nums|na")
vls.(abc, nums, na)

dtf(abc, NUMS, na, cn. = labs2)
dtf(abc = abc, NUMS = NUMS, na = na)
dtf(abc, NUMS, na, cn. = "abc|NUMS|na")
dtf.(abc, NUMS, na)

vec_na(3)

dmat(abc)
dmat(1, 3)
dmat(TRUE, 3)

dtf0(abc)
dtf0("a|b|c")
dtf_na(abc, 3)
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{dups}()},
\code{\link{envir_vals}},
\code{\link{evals}},
\code{\link{failsafe_binaries}},
\code{\link{failsafe_is}},
\code{\link{failsafe}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{n_is}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{stats0}},
\code{\link{swap}()},
\code{\link{uv}()},
\code{\link{wv}()},
\code{\link{xat}()}
}
\concept{extensions}
