% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/declare.R
\encoding{UTF-8}
\name{declare}
\alias{declare}
\alias{dtf}
\alias{dtf.}
\alias{dtf0}
\alias{dtfNA}
\alias{mat}
\alias{matNA}
\alias{matd}
\alias{vec}
\alias{vec.}
\alias{vecNA}
\alias{vls}
\alias{vls.}
\title{Declare basic .r objects with extended functionality}
\usage{
dtf(..., ..cn = NULL)

dtf.(...)

dtf0(.cn)

dtfNA(.cn, .nr)

mat(..., .r = 1, .nr = NULL, .nc = NULL, .br = F, .rn = NULL, .cn = NULL)

matNA(.nr = 1, .nc = 1, .rn = NULL, .cn = NULL)

matd(x = 1, .r = 1)

vec(..., .r = 1, .vn = NULL)

vec.(...)

vecNA(.r)

vls(..., .vn = NULL)

vls.(...)
}
\arguments{
\item{...}{Objects to placed in an atomic vec, atomic matrix, atomic data.frame, vlist, or square atomic diagonal matrix. \link[=a]{Atomized} for vec and matrix creation.}

\item{.cn}{Possibly pipe-delimited complete character vec of matrix/data.frame column names.}

\item{.nr}{Complete positive whole-number scalars giving number of matrix rows.}

\item{.r}{A non-\code{NA} numeric scalar number of replications.}

\item{.nc}{Complete positive whole-number scalars giving number of matrix columns.}

\item{.br}{\code{TRUE} or \code{FALSE} indicating whether to fill matrices by row.}

\item{.rn}{Possibly pipe-delimited complete character vec of matrix row names.}

\item{x}{A non-empty vector of mode \code{'numeric'}, \code{'character'}, or \code{'logical'}.}

\item{.vn}{A possibly pipe-delimited, \link[=cmp_chr_vec]{complete character vec} of names to apply to vector or list elements}
}
\value{
\strong{An atomic data.frame}  \cr\cr \verb{dtf, dtf., dtf0, dtfNA}
\cr\cr  \strong{An atomic vector}      \cr\cr \verb{vec, vec., vecNA}
\cr\cr  \strong{A \link[=VLS]{vlist}}  \cr\cr \verb{vls, vls.}
\cr\cr  \strong{A square matrix}       \cr\cr \code{dmat}
\cr\cr  \strong{A matrix}              \cr\cr \code{mat}
}
\description{
This family of functions enforces the restrictions that names must (a) contain only ASCII letters, numerals, \code{'.'}, and \code{'_'}; (b) begin with a letter or \code{'.'} followed by a letter; and (c) end with a letter or numeral.
\cr\cr \strong{Functions declaring \link[=atm_dtf]{atomic data.frames}:}
\tabular{ll}{  \code{dtf}     \tab Declares a data frame.                                                                                          \cr   \tab   \cr
  \code{dtf.}    \tab Declares a data frame concisely: \code{dtf.(a, b)} is identical to \code{data.frame(a = a, b = b, stringsAsFactors = F)}. \cr   \tab   \cr
  \code{dtf0}    \tab Declares a \code{0}-row data frame.                                                                                  \cr   \tab   \cr
  \code{dtfNA}   \tab Declares a data frame of \code{NA} values.                                                                                          }
\cr\cr \strong{Functions declaring matrices:}
\tabular{ll}{  \code{mat}     \tab Declares a matrix.                                                                                              \cr   \tab   \cr
  \code{matd}    \tab Declares a square diagonal matrix: off-diagonals are \code{0}, \code{FALSE}, and \code{""} consistent with \code{mode(av(...))}.    \cr   \tab   \cr
  \code{matNA}   \tab Declares a matrix of \code{NA} values.                                                                                              }
\cr\cr \strong{Functions declaring atomic vectors:}
\tabular{ll}{  \code{vec}     \tab Declares a vector.                                                                                              \cr   \tab   \cr
  \code{vec.}    \tab Declares a named atomic vector concisely: \code{vec.(a, b)} is identical to \code{c(a = a, b = b)}.                       \cr   \tab   \cr
  \code{vecNA}   \tab Declares a vector of \code{NA} values.                                                                                              }
\cr\cr \strong{Functions declaring \link[=iVLS]{vlists}:}
\tabular{ll}{  \code{vls}     \tab Declares a \link[=VLS]{vlist}.                                                                                  \cr   \tab   \cr
  \code{vls.}    \tab Declares a named \link[=VLS]{vlist} concisely: \code{vls.(a, b)} is identical to \code{list(a = a, b = b)}.                              }
}
\examples{
egA <- "a"
egB <- "b"
egC <- "c"
egNA <- NA
egABC <- c(a, b, c)
egNums <- 0:9
egNUMS <- 1:9
egLabs1 <- c("abc", "nums", "na")
egLabs2 <- c("abc", "NUMS", "na")

vec(egA, egB, egC)
vec(egA, egB, egC, .vn = abc)
vec(egA, egB, egC, .vn = "a|b|c")
vec(egA = egA, egB = egB, egC = egC)
vec.(egA, egB, egC)
vecNA(3)

mat(1:9)
mat(1:9, .nr = 3)
mat(1:9, .nc = 3)
mat(1:9, .nr = 3, .rn = "a|b|c", .cn = egABC, .br = TRUE)
dmat(egABC)
dmat(1, 3)
dmat(TRUE, 3)

vls(egABC, egNums, egNA)
vls(egABC, egNums, egABC, .vn = Labs1)
vls(egABC = egABC, egNums = egNums, egNA = egNA)
vls(egABC, egNums, egNA, .vn = "egABC|egNums|egNA")
vls.(egABC, egNums, egNA)

dtf(egABC, egNUMS, egNA, ..cn = Labs2)
dtf(egABC = egABC, egNUMS = egNUMS, egNA = egNA)
dtf(egABC, egNUMS, egNA, ..cn = "egABC|egNUMS|egNA")
dtf.(egABC, egNUMS, egNA)
dtf0(egABC)
dtf0("egA|egB|egC")
dtfNA(egABC, 3)
}
