% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/n_is.R
\encoding{UTF-8}
\name{n_is}
\alias{n_is}
\alias{nx}
\alias{ns}
\alias{nmin}
\alias{nmax}
\alias{nsame}
\alias{nw}
\alias{nt}
\alias{nf}
\alias{nu}
\alias{nuv}
\alias{nr}
\alias{nc}
\alias{nch}
\alias{nna}
\alias{nok}
\alias{nat}
\alias{n0}
\alias{n1}
\alias{n2}
\alias{n3}
\alias{n1p}
\alias{n2p}
\alias{n3p}
\alias{nd}
\alias{nd0}
\alias{nd1}
\alias{nd2}
\alias{nd3}
\alias{nd1p}
\alias{nd2p}
\alias{nd3p}
\title{Dedicated counting functions}
\usage{
n_is(x, n = NULL, min = NULL, max = NULL, eq = FALSE)

nx(
  ...,
  n = NULL,
  min = NULL,
  max = NULL,
  eq = FALSE,
  a = FALSE,
  na = TRUE,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

ns(
  ...,
  n = NULL,
  min = NULL,
  max = NULL,
  na = TRUE,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

nmin(..., na = TRUE, vals = NULL, lt = NULL, le = NULL, ge = NULL, gt = NULL)

nmax(..., na = TRUE, vals = NULL, lt = NULL, le = NULL, ge = NULL, gt = NULL)

nsame(
  ...,
  min = NULL,
  max = NULL,
  na = TRUE,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

nw(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = FALSE, a = TRUE)

nt(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = FALSE, a = TRUE)

nf(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = FALSE, a = TRUE)

nu(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = TRUE, a = TRUE)

nuv(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = TRUE, a = TRUE)

nr(..., n = NULL, min = NULL, max = NULL, eq = FALSE)

nc(..., n = NULL, min = NULL, max = NULL, eq = FALSE)

nch(..., n = NULL, min = NULL, max = NULL, eq = FALSE, na = FALSE, a = TRUE)

nna(..., n = NULL, min = NULL, max = NULL, eq = FALSE, a = TRUE)

nok(..., n = NULL, min = NULL, max = NULL, eq = FALSE, a = TRUE)

nat(..., n = NULL, min = NULL, max = NULL, eq = FALSE, a = TRUE)

n0(..., na = TRUE, a = TRUE)

n1(..., na = TRUE, a = TRUE)

n2(..., na = TRUE, a = TRUE)

n3(..., na = TRUE, a = TRUE)

n1p(..., na = TRUE, eq = FALSE, a = TRUE)

n2p(..., na = TRUE, eq = FALSE, a = TRUE)

n3p(..., na = TRUE, eq = FALSE, a = TRUE)

nd()

nd0()

nd1()

nd2()

nd3()

nd1p()

nd2p()

nd3p()
}
\arguments{
\item{x}{\link[=innw]{non-negative whole-number} object.}

\item{n}{Optional \link[=cmp_nnw_vec]{complete non-negative whole-number vec} of valid element, row, or column counts.}

\item{min}{Optional complete non-negative whole-number scalar giving minimum valid element, row, or column counts.}

\item{max}{Optional complete non-negative whole-number scalar giving maximum valid element, row, or column counts.}

\item{eq}{Non-\code{NA} scalar indicating whether all counts must be equal.}

\item{...}{One or more arguments to be examined for counts.}

\item{a}{Non-\code{NA} scalar indicating whether to \link[=av]{atomize} \code{...} to create a single atomic vector before processing. If \code{a = FALSE}, each argument in \code{...} is processed separately.}

\item{na}{Non-\code{NA} scalar whether \code{NA} values are allowed.}

\item{vals}{Optional \link[=atm_vec]{atomic vec} indicating specific values to be counted.}

\item{lt}{Optional \link[=cmp_srt_scl]{complete sortable scalar} indicating specific values elements of \code{...} arguments must be less than in order to be counted.}

\item{le}{Optional complete sortable scalar indicating specific values elements of \code{...} arguments must be less than or equal to in order to be counted}

\item{ge}{Optional complete sortable scalar indicating specific values elements of \code{...} arguments must be greater than or equal to in order to be counted.}

\item{gt}{Optional complete sortable scalar indicating specific values elements of \code{...} arguments must be greater than in order to be counted.}
}
\value{
May be non-negative integer or a logical scalar or vector, depending the properties of primary argument(s) (i.e., \code{x} and \code{...}) and optional arguments (i.e., all others).
}
\description{
Counting functions can be used with a single unnamed argument, multiple unnamed arguments, and with restrictions in named arguments, in any combination. The functions in this family answer the questions described below.
\tabular{rl}{
  \verb{nu, nuv}   \tab Number of unique atomic values.
\cr \verb{nw, nt}   \tab Number of \code{TRUE} values.
\cr     \code{nf}   \tab Number of \code{FALSE} values.
\cr    \code{nna}   \tab Number of atomic \code{NA} values.
\cr    \code{nok}   \tab Number of atomic non-\code{NA} values.
\cr    \code{nch}   \tab Number of characters in each element.
\cr     \code{nc}   \tab Number of columns.
\cr     \code{nr}   \tab Number of rows.
\cr            \tab  
\cr     \code{nd}   \tab Gets the number of \code{...} args.
\cr    \code{nd0}   \tab Are there \verb{0 ...} args?
\cr    \code{nd1}   \tab Are there \verb{1 ...} args?
\cr    \code{nd2}   \tab Are there \verb{2 ...} args?
\cr    \code{nd3}   \tab Are there \verb{3 ...} args?
\cr   \code{nd1p}   \tab Are there \code{1+ ...} args?
\cr   \code{nd2p}   \tab Are there \code{2+ ...} args?
\cr   \code{nd3p}   \tab Are there \code{3+ ...} args?
\cr            \tab  
\cr     \code{n0}   \tab Is length \code{0}?
\cr     \code{n1}   \tab Is length \code{1}?
\cr     \code{n2}   \tab Is length \code{2}?
\cr     \code{n3}   \tab Is length \code{3}?
\cr    \code{n1p}   \tab Is length \verb{1+}?
\cr    \code{n2p}   \tab Is length \verb{2+}?
\cr    \code{n3p}   \tab Is length \verb{3+}?
\cr            \tab  
\cr   \code{nmin}   \tab Min \code{...} arg length.
\cr   \code{nmax}   \tab Max \code{...} arg length.
\cr            \tab  
\cr  \code{nsame}   \tab Are \code{...} arg lengths the same?
\cr    \code{nat}   \tab Length after \link[=av]{atomizing}.
\cr            \tab  
\cr     \code{nx}   \tab Length(s) of \code{...} args.
\cr     \code{ns}   \tab Lengths of \code{...} args.
\cr            \tab  
\cr   \code{n_is}   \tab Do counts meet criteria in \verb{n, min, max, eq}?
}
}
\examples{
N <- 0:15
n_is(N, n = 0:5)
n_is(N, min = 3, max = 12)
n_is(N, eq = T)
n_is(rep(0, 3), eq = T)
nx(letters, LETTERS, 0:9, NULL)
nx(letters, LETTERS, vals = letters)
nx(letters, LETTERS, le = "M", ge = "m")
nx(letters, LETTERS, lt = "M", gt = "m")
n0(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n2p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
nmin(letters, LETTERS, 0:9)
nmax(letters, LETTERS, 0:9)
nsame(letters, LETTERS, 0:9)
nsame(letters, LETTERS)
nsame(letters, LETTERS, lt = "M", gt = "m")
nmin(letters, LETTERS, 0:9, min = 11)
nmax(letters, LETTERS, 0:9, max = 11)
nsame(letters, LETTERS, 0:9, min = 11, max = 25)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nt(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n = 0:9)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19, eq = T)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n = 0:9)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19, eq = T)
nr(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nc(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nch(letters, eq = T)
nch(letters, "a string")
nch(letters, "a string", a = T)
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{envir_vals}},
\code{\link{evals}},
\code{\link{failsafe_binaries}},
\code{\link{failsafe_is}},
\code{\link{failsafe}()},
\code{\link{fork}()},
\code{\link{is_unq}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{stats0}},
\code{\link{swap}()},
\code{\link{uv}()},
\code{\link{wv}()},
\code{\link{x}()}

Other counts: 
\code{\link{max_nch}()},
\code{\link{meets}()}

Other dots: 
\code{\link{dots_uj}}
}
\concept{counts}
\concept{dots}
\concept{extensions}
