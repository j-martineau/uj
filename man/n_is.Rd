% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/n_is.R
\name{n_is}
\alias{n_is}
\alias{nx}
\alias{ns}
\alias{nmin}
\alias{nmax}
\alias{nsame}
\alias{nw}
\alias{nt}
\alias{nf}
\alias{nu}
\alias{nuv}
\alias{nr}
\alias{nc}
\alias{nch}
\alias{nna}
\alias{nok}
\alias{nat}
\alias{n0}
\alias{n1}
\alias{n2}
\alias{n3}
\alias{n1p}
\alias{n2p}
\alias{n3p}
\alias{nd}
\alias{nd0}
\alias{nd1}
\alias{nd2}
\alias{nd3}
\alias{nd1p}
\alias{nd2p}
\alias{nd3p}
\title{Dedicated counting functions}
\usage{
n_is(x, n = NULL, min = NULL, max = NULL, eq = F)

nx(
  ...,
  n = NULL,
  min = NULL,
  max = NULL,
  eq = F,
  a = F,
  na = F,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

ns(
  ...,
  n = NULL,
  min = NULL,
  max = NULL,
  na = F,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

nmin(..., na = F, vals = NULL, lt = NULL, le = NULL, ge = NULL, gt = NULL)

nmax(..., na = F, vals = NULL, lt = NULL, le = NULL, ge = NULL, gt = NULL)

nsame(
  ...,
  min = NULL,
  max = NULL,
  na = F,
  vals = NULL,
  lt = NULL,
  le = NULL,
  ge = NULL,
  gt = NULL
)

nw(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nt(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nf(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nu(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nuv(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nr(..., n = NULL, min = NULL, max = NULL, eq = F)

nc(..., n = NULL, min = NULL, max = NULL, eq = F)

nch(..., n = NULL, min = NULL, max = NULL, eq = F, na = F, a = T)

nna(..., n = NULL, min = NULL, max = NULL, eq = F, a = T)

nok(..., n = NULL, min = NULL, max = NULL, eq = F, a = T)

nat(..., n = NULL, min = NULL, max = NULL, eq = F, a = T)

n0(..., na = F, a = T)

n1(..., na = F, a = T)

n2(..., na = F, a = T)

n3(..., na = F, a = T)

n1p(..., na = F, eq = T, a = T)

n2p(..., na = F, eq = T, a = T)

n3p(..., na = F, eq = T, a = T)

nd()

nd0()

nd1()

nd2()

nd3()

nd1p()

nd2p()

nd3p()
}
\arguments{
\item{x}{\link[=innw]{non-negative whole-number} object.}

\item{n}{Optional \link[=cmp_nnw_vec]{complete non-negative whole-number vec} of valid element, row, or column counts.}

\item{min, max}{Optional \link[=cmp_nnw_scl]{complete non-negative whole-number scalars} giving minimum and maximum valid element, row, or column counts.}

\item{eq, na, a}{Non-\code{NA} scalars indicating, respectively, whether all counts must be equal, whether \code{NA} values are allowed, and whether to \link[=av]{atomize} \code{...} to create a single atomic vector before processing. If \code{a = FALSE}, each argument in \code{...} is processed separately.}

\item{...}{One or more arguments to be examined for counts.}

\item{vals}{Optional \link[=atm_vec]{atomic vec} indicating specific values to be counted.}

\item{lt, le, ge, gt}{Optional \link[=cmp_srt_scl]{complete sortable scalars} indicating specific values elements of \code{...} arguments must be less than, less than or equal to, greater than or equal to, or greater than, respectively, to be counted.}
}
\value{
An integer or logical scalar or vector.
}
\description{
Counting functions can be used with a single unnamed argument, multiple unnamed arguments, and with restrictions in named arguments, in any combination. The functions in this family answer the questions described below.
\itemize{\item \strong{\code{n_is}}: do counts in \code{x} meet criteria in \code{n}, \code{min},. \code{max}, and/or \code{eq}?}
\cr\itemize{
\item \strong{\code{nx}}: gets number of values in \code{...} arguments.
\item \strong{\code{nd}}: number of \code{...} arguments.
\item \strong{\code{ns}}: gets number of values in each \code{...} argument.
\item \strong{\code{nf}}:  gets number of values \code{FALSE} values.
\item \strong{\verb{nw nt}}: gets number of values \code{TRUE} values.
}
\cr\itemize{
\item \strong{\code{nat}}: gets number of values after \link[=av]{atomizing}.
\item \strong{\code{nch}}: gets number of characters in each element.
\item \strong{\verb{nr nc}}: gets number of values rows vs. columns, respectively.
\item \strong{\verb{nu nuv}}: gets number of unique atomic values.
\item \strong{\verb{nna nok}}:  gets number of values atomic \code{NA} vs. atomic non-\code{NA} values, respectively.
\item \strong{\verb{nmin nmax}}: gets the min vs. max \code{...} argument length, respectively.
}
\cr\itemize{
\item \strong{\verb{n0 n1 n2 n3}}: evaluates whether length is \code{0} vs. \code{1} vs. \code{2} vs. \code{3}, respectively.
\item \strong{\verb{n1p n2p n3p}}: evaluates whether length is \verb{1+} vs. \verb{2+} vs. \verb{3+}, respectively.
}
\cr\itemize{
\item \strong{\code{nsame}}: are lengths of all \code{...} arguments the same.
\item \strong{\verb{nd1p nd2p nd3p}}: is the number of \code{...} arguments \verb{1+} vs. \verb{2+} vs. \verb{3+}, respectively.
\item \strong{\verb{nd0 nd1 nd2 nd3}}: is the number of \code{...} arguments \code{0} vs. \code{1} vs. \code{2} vs. \code{3}, respectively.
}
}
\examples{
N <- 0:15
n_is(N, n = 0:5)
n_is(N, min = 3, max = 12)
n_is(N, eq = T)
n_is(rep(0, 3), eq = T)
nx(letters, LETTERS, 0:9, NULL)
nx(letters, LETTERS, 0:9, vals = letters)
nx(letters, LETTERS, vals = letters)
nx(letters, LETTERS, le = "M", ge = "m")
nx(letters, LETTERS, lt = "M", gt = "m")
n0(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n2p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
nmin(letters, LETTERS, 0:9)
nmax(letters, LETTERS, 0:9)
nsame(letters, LETTERS, 0:9)
nsame(letters, LETTERS)
nsame(letters, LETTERS, lt = "M", gt = "m")
nmin(letters, LETTERS, 0:9, min = 11)
nmax(letters, LETTERS, 0:9, max = 11)
nsame(letters, LETTERS, 0:9, min = 11, max = 25)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n = 0:9)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19, eq = T)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n = 0:9)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min = 9, max = 19, eq = T)
nr(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nc(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nch(letters, eq = T)
nch(letters, "a string")
nch(letters, "a string", a = T)
}
