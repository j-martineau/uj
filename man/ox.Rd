% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ox.R
\encoding{UTF-8}
\name{ox}
\alias{ox}
\alias{oxford}
\alias{oxford_comma}
\alias{ox_n}
\alias{ox_and}
\alias{ox_or}
\alias{ox_nor}
\alias{ox_either}
\alias{ox_neither}
\alias{ox_all}
\alias{ox_any}
\alias{ox_none}
\alias{ox_some}
\alias{ox_exactly}
\alias{ox_less}
\alias{ox_more}
\alias{ox_fewer}
\alias{ox_greater}
\alias{ox_at_least}
\alias{ox_at_most}
\alias{ox_no_greater}
\alias{ox_no_fewer}
\alias{ox_no_more}
\alias{ox_no_less}
\alias{ox_or_more}
\alias{ox_or_greater}
\alias{ox_or_less}
\alias{ox_or_fewer}
\title{Oxford-comma separated lists}
\usage{
ox(..., Conj = "and", Pref = "", Quote = 0)

oxford(..., Conj = "and", Pref = "", Quote = 0)

oxford_comma(..., Conj = "and", Pref = "", Quote = 0)

ox_n(..., Conj = "and", Comp = "", Quote = 0, N = 1, First = TRUE)

ox_and(..., Pref = "")

ox_or(..., Pref = "")

ox_nor(..., Pref = "neither")

ox_either(...)

ox_neither(...)

ox_all(..., Conj = "and")

ox_any(..., Conj = "or")

ox_none(..., Conj = "or")

ox_some(..., Conj = "and")

ox_exactly(..., Conj = "or", N = 1)

ox_less(..., Conj = "and", N = 2)

ox_more(..., Conj = "and", N = 1)

ox_fewer(..., Conj = "and", N = 2)

ox_greater(..., Conj = "and", N = 2)

ox_at_least(..., Conj = "and", N = 1)

ox_at_most(..., Conj = "and", N = 1)

ox_no_greater(..., Conj = "and", N = 1)

ox_no_fewer(..., Conj = "and", N = 1)

ox_no_more(..., Conj = "and", N = 1)

ox_no_less(..., Conj = "and", N = 1)

ox_or_more(..., Conj = "and", N = 1)

ox_or_greater(..., Conj = "and", N = 1)

ox_or_less(..., Conj = "and", N = 1)

ox_or_fewer(..., Conj = "and", N = 1)
}
\arguments{
\item{...}{Any number of arguments coerceable to mode character.}

\item{Conj}{A complete character scalar conjunction to use between the next to last and last elements of the list. Typical values are \code{and}, \code{or} and \code{nor}.}

\item{Pref}{A \link[=cmp_chr_scl]{complete character scalar} prefix to prepend to the list.}

\item{Comp}{A complete character scalar used for comparing to \code{N}, such as \code{'at least'} or \code{'or fewer'}.}

\item{N}{A \link[=cmp_psw_scl]{complete positive whole-number scalar}.}

\item{First}{\code{TRUE} or \code{FALSE} used to determine whether \code{Comp} is placed in front of \code{N} rather than after \code{N}.}
}
\value{
A character scalar.
}
\description{
Create Oxford-comma separated lists with a variety of templates (see \emph{details}).
\cr\cr With the exception of \code{{N} > length(uj::av(...))}, these functions appropriately process lists of length \code{1} and \code{2}.
}
\details{
Each function in this family operates from a template as shown in the following tables where \code{{conj}} and \code{{N}} represent the values of arguments \code{conj} and \code{N}; \code{{pref}} and \code{{comp}} indicate the potentially-\code{NULL} values of arguments \code{pref} and \code{conj}; and \verb{[a]}, \verb{[b]}, and \verb{[z]} represents elements of a list.
\cr\cr \strong{Simple lists}
\cr\cr These functions do not incorporate a number into the Oxford-comma separated list:
\tabular{ll}{  \code{ox}             \tab \code{'(pref) [a], [b], ..., {conj} [z]'}         \cr
  \code{oxford}         \tab                                              \cr
  \code{oxford_comma}   \tab                                              \cr   \tab   \cr
  \code{ox_or }         \tab \code{'(pref) [a], [b], ..., or [z]'}             \cr
  \code{ox_and}         \tab \code{'(pref) [a], [b], ..., and [z]'}            \cr
  \code{ox_any }        \tab \code{'(pref) any of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_all }        \tab \code{'(pref) all of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_none}        \tab \code{'(pref) none of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_some}        \tab \code{'(pref) some of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_either}      \tab \code{'(pref) either [a], [b], ..., or [z]'}      \cr
  \code{ox_neither}     \tab \code{'(pref) neither [a], [b], ..., nor [z]'}      }
\cr\cr \strong{Numeric-comparison lists}
\cr\cr These functions incorporate a number into the Oxford-comma separated list:
\tabular{ll}{  \code{ox_n}            \tab \code{'(pref) {N} of [a], [b], ..., {conj} [z]'}                 \cr
  \code{ox_exactly}      \tab \code{'(pref) exactly {N} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_less}         \tab \code{'(pref) less than {N} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_more}         \tab \code{'(pref) more than {N} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_fewer}        \tab \code{'(pref) fewer than {N} of [a], [b], ..., {conj} [z]'}      \cr
  \code{ox_greater}      \tab \code{'(pref) greater than {N} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_at_most}      \tab \code{'(pref) at most {N} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_at_least}     \tab \code{'(pref) at least {N} of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_no_less}      \tab \code{'(pref) no less than {N} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_more}      \tab \code{'(pref) no more than {N} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_fewer}     \tab \code{'(pref) no fewer than {N} of [a], [b], ..., {conj} [z]'}   \cr
  \code{ox_no_greater}   \tab \code{'(pref) no greater than {N} of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_or_less}      \tab \code{'(pref) {N} or less of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_more}      \tab \code{'(pref) {N} or more of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_fewer}     \tab \code{'(pref) {N} or fewer of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_or_greater}   \tab \code{'(pref) {N} or greater of [a], [b], ..., {conj} [z]'}        }
}
\examples{
egFruits <- c("apples", "bananas", "oranges")

ox(egFruits)
ox("apples", "bananas", "orange")
ox_or(egFruits)
ox_and(egFruits)
ox_nor(egFruits)
ox_nor(egFruits, Pref = "")

ox(egFruits)
ox(egFruits, Conj = "or")
ox(egFruits, Pref = "neither", Conj = "nor")

ox(egFruits, Pref = "", Conj = "nor")
ox(egFruits, Pref = "either", Conj = "or")
ox(egFruits, Pref = "all of", Conj = "and")

ox_either(egFruits)
ox_either("apples", "bananas", "oranges")

ox_neither(egFruits)
ox_neither("apples", "bananas", "oranges")

ox_all(egFruits)
ox_all("apples", "bananas", "oranges")

ox_none(egFruits)
ox_none("apples", "bananas", "oranges")

ox_n(egFruits, N = 1)
ox_n(egFruits, Conj = "and", N = 2, Comp = "from among")
ox_n(egFruits, Conj = "and", N = 2, Comp = "at least", First = TRUE)
ox_n(egFruits, Conj = "and", N = 2, Comp = "or more", First = FALSE)

ox_exactly(egFruits, N = 2)
ox_less(egFruits, N = 2)
ox_more(egFruits, N = 2)
ox_fewer(egFruits, N = 2)
ox_greater(egFruits, N = 2)
ox_at_least(egFruits, N = 2)
ox_at_most(egFruits, N = 2)
ox_no_greater(egFruits, N = 2)
ox_no_fewer(egFruits, N = 2)
ox_no_more(egFruits, N = 2)
ox_no_less(egFruits, N = 2)
ox_or_more(egFruits, N = 2)
ox_or_greater(egFruits, N = 2)
ox_or_less(egFruits, N = 2)
ox_or_fewer(egFruits, N = 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}()},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}()},
\code{\link{markdown}()},
\code{\link{maxnch}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
