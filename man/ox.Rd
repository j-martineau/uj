% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ox.R
\encoding{UTF-8}
\name{ox}
\alias{ox}
\alias{oxford}
\alias{oxford_comma}
\alias{ox_n}
\alias{ox_and}
\alias{ox_or}
\alias{ox_nor}
\alias{ox_either}
\alias{ox_neither}
\alias{ox_all}
\alias{ox_any}
\alias{ox_none}
\alias{ox_some}
\alias{ox_exactly}
\alias{ox_less}
\alias{ox_more}
\alias{ox_fewer}
\alias{ox_greater}
\alias{ox_at_least}
\alias{ox_at_most}
\alias{ox_no_greater}
\alias{ox_no_fewer}
\alias{ox_no_more}
\alias{ox_no_less}
\alias{ox_or_more}
\alias{ox_or_greater}
\alias{ox_or_less}
\alias{ox_or_fewer}
\title{Oxford-comma separated lsts}
\usage{
ox(..., conj = "and", pref = "", quote = 0)

oxford(..., conj = "and", pref = "", quote = 0)

oxford_comma(..., conj = "and", pref = "", quote = 0)

ox_n(..., conj = "and", comp = "", quote = 0, n = 1, first = TRUE)

ox_and(..., pref = "", quote = 0)

ox_or(..., pref = "", quote = 0)

ox_nor(..., pref = "neither", quote = 0)

ox_either(..., quote = 0)

ox_neither(..., quote = 0)

ox_all(..., conj = "and", quote = 0)

ox_any(..., conj = "or", quote = 0)

ox_none(..., conj = "or", quote = 0)

ox_some(..., conj = "and", quote = 0)

ox_exactly(..., conj = "or", n = 1, quote = 0)

ox_less(..., conj = "and", n = 2, quote = 0)

ox_more(..., conj = "and", n = 1, quote = 0)

ox_fewer(..., conj = "and", n = 2, quote = 0)

ox_greater(..., conj = "and", n = 2, quote = 0)

ox_at_least(..., conj = "and", n = 1, quote = 0)

ox_at_most(..., conj = "and", n = 1, quote = 0)

ox_no_greater(..., conj = "and", n = 1, quote = 0)

ox_no_fewer(..., conj = "and", n = 1, quote = 0)

ox_no_more(..., conj = "and", n = 1, quote = 0)

ox_no_less(..., conj = "and", n = 1, quote = 0)

ox_or_more(..., conj = "and", n = 1, quote = 0)

ox_or_greater(..., conj = "and", n = 1, quote = 0)

ox_or_less(..., conj = "and", n = 1, quote = 0)

ox_or_fewer(..., conj = "and", n = 1, quote = 0)
}
\arguments{
\item{...}{Any number of arguments coerceable to mode character.}

\item{conj}{A complete character scalar conjunction to use between the next to last and last elements of the lst. Typical values are \code{and}, \code{or} and \code{nor}.}

\item{pref}{A \link[=cmp_chr_scl]{complete character scalar} prefix to prepend to the lst.}

\item{quote}{\code{0}, \code{1}, or \code{2} indicating whether to leave lst elements unquoted, single-quote the lst elements, or double-quote the lst elements.}

\item{comp}{A complete character scalar used for comparing to \code{n}, such as \code{'at least'} or \code{'or fewer'}.}

\item{n}{A \link[=cmp_psw_scl]{complete positive whole-number scalar}.}

\item{first}{\code{TRUE} or \code{FALSE} used to determine whether \code{comp} is placed in front of \code{n} rather than after \code{n}.}
}
\value{
A character scalar.
}
\description{
Create Oxford-comma separated lsts with a variety of templates (see \emph{details}).
\cr\cr With the exception of \code{n > length(uj::av(...))}, these functions appropriately process lsts of length \code{1} and \code{2}.
}
\details{
Each function in this family operates from a template as shown in the following tables where \code{{conj}} and \code{{n}} represent the values of arguments \code{conj} and \code{n}; \code{{pref}} and \code{{comp}} indicate the potentially-\code{NULL} values of arguments \code{pref} and \code{comp}; and \verb{[a]}, \verb{[b]}, and \verb{[z]} represents elements of a lst.
\cr\cr \strong{Simple lsts}
\cr\cr These functions do not incorporate a number into the Oxford-comma separated lst:
\tabular{ll}{  \code{ox}             \tab \code{'{pref} [a], [b], ..., {conj} [z]'}         \cr
  \code{oxford}         \tab                                              \cr
  \code{oxford_comma}   \tab                                              \cr   \tab   \cr
  \code{ox_or }         \tab \code{'{pref} [a], [b], ..., or [z]'}             \cr
  \code{ox_and}         \tab \code{'{pref} [a], [b], ..., and [z]'}            \cr
  \code{ox_any }        \tab \code{'{pref} any of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_all }        \tab \code{'{pref} all of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_none}        \tab \code{'{pref} none of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_some}        \tab \code{'{pref} some of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_either}      \tab \code{'{pref} either [a], [b], ..., or [z]'}      \cr
  \code{ox_neither}     \tab \code{'{pref} neither [a], [b], ..., nor [z]'}      }
\cr\cr \strong{Numeric-comparison lsts}
\cr\cr These functions incorporate a number into the Oxford-comma separated lst:
\tabular{ll}{  \code{ox_n}            \tab \code{'{n} of [a], [b], ..., {conj} [z]'}          \cr
  \code{ox_exactly}      \tab \code{'exactly {n} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_less}         \tab \code{'less than {n} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_more}         \tab \code{'more than {n} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_fewer}        \tab \code{'fewer than {n} of [a], [b], ..., {conj} [z]'}      \cr
  \code{ox_greater}      \tab \code{'greater than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_at_most}      \tab \code{'at most {n} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_at_least}     \tab \code{'at least {n} of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_no_less}      \tab \code{'no less than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_more}      \tab \code{'no more than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_fewer}     \tab \code{'no fewer than {n} of [a], [b], ..., {conj} [z]'}   \cr
  \code{ox_no_greater}   \tab \code{'no greater than {n} of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_or_less}      \tab \code{'{n} or less of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_more}      \tab \code{'{n} or more of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_fewer}     \tab \code{'{n} or fewer of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_or_greater}   \tab \code{'{n} or greater of [a], [b], ..., {conj} [z]'}        }
}
\examples{
egFruits <- c("apples", "bananas", "oranges")

ox(egFruits)
ox("apples", "bananas", "orange")
ox_or(egFruits)
ox_and(egFruits)
ox_nor(egFruits)
ox_nor(egFruits, pref = "")

ox(egFruits)
ox(egFruits, conj = "or")
ox(egFruits, pref = "neither", conj = "nor")

ox(egFruits, pref = "", conj = "nor")
ox(egFruits, pref = "either", conj = "or")
ox(egFruits, pref = "all of", conj = "and")

ox_either(egFruits)
ox_either("apples", "bananas", "oranges")

ox_neither(egFruits)
ox_neither("apples", "bananas", "oranges")

ox_all(egFruits)
ox_all("apples", "bananas", "oranges")

ox_none(egFruits)
ox_none("apples", "bananas", "oranges")

ox_n(egFruits, n = 1)
ox_n(egFruits, conj = "and", n = 2, comp = "from among")
ox_n(egFruits, conj = "and", n = 2, comp = "at least", first = TRUE)
ox_n(egFruits, conj = "and", n = 2, comp = "or more", first = FALSE)

ox_exactly(egFruits, n = 2)
ox_less(egFruits, n = 2)
ox_more(egFruits, n = 2)
ox_fewer(egFruits, n = 2)
ox_greater(egFruits, n = 2)
ox_at_least(egFruits, n = 2)
ox_at_most(egFruits, n = 2)
ox_no_greater(egFruits, n = 2)
ox_no_fewer(egFruits, n = 2)
ox_no_more(egFruits, n = 2)
ox_no_less(egFruits, n = 2)
ox_or_more(egFruits, n = 2)
ox_or_greater(egFruits, n = 2)
ox_or_less(egFruits, n = 2)
ox_or_fewer(egFruits, n = 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}()},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}()},
\code{\link{markdown}()},
\code{\link{maxnch}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
