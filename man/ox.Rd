% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ox.R
\encoding{UTF-8}
\name{ox}
\alias{ox}
\alias{oxford}
\alias{oxford_comma}
\alias{ox_n}
\alias{ox_and}
\alias{ox_or}
\alias{ox_nor}
\alias{ox_either}
\alias{ox_neither}
\alias{ox_all}
\alias{ox_any}
\alias{ox_none}
\alias{ox_some}
\alias{ox_exactly}
\alias{ox_less}
\alias{ox_more}
\alias{ox_fewer}
\alias{ox_greater}
\alias{ox_at_least}
\alias{ox_at_most}
\alias{ox_no_greater}
\alias{ox_no_fewer}
\alias{ox_no_more}
\alias{ox_no_less}
\alias{ox_or_more}
\alias{ox_or_greater}
\alias{ox_or_less}
\alias{ox_or_fewer}
\title{Oxford-comma separated lists}
\usage{
ox(..., .CONJ = "and", .PREF = "", .QUOTE = 0)

oxford(..., .CONJ = "and", .PREF = "", .QUOTE = 0)

oxford_comma(..., .CONJ = "and", .PREF = "", .QUOTE = 0)

ox_n(..., .CONJ = "and", .COMP = "", .QUOTE = 0, .N = 1, .FIRST = TRUE)

ox_and(..., .PREF = "", .QUOTE = 0)

ox_or(..., .PREF = "", .QUOTE = 0)

ox_nor(..., .PREF = "neither", .QUOTE = 0)

ox_either(..., .QUOTE = 0)

ox_neither(..., .QUOTE = 0)

ox_all(..., .CONJ = "and", .QUOTE = 0)

ox_any(..., .CONJ = "or", .QUOTE = 0)

ox_none(..., .CONJ = "or", .QUOTE = 0)

ox_some(..., .CONJ = "and", .QUOTE = 0)

ox_exactly(..., .CONJ = "or", .N = 1, .QUOTE = 0)

ox_less(..., .CONJ = "and", .N = 2, .QUOTE = 0)

ox_more(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_fewer(..., .CONJ = "and", .N = 2, .QUOTE = 0)

ox_greater(..., .CONJ = "and", .N = 2, .QUOTE = 0)

ox_at_least(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_at_most(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_no_greater(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_no_fewer(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_no_more(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_no_less(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_or_more(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_or_greater(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_or_less(..., .CONJ = "and", .N = 1, .QUOTE = 0)

ox_or_fewer(..., .CONJ = "and", .N = 1, .QUOTE = 0)
}
\arguments{
\item{...}{Any number of arguments coerceable to mode character.}

\item{.CONJ}{A complete character scalar conjunction to use between the next to last and last elements of the list. Typical values are \code{and}, \code{or} and \code{nor}.}

\item{.PREF}{A \link[=cmp_chr_scl]{complete character scalar} prefix to prepend to the list.}

\item{.QUOTE}{\code{0}, \code{1}, or \code{2} indicating whether to leave list elements unquoted, single-quote the list elements, or double-quote the list elements.}

\item{.COMP}{A complete character scalar used for comparing to \code{.N}, such as \code{'at least'} or \code{'or fewer'}.}

\item{.N}{A \link[=cmp_psw_scl]{complete positive whole-number scalar}.}

\item{.FIRST}{\code{TRUE} or \code{FALSE} used to determine whether \code{.COMP} is placed in front of \code{.N} rather than after \code{.N}.}
}
\value{
A character scalar.
}
\description{
Create Oxford-comma separated lists with a variety of templates (see \emph{details}).
\cr\cr With the exception of \code{.N > length(uj::av(...))}, these functions appropriately process lists of length \code{1} and \code{2}.
}
\details{
Each function in this family operates from a template as shown in the following tables where \code{{conj}} and \code{{n}} represent the values of arguments \code{.CONJ} and \code{.N}; \code{{pref}} and \code{{comp}} indicate the potentially-\code{NULL} values of arguments \code{.PREF} and \code{.COMP}; and \verb{[a]}, \verb{[b]}, and \verb{[z]} represents elements of a list.
\cr\cr \strong{Simple lists}
\cr\cr These functions do not incorporate a number into the Oxford-comma separated list:
\tabular{ll}{  \code{ox}             \tab \code{'{pref} [a], [b], ..., {conj} [z]'}         \cr
  \code{oxford}         \tab                                              \cr
  \code{oxford_comma}   \tab                                              \cr   \tab   \cr
  \code{ox_or }         \tab \code{'{pref} [a], [b], ..., or [z]'}             \cr
  \code{ox_and}         \tab \code{'{pref} [a], [b], ..., and [z]'}            \cr
  \code{ox_any }        \tab \code{'{pref} any of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_all }        \tab \code{'{pref} all of [a], [b], ..., {conj} [z]'}  \cr
  \code{ox_none}        \tab \code{'{pref} none of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_some}        \tab \code{'{pref} some of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_either}      \tab \code{'{pref} either [a], [b], ..., or [z]'}      \cr
  \code{ox_neither}     \tab \code{'{pref} neither [a], [b], ..., nor [z]'}      }
\cr\cr \strong{Numeric-comparison lists}
\cr\cr These functions incorporate a number into the Oxford-comma separated list:
\tabular{ll}{  \code{ox_n}            \tab \code{'{n} of [a], [b], ..., {conj} [z]'}          \cr
  \code{ox_exactly}      \tab \code{'exactly {n} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_less}         \tab \code{'less than {n} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_more}         \tab \code{'more than {n} of [a], [b], ..., {conj} [z]'}       \cr
  \code{ox_fewer}        \tab \code{'fewer than {n} of [a], [b], ..., {conj} [z]'}      \cr
  \code{ox_greater}      \tab \code{'greater than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_at_most}      \tab \code{'at most {n} of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_at_least}     \tab \code{'at least {n} of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_no_less}      \tab \code{'no less than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_more}      \tab \code{'no more than {n} of [a], [b], ..., {conj} [z]'}    \cr
  \code{ox_no_fewer}     \tab \code{'no fewer than {n} of [a], [b], ..., {conj} [z]'}   \cr
  \code{ox_no_greater}   \tab \code{'no greater than {n} of [a], [b], ..., {conj} [z]'} \cr
  \code{ox_or_less}      \tab \code{'{n} or less of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_more}      \tab \code{'{n} or more of [a], [b], ..., {conj} [z]'}         \cr
  \code{ox_or_fewer}     \tab \code{'{n} or fewer of [a], [b], ..., {conj} [z]'}        \cr
  \code{ox_or_greater}   \tab \code{'{n} or greater of [a], [b], ..., {conj} [z]'}        }
}
\examples{
egFruits <- c("apples", "bananas", "oranges")

ox(egFruits)
ox("apples", "bananas", "orange")
ox_or(egFruits)
ox_and(egFruits)
ox_nor(egFruits)
ox_nor(egFruits, .PREF = "")

ox(egFruits)
ox(egFruits, .CONJ = "or")
ox(egFruits, .PREF = "neither", .CONJ = "nor")

ox(egFruits, .PREF = "", .CONJ = "nor")
ox(egFruits, .PREF = "either", .CONJ = "or")
ox(egFruits, .PREF = "all of", .CONJ = "and")

ox_either(egFruits)
ox_either("apples", "bananas", "oranges")

ox_neither(egFruits)
ox_neither("apples", "bananas", "oranges")

ox_all(egFruits)
ox_all("apples", "bananas", "oranges")

ox_none(egFruits)
ox_none("apples", "bananas", "oranges")

ox_n(egFruits, .N = 1)
ox_n(egFruits, .CONJ = "and", .N = 2, .COMP = "from among")
ox_n(egFruits, .CONJ = "and", .N = 2, .COMP = "at least", .FIRST = TRUE)
ox_n(egFruits, .CONJ = "and", .N = 2, .COMP = "or more", .FIRST = FALSE)

ox_exactly(egFruits, .N = 2)
ox_less(egFruits, .N = 2)
ox_more(egFruits, .N = 2)
ox_fewer(egFruits, .N = 2)
ox_greater(egFruits, .N = 2)
ox_at_least(egFruits, .N = 2)
ox_at_most(egFruits, .N = 2)
ox_no_greater(egFruits, .N = 2)
ox_no_fewer(egFruits, .N = 2)
ox_no_more(egFruits, .N = 2)
ox_no_less(egFruits, .N = 2)
ox_or_more(egFruits, .N = 2)
ox_or_greater(egFruits, .N = 2)
ox_or_less(egFruits, .N = 2)
ox_or_fewer(egFruits, .N = 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}()},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}()},
\code{\link{markdown}()},
\code{\link{maxnch}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
