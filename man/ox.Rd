% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ox.R
\encoding{UTF-8}
\name{ox}
\alias{ox}
\alias{oxford}
\alias{oxford_comma}
\alias{ox_n}
\alias{ox_and}
\alias{ox_or}
\alias{ox_nor}
\alias{ox_either}
\alias{ox_neither}
\alias{ox_all}
\alias{ox_any}
\alias{ox_none}
\alias{ox_some}
\alias{ox_exactly}
\alias{ox_less}
\alias{ox_more}
\alias{ox_fewer}
\alias{ox_greater}
\alias{ox_atleast}
\alias{ox_atmost}
\alias{ox_nogreater}
\alias{ox_nofewer}
\alias{ox_nomore}
\alias{ox_noless}
\alias{ox_ormore}
\alias{ox_orgreater}
\alias{ox_orless}
\alias{ox_orfewer}
\title{Oxford-comma separated lists}
\usage{
ox(..., conj = "and", pref = "", quote = 0)

oxford(..., conj = "and", pref = "", quote = 0)

oxford_comma(..., conj = "and", pref = "", quote = 0)

ox_n(..., conj = "and", comp = "", quote = 0, n = 1, first = TRUE)

ox_and(..., pref = "")

ox_or(..., pref = "")

ox_nor(..., pref = "neither")

ox_either(...)

ox_neither(...)

ox_all(..., conj = "and")

ox_any(..., conj = "or")

ox_none(..., conj = "or")

ox_some(..., conj = "and")

ox_exactly(..., conj = "or", n = 1)

ox_less(..., conj = "and", n = 2)

ox_more(..., conj = "and", n = 1)

ox_fewer(..., conj = "and", n = 2)

ox_greater(..., conj = "and", n = 2)

ox_atleast(..., conj = "and", n = 1)

ox_atmost(..., conj = "and", n = 1)

ox_nogreater(..., conj = "and", n = 1)

ox_nofewer(..., conj = "and", n = 1)

ox_nomore(..., conj = "and", n = 1)

ox_noless(..., conj = "and", n = 1)

ox_ormore(..., conj = "and", n = 1)

ox_orgreater(..., conj = "and", n = 1)

ox_orless(..., conj = "and", n = 1)

ox_orfewer(..., conj = "and", n = 1)
}
\arguments{
\item{...}{Any number of arguments coerceable to mode character.}

\item{conj}{A complete character scalar conjunction to use between the next to last and last elements of the list. Typical values are \code{and}, \code{or} and \code{nor}.}

\item{pref}{A \link[=cmp_chr_scl]{complete character scalar} prefix to prepend to the list.}

\item{comp}{A complete character scalar used for comparing to \code{n}, such as \code{'at least'} or \code{'or fewer'}.}

\item{n}{A \link[=cmp_psw_scl]{complete positive whole-number scalar}.}

\item{first}{A non-\code{NA} logical scalar used to determine whether \code{comp} is placed in front of \code{n} rather than after \code{n}.}
}
\value{
A character scalar.
}
\description{
Create Oxford-comma separated lists with a variety of templates (displayed below) where \code{{conj}} and \code{{n}} represent the values of arguments \code{conj} and \code{n}; \code{{pref}} and \code{{comp}} indicate the potentially-\code{NULL} values of arguments \code{pref} and \code{conj}; and \verb{[a]}, \verb{[b]}, and \verb{[z]} represents elements of a list.
\cr\cr  With the exception of \code{{n} > length(av(...))}, these functions appropriately process lists of length \code{1} and \code{2}.
\cr\cr \strong{Functions and associated templates}
\tabular{rl}{
  \strong{Function}   \tab \strong{Associated template}
\cr                    \tab   
\cr             \code{ox}   \tab \code{'(pref) [a], [b], ..., {conj} [z]'}
\cr                    \tab   
\cr           \code{ox_n}   \tab \code{'(pref) {n} of [a], [b], ..., {conj} [z]'}
\cr                    \tab \code{'(pref) {n} (comp) of [a], [b], ..., {conj} [z]'}
\cr                    \tab \code{'(pref) (comp) {n} of [a], [b], ..., {conj} [z]'}
\cr                    \tab   
\cr          \code{ox_or}   \tab \code{'(pref) [a], [b], ..., or [z]'}
\cr         \code{ox_and}   \tab \code{'(pref) [a], [b], ..., and [z]'}
\cr      \code{ox_either}   \tab \code{'(pref) either [a], [b], ..., or [z]'}
\cr     \code{ox_neither}   \tab \code{'(pref) neither [a], [b], ..., nor [z]'}
\cr                    \tab   
\cr         \code{ox_any}   \tab \code{'(pref) any of [a], [b], ..., {conj} [z]'}
\cr         \code{ox_all}   \tab \code{'(pref) all of [a], [b], ..., {conj} [z]'}
\cr        \code{ox_none}   \tab \code{'(pref) none of [a], [b], ..., {conj} [z]'}
\cr        \code{ox_some}   \tab \code{'(pref) some of [a], [b], ..., {conj} [z]'}
\cr                    \tab   
\cr      \code{ox_atmost}   \tab \code{'(pref) at most {n} of [a], [b], ..., {conj} [z]'}
\cr     \code{ox_exactly}   \tab \code{'(pref) exactly {n} of [a], [b], ..., {conj} [z]'}
\cr     \code{ox_atleast}   \tab \code{'(pref) at least {n} of [a], [b], ..., {conj} [z]'}
\cr        \code{ox_less}   \tab \code{'(pref) less than {n} of [a], [b], ..., {conj} [z]'}
\cr        \code{ox_more}   \tab \code{'(pref) more than {n} of [a], [b], ..., {conj} [z]'}
\cr       \code{ox_fewer}   \tab \code{'(pref) fewer than {n} of [a], [b], ..., {conj} [z]'}
\cr      \code{ox_noless}   \tab \code{'(pref) no less than {n} of [a], [b], ..., {conj} [z]'}
\cr      \code{ox_nomore}   \tab \code{'(pref) no more than {n} of [a], [b], ..., {conj} [z]'}
\cr     \code{ox_greater}   \tab \code{'(pref) greater than {n} of [a], [b], ..., {conj} [z]'}
\cr     \code{ox_nofewer}   \tab \code{'(pref) no fewer than {n} of [a], [b], ..., {conj} [z]'}
\cr   \code{ox_nogreater}   \tab \code{'(pref) no greater than {n} of [a], [b], ..., {conj} [z]'}
\cr                    \tab   
\cr      \code{ox_orless}   \tab \code{'(pref) {n} or less of [a], [b], ..., {conj} [z]'}
\cr      \code{ox_ormore}   \tab \code{'(pref) {n} or more of [a], [b], ..., {conj} [z]'}
\cr     \code{ox_orfewer}   \tab \code{'(pref) {n} or fewer of [a], [b], ..., {conj} [z]'}
\cr   \code{ox_orgreater}   \tab \code{'(pref) {n} or greater of [a], [b], ..., {conj} [z]'}
}
}
\examples{
Fruits <- c("apples", "bananas", "oranges")

ox(Fruits)
ox("apples", "bananas", "orange")
ox_or(Fruits)
ox_and(Fruits)
ox_nor(Fruits)
ox_nor(Fruits, pref = "")

ox(Fruits)
ox(Fruits, conj = "or")
ox(Fruits, pref = "neither", conj = "nor")

ox(Fruits, pref = "", conj = "nor")
ox(Fruits, pref = "either", conj = "or")
ox(Fruits, pref = "all of", conj = "and")

ox_either(Fruits)
ox_either("apples", "bananas", "oranges")

ox_neither(Fruits)
ox_neither("apples", "bananas", "oranges")

ox_all(Fruits)
ox_all("apples", "bananas", "oranges")

ox_none(Fruits)
ox_none("apples", "bananas", "oranges")

ox_n(Fruits, n = 1)
ox_n(Fruits, conj = "and", n = 2, comp = "from among")
ox_n(Fruits, conj = "and", n = 2, comp = "at least", first = TRUE)
ox_n(Fruits, conj = "and", n = 2, comp = "or more", first = FALSE)

ox_exactly(Fruits, n = 2)
ox_less(Fruits, n = 2)
ox_more(Fruits, n = 2)
ox_fewer(Fruits, n = 2)
ox_greater(Fruits, n = 2)
ox_atleast(Fruits, n = 2)
ox_atmost(Fruits, n = 2)
ox_nogreater(Fruits, n = 2)
ox_nofewer(Fruits, n = 2)
ox_nomore(Fruits, n = 2)
ox_noless(Fruits, n = 2)
ox_ormore(Fruits, n = 2)
ox_orgreater(Fruits, n = 2)
ox_orless(Fruits, n = 2)
ox_orfewer(Fruits, n = 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}},
\code{\link{markdown}},
\code{\link{max_nch}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
