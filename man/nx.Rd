% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nx.R
\name{nx}
\alias{nx}
\alias{n_is}
\alias{ns}
\alias{nmin}
\alias{nmax}
\alias{nsame}
\alias{nw}
\alias{nt}
\alias{nf}
\alias{nu}
\alias{nr}
\alias{nc}
\alias{nch}
\alias{nna}
\alias{nok}
\alias{nat}
\alias{n0}
\alias{n1}
\alias{n1p}
\alias{n2p}
\title{Dedicated counting functions}
\usage{
n_is(x, n. = NULL, min. = NULL, max. = NULL, eq. = F)

nx(
  ...,
  n. = NULL,
  min. = NULL,
  max. = NULL,
  eq. = F,
  a. = F,
  na. = F,
  vals. = NULL,
  lt. = NULL,
  le. = NULL,
  ge. = NULL,
  gt. = NULL
)

ns(
  ...,
  n. = NULL,
  min. = NULL,
  max. = NULL,
  na. = F,
  vals. = NULL,
  lt. = NULL,
  le. = NULL,
  ge. = NULL,
  gt. = NULL
)

nmin(
  ...,
  na. = F,
  vals. = NULL,
  lt. = NULL,
  le. = NULL,
  ge. = NULL,
  gt. = NULL
)

nmax(
  ...,
  na. = F,
  vals. = NULL,
  lt. = NULL,
  le. = NULL,
  ge. = NULL,
  gt. = NULL
)

nsame(
  ...,
  min. = NULL,
  max. = NULL,
  na. = F,
  vals. = NULL,
  lt. = NULL,
  le. = NULL,
  ge. = NULL,
  gt. = NULL
)

nw(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, na. = F, a. = T)

nt(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, na. = F, a. = T)

nf(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, na. = F, a. = T)

nu(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, na. = F, a. = T)

nr(..., n. = NULL, min. = NULL, max. = NULL, eq. = F)

nc(..., n. = NULL, min. = NULL, max. = NULL, eq. = F)

nch(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, na. = F, a. = T)

nna(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, a. = T)

nok(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, a. = T)

nat(..., n. = NULL, min. = NULL, max. = NULL, eq. = F, a. = T)

n0(..., na. = F, a. = T)

n1(..., na. = F, a. = T)

n1p(..., na. = F, eq. = T, a. = T)

n2p(..., na. = F, eq. = T, a. = T)
}
\arguments{
\item{x}{A non-negative whole-number object.}

\item{n.}{Optional non-negative whole-number vector of valid element, row, or
column counts.}

\item{min., max.}{Optional non-negative whole-number scalars giving minimum
and maximum valid element, row, or column counts.}

\item{eq., na., a.}{Logical scalars indicating, respectively, whether all
counts must be equal, whether \code{NA} values are allowed, and whether to
atomize \code{...} to create a single atomic vector before processing. If
\code{a} is \code{FALSE}, each argument in \code{...} is processed
separately.}

\item{...}{One or more arguments to be examined for counts.}

\item{vals.}{Optional atomic vector indicating specific values to be counted.}

\item{lt., le, .ge., gt.}{Optional atomic scalars indicating specific values
elements of arguments in \code{...} must be less than, less than or equal
to, greater than or equal to, or greater than, respectively, to be counted.}
}
\value{
An integer or logical scalar or vector.
}
\description{
Dedicated counting functions
}
\details{
\strong{\code{n_is}}
\cr Checks for specific counts, minimum counts, maximum counts, and equal
counts. Returns counts themselves if no checks are specified.
\cr\cr
\strong{\code{n.}, \code{nr}, and \code{nc}}
\cr Get or check counts of elements, rows, and columns, respectively.
\cr\cr
\strong{\code{ns}, \code{nmin}, and \code{nmax}}
\cr Get the number of elements in each argument in \code{...}, the minimum
length of any argument in \code{...}, and the maximum length of any
argument in \code{...}, respectively.
\cr\cr
\strong{\code{nsame}}
\cr Checks all arguments in \code{...} for the same length.
\cr\cr
\strong{\code{nw}, \code{nt}, \code{nf}, \code{nu}, \code{nav}, \code{nna},
and \code{nok}}
\cr Get or check counts of \code{TRUE}, \code{TRUE}, \code{FALSE}, unique
atomic, atomic, \code{NA}, and non-\code{NA} values, respectively.
\cr\cr
\strong{\code{n0}, \code{n1}, \code{n1p}, and \code{n2p}}
\cr Check for counts of \code{0}, \code{1}, \code{≥ 1}, and \code{≥ 2},
  respectively.
\cr\cr
\strong{\code{nch}}
\cr Gets or checks number of characters in each element of character
scalars, vectors, matrices, and arrays.
}
\examples{
N <- 0:15
n_is(N, n. = 0:5)
n_is(N, min. = 3, max. = 12)
n_is(N, eq. = T)
n_is(rep(0, 3), eq. = T)
nx(letters, LETTERS, 0:9, NULL)
nx(letters, LETTERS, 0:9, vals. = letters)
nx(letters, LETTERS, vals. = letters)
nx(letters, LETTERS, le. = "M", ge. = "m")
nx(letters, LETTERS, lt. = "M", gt. = "m")
n0(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n1p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
n2p(letters, LETTERS, TRUE, 0:1, 0:2, 0:9)
nmin(letters, LETTERS, 0:9)
nmax(letters, LETTERS, 0:9)
nsame(letters, LETTERS, 0:9)
nsame(letters, LETTERS)
nsame(letters, LETTERS, lt. = "M", gt. = "m")
nmin(letters, LETTERS, 0:9, min. = 11)
nmax(letters, LETTERS, 0:9, max. = 11)
nsame(letters, LETTERS, 0:9, min. = 11, max. = 25)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n. = 0:9)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min. = 9, max. = 19)
nw(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min. = 9, max. = 19, eq. = T)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, n = 0:9)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min. = 9, max. = 19)
nf(0:99 \%in\% 50:59, 0:99 \%in\% 41:49, min. = 9, max. = 19, eq. = T)
nr(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nc(tibble(letters, LETTERS), matrix(c(letters, LETTERS), nrow = 2))
nch(letters, eq. = T)
nch(letters, "a string")
nch(letters, "a string", a. = T)
}
\seealso{
Other meta: 
\code{\link{as_xxx}},
\code{\link{av}()},
\code{\link{binfuns}},
\code{\link{callers}()},
\code{\link{case}()},
\code{\link{ex}()},
\code{\link{failsafe}()},
\code{\link{fx}()},
\code{\link{getnames}()},
\code{\link{make}},
\code{\link{na_vals}},
\code{\link{named}()},
\code{\link{os}()},
\code{\link{ply}()},
\code{\link{recycling}},
\code{\link{run}()},
\code{\link{swap}()},
\code{\link{values}},
\code{\link{xb}()}
}
\concept{meta}
