% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mkstr.R
\name{mkstr.}
\alias{mkstr.}
\alias{geq}
\alias{geq0}
\alias{gcat}
\alias{gelt}
\alias{gfun}
\alias{glst}
\alias{gform}
\alias{gtick}
\alias{gwrap}
\alias{gbrace}
\alias{gcolon}
\alias{gparen}
\alias{gquote}
\alias{gquote2}
\alias{gbracket}
\alias{pcat}
\alias{peq}
\alias{peq0}
\alias{pelt}
\alias{pfun}
\alias{plst}
\alias{pform}
\alias{ptick}
\alias{pwrap}
\alias{pbrace}
\alias{pcolon}
\alias{pparen}
\alias{pquote}
\alias{pquote2}
\alias{pbracket}
\title{Specialized string building functions}
\usage{
mkstr.()

geq(x, ...)

geq0(x, ...)

gcat(...)

gelt(x, ...)

gfun(x, ...)

glst(...)

gform(x, ...)

gtick(...)

gwrap(l, r, ...)

gbrace(...)

gcolon(...)

gparen(...)

gquote(...)

gquote2(...)

gbracket(...)

pcat(...)

peq(x, ...)

peq0(x, ...)

pelt(x, ...)

pfun(x, ...)

plst(...)

pform(x, ...)

ptick(...)

pwrap(l, r, ...)

pbrace(...)

pcolon(...)

pparen(...)

pquote(...)

pquote2(...)

pbracket(...)
}
\arguments{
\item{x}{An object containing atomic values (atomized).}

\item{...}{An arbitrary number of objects to be atomized into a single atomic
vector.}

\item{l, r}{\link[=cmp_chr_scl]{Complete character scalars} giving left and
right side enclosures for \code{...} after \link[=a]{atomization}.}
}
\value{
Character vector
}
\description{
Specialized string building functions
}
\section{Functions}{
\itemize{
\item \code{geq()}: Build a space-padded equality statements of atomized and
glued values of \code{x} and \code{...} (e.g., \code{geq(c('x', 'y', 'z'),
  0, 1, 2)} produces \code{'xyz = 012'}).

\item \code{geq0()}: Build an unpadded equality statements of atomized and
glued values of \code{.x} and \code{...} (e.g., \code{geq0(c('x', 'y',
  'z'), 0, 1, 2)} produces \code{'xyz=012'}).

\item \code{gcat()}: Build a vector concatenation statements of atomized and
glued values of \code{...} (e.g., \code{gcat(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'c(xyz012)'}).

\item \code{gelt()}: Build an element extraction concatenation statement from
atomized and glued values of \code{x} and \code{...} (e.g.,
\code{gelt(c('x', 'y', 'z'), 0, 1, 2)} produces \code{'xyz[012]'}).

\item \code{gfun()}: Build a function call from atomized and glued values of
\code{x} and \code{...} (e.g., \code{gfun(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'xyz(012)'}).

\item \code{glst()}: Build a comma-separated list from atomized and glued
values of \code{...} (e.g., \code{glst(c('x', 'y', 'z'), 0, 1, 2)} produces
\code{'x, y, z, 0, 1, 2'}).

\item \code{gform()}: Build a model formula of additive terms from atomized and
glued values of \code{x} and \code{...} (e.g., \code{gform(c('x', 'y',
  'z'), 0, 1, 2)} produces \code{'xyz ~ 012'}).

\item \code{gtick()}: Build a backtick-quoted value from atomized and glued
values of \code{...} (e.g., \code{gtick(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'`xyz012`'}).

\item \code{gwrap()}: Build left- and write-wrapped strings from atomized and
glued values of \code{l.}, \code{r.}, and \code{...} (e.g.,
\code{gwrap(c('a', 'b', 'c'), 'z', 0, 1, 2)} produces \code{'abc012z'}).

\item \code{gbrace()}: Build a curly-brace-enclosed value from atomized and glued
values of \code{...} (e.g., \code{gbrace(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'\{xyz012\}'}).

\item \code{gcolon()}: Build a colon-delimited list from atomized and glued
values of \code{...} (e.g., \code{gcolon(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'x:y:z:0:1:2'}).

\item \code{gparen()}: Build a parentheses-enclosed value from atomized and glued
values of \code{...} (e.g., \code{gparen(c('x', 'y', 'z'), 0, 1, 2)}
produces \code{'(xyz012)'}).

\item \code{gquote()}: Build a single-straight-quote-enclosed value from atomized
and glued values of \code{...} (e.g., \code{gquote(c('x', 'y', 'z'), 0, 1,
  2)} produces \code{"'xyz012'"}).

\item \code{gquote2()}: Build a double-straight-quote-enclosed value from atomized
and glued values of \code{...} (e.g., \code{gquote(c('x', 'y', 'z'), 0, 1,
  2)} produces \code{'"xyz012"'}).

\item \code{gbracket()}: Build a square-bracket-enclosed value from atomized and
glued values of \code{...} (e.g., \code{gbracket(c('x', 'y', 'z'), 0, 1,
  2)} produces \code{'(xyz012)'}).

\item \code{pcat()}: Build vector concatenation statement from atomized values
of \code{...} (e.g., \code{pcat(c('x', 'y', 'z'), 0, 1, 2)} produces
\code{'c(x, y, z, 0, 1, 2)'}).

\item \code{peq()}: Build string-padded equality statements (e.g.,
\code{peq(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('x = 012', 'y =
  012', 'z = 012')}).

\item \code{peq0()}: Build unpadded equality statements (e.g.,
\code{peq0(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('x=012', 'y=012',
  'z=012')}).

\item \code{pelt()}: Build element extraction statements (e.g.,
\code{pelt(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('x\[012\]',
  'y\[012\]', 'z\[012\]')}).

\item \code{pfun()}: Build function calls (e.g., \code{pfun(c('x', 'y', 'z'),
0, 1, 2)} produces \code{c('x(012)', 'y(012)', 'z(012)')}).

\item \code{plst()}: Build comma-separated lists (e.g., \code{plst(c('x', 'y',
'z'), 0, 1, 2)} produces \code{c('x, 0, 1, 2', 'y, 0, 1, 2', 'z, 0, 1,
2')}).

\item \code{pform()}: Build model formula statements with additive terms only
(e.g., \code{pform(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('x ~ 0 + 1
  + 2', 'y ~ 0 + 1 + 2', 'z ~ 0 + 1 + 2')}).

\item \code{ptick()}: Build tick enclosed vectors (e.g., \code{ptick(c('x', 'y',
'z'), 0, 1, 2)} produces \code{c('`x012`', '`y012`', '`z012`')}).

\item \code{pwrap()}: Build left/right wrapped vectors (e.g., \code{pwrap(c('l',
'L', 'l'), 'r', 1, 2)} produces \code{c('l12r`', 'L12r`', 'l12r')}).

\item \code{pbrace()}: Build curly-brace-enclosed vectors (e.g.,
\code{pbrace(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('\{x012\}',
  '\{y012\}', '\{z012\}')}.

\item \code{pcolon()}: Build colon-delimited lists (e.g., \code{pcolon(c('x',
'y', 'z'), 0, 1, 2)} produces \code{c('x:0:1:2', 'y:0:1:2', 'z:0:1:2')}).

\item \code{pparen()}: Build parentheses-enclosed vectors (e.g.,
\code{pparen(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('(x012)',
  '(y012)', '(z012)')}.

\item \code{pquote()}: Build single-straight-quoted vectors (e.g.,
\code{pquote(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c("'x012'",
  "'y012'", "'z012'")}).

\item \code{pquote2()}: Build single-straight-quoted vectors (e.g.,
\code{pquote(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('"x012"',
  '"y012"', '"z012"')}).

\item \code{pbracket()}: Build square-bracket-enclosed vectors (e.g.,
\code{pbrace(c('x', 'y', 'z'), 0, 1, 2)} produces \code{c('\[x012\]',
  '\[y012\]', '\[z012\]')}.

}}
\seealso{
Other strings: 
\code{\link{blank.}()},
\code{\link{charn.}()},
\code{\link{delim.}()},
\code{\link{fsub.}()},
\code{\link{ipat.}()},
\code{\link{max_nch.}()},
\code{\link{ox.}()},
\code{\link{pgrid.}()},
\code{\link{rev_str.}()},
\code{\link{spacing.}()},
\code{\link{ss.}()},
\code{\link{tocase.}()},
\code{\link{weave.}()}
}
\concept{strings}
