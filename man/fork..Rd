% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fork.R
\name{fork.}
\alias{fork.}
\alias{f0}
\alias{f1}
\alias{fx}
\alias{ff0}
\alias{ff1}
\alias{ffx}
\title{Forking as an extension of \code{\link[base]{ifelse}}}
\usage{
fork.()

f0(test, yes, no)

f1(test, yes, no, na = no, err = no)

fx(test, yes, no, na = "err")

ff0(test, yes, no)

ff1(test, yes, no)

ffx(test, yes, no)
}
\arguments{
\item{test}{\link[=cmp_lgl_scl]{Complete logical scalar} for \code{f0},
\code{ff0}, \code{f1}, and \code{ff1}. \link[=cmp_lgl_vec]{Complete logical
vec} for \code{fx} and \code{ffx}. \code{f0}, \code{f1}, and \code{f2} can
manage \code{NA} values in \code{test}. The others do not.}

\item{yes}{An object of any type for \code{f0}, \code{ff0}, \code{f1}, and
\code{ff1}. An \link[=atm_scl]{atomic scalar} or an \link[=atm_vec]{atomic
vector+} of the same length as \code{test} for \code{fx} and \code{ffx}.}

\item{no}{An object of any type for \code{f0}, \code{ff0}, \code{f1}, and
\code{ff1}. An \link[atm_scl]{atomic scalar} or an \link[atm_vec]{atomic
vec} of the same length as \code{test} for \code{fx} and \code{ffx}. Must
be \code{\link{compatible}} with \code{yes}.}

\item{na}{An object of any type for \code{f1}. An \link[=atm_scl]{atomic
scalar} \code{\link{compatible}} with \code{yes} and \code{no} for
\code{fx} and \code{ffx}, with the additional possibility of \code{na =
  'err'} for \code{fx} to indicate an error should be thrown if any values in
\code{test} are \code{NA}.}

\item{err}{\code{'err'} or an object to be returned when \code{test} is not
an atomic scalar in \code{c(TRUE, FALSE, NA)}.}
}
\value{
An R object.
}
\description{
Robust extended functionality for \code{\link[base]{ifelse}}.
}
\section{Functions}{
\itemize{
\item \code{f0()}: If \code{test = TRUE}, returns \code{yes}. If \code{test}
is anything else, returns \code{no}.

\item \code{f1()}: If \code{test = TRUE}, returns \code{yes}. If
\code{test = FALSE}, returns \code{no}. If \code{test = NA} and
\code{na = 'err'}, throws an error, otherwise returns \code{na}. If
\code{test} is anything else and \code{err = 'err'}, throws an error,
otherwise returns \code{err}.

\item \code{fx()}: Evaluates \code{test} (which must be a logical scalar or
vector) and returns an object of the same dimension as \code{test} where
\code{TRUE} values are exchanged for the corresponding value of \code{yes},
and \code{NA} values are exchanged for \code{na} (unless \code{na = 'err'},
in which case if there are \code{NA} values in \code{test}, an error is
thrown).

\item \code{ff0()}: Bare-bones version of \code{f0} without error-checking.
If \code{test} is logical scalar \code{TRUE}, return \code{yes} (all of
it), otherwise return \code{no} (all of it).

\item \code{ff1()}: Bare-bones version of \code{f1} without error checking.
Creates a new vector the same length as \code{test}, placing the atomic
scalar value \code{yes} into the elements of the new vector corresponding
to the \code{TRUE} elements of \code{test} and placing the atomic scalar
value in \code{no} into elements of the new vector corresponding to
\code{FALSE} elements of \code{test}.

\item \code{ffx()}: Bare-bones version of \code{fx} without error checking.
Creates a new vector the same length as \code{test}, placing values of
atomic vector \code{yes} corresponding to \code{TRUE} elements of
\code{test} into those same elements of the new vector and placing values
of atomic vector \code{no} corresponding to \code{FALSE} elements of
\code{test} into those same elements of the new vector.

}}
\section{The \code{test} argument}{

\code{f0} and \code{ff0} expect \code{test} to be a non-\code{NA} logical
\code{no}, whereas \code{ff0}'s return value will be unpredictable.
\cr\cr
\code{f1} and \code{ff1} by default also expect \code{test} to be a
non-\code{NA} logical scalar. However, \code{f1} allows for specifying
replacement values for \code{NA} values in \code{test}. \code{ff1}'s return
value is unpredictable when \code{test = NA}.
\cr\cr
\code{fx} and \code{ffx} expect a logical vector without any \code{NA}
values.  However, \code{fx} allows for specifying either throwing an error
if \code{test} contains any \code{NA} values or a return value to replace
\code{NA} values. \code{ffx}'s return value is unpredictable when
\code{test} contains \code{NA} values.
}

\seealso{
Other extensions: 
\code{\link{a.}()},
\code{\link{binfuns.}()},
\code{\link{callers.}()},
\code{\link{case.}()},
\code{\link{dots.}()},
\code{\link{ex.}()},
\code{\link{failsafe.}()},
\code{\link{files.}()},
\code{\link{fsub.}()},
\code{\link{is_failsafe.}()},
\code{\link{is_unq.}()},
\code{\link{logicals.}()},
\code{\link{make.}()},
\code{\link{n_th.}()},
\code{\link{na.}()},
\code{\link{naming.}()},
\code{\link{nx.}()},
\code{\link{os.}()},
\code{\link{pause.}()},
\code{\link{ply.}()},
\code{\link{put.}()},
\code{\link{reclass.}()},
\code{\link{recycling.}()},
\code{\link{run.}()},
\code{\link{stats.}()},
\code{\link{swap.}()},
\code{\link{values.}()},
\code{\link{x.}()},
\code{\link{xb.}()}
}
\concept{extensions}
\concept{fork}
