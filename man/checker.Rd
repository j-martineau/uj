% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/checkerr.R
\encoding{UTF-8}
\name{checker}
\alias{checker}
\alias{stopperr}
\alias{getterr}
\alias{purgerr}
\alias{err_if}
\alias{err_if_not}
\alias{errs_ifs}
\alias{errs_if_nots}
\alias{err_if_pop}
\alias{errs_if_pop}
\alias{errs}
\alias{err}
\alias{banked_errs}
\alias{checkerr}
\alias{bankerr}
\alias{bankerrs}
\alias{check_t}
\alias{check_tf}
\alias{check_lgl}
\alias{check_nll_or}
\alias{check_nas_or}
\alias{check_cls}
\alias{check_pop}
\alias{check_funs}
\alias{check_spec}
\alias{check_vals}
\alias{check_chars}
\alias{check_dots}
\alias{check_when}
\alias{check_fail}
\title{Error checking, banking, and processing}
\usage{
stopperr(..., FUN = "", PKG = "", STACK = "")

getterr()

purgerr()

err_if(TEST, ..., FUN = "", PKG = "", STACK = "", D = " ")

err_if_not(TEST, ..., FUN = "", PKG = "", STACK = "", D = " ")

errs_ifs(..., FUN = "", PKG = "", STACK = "", D = " ")

errs_if_nots(..., FUN = "", PKG = "", STACK = "", D = " ")

err_if_pop(..., FUN = "", PKG = "", STACK = "", D = " ")

errs_if_pop(..., FUN = "", PKG = "", STACK = "")

errs(ERRS, PKG = "", STACK = "")

err(..., PKG = "", STACK = "", D = " ")

banked_errs(GENS = 0)

checkerr(GENS = 0, PKG = "")

bankerr(..., GENS = 0, D = "")

bankerrs(..., GENS = 0)

check_t(..., D = " ")

check_tf(...)

check_lgl(..., NAS = FALSE, EXTRAS = NULL)

check_nll_or(FUNS, ..., VALS = NULL)

check_nas_or(FUNS, ..., VALS = NULL)

check_cls(CLS, ...)

check_pop(...)

check_funs(FUNS, ..., VALS = NULL)

check_spec(SPEC, ..., NAS = F)

check_vals(VALS, ..., A = TRUE, NAS = FALSE)

check_chars(CHARS, ..., A = TRUE)

check_dots(SPEC, ..., NAMED = FALSE)

check_when(WHENS, VALS, ...)

check_fail(...)
}
\arguments{
\item{...}{Differs by function in terms of whether they are named, how many there are, and their \link[=ppp]{property requirements} as described in section \emph{the} \code{...} \emph{arguments}.}

\item{FUN}{A character scalar naming the function generating an error or errors.}

\item{PKG}{A character scalar naming the package \code{FUN} is a part of. The package is identified as \code{'unknown'} when \code{PKG = ""}.}

\item{STACK}{An optional character vector naming the lineage of the function generating the error. If \code{NULL}, retrieves the stack under the assumption that the immediate calling function is where the error is generated.}

\item{D}{A non-\code{NA} character scalar delimiter for collapsing \code{...} into a an error message.}

\item{ERRS}{A character vector of individual error messages.}

\item{GENS}{A \link[=cmp_nnw_scl]{complete non-negative whole-number scalar} indicating the number of generations back in the call stack in which to bank and/or check for error messages.}

\item{NAS}{\code{TRUE} or \code{FALSE} indicating whether \code{NA} values qualify as \code{'logical'}.}

\item{EXTRAS}{\code{NULL} or a \link[=cmp_atm]{complete atomic object} containing additional valid values.}

\item{FUNS}{A \link[=cmp_chr_vec]{complete character vec} containing \code{1} or more \link[=prop_funs]{property function} names.}

\item{VALS}{A \link[=cmp_atm]{complete atomic object} of length \code{length(WHENS)}.}

\item{SPEC}{A \link[=cmp_chr_scl]{complete character scalar} containing a \link[=is_prop_spec]{property spec}.}

\item{A}{\code{TRUE} or \code{FALSE} indicating whether to \link[=av]{atomize} \code{...} args.}

\item{NAMED}{\code{TRUE} or \code{FALSE} indicating whether \code{...} args must uniquely named without using \code{""}.}

\item{WHENS}{A \link[=pop_atm]{populated atomic object} of length \code{length(VALS)}.}
}
\value{
**A **\code{\link[base]{simpleError}} \strong{object} \cr\cr \code{getterr}
\cr\cr  \strong{A character vector}                           \cr\cr \code{banked_errs}
\cr\cr  All others are called for their side effects.
}
\description{
Bank error messages in the immediate environment of a function to allow for exhaustive error checking before throwing an exception. Results in a possibly multiple-error, accumulated message to be processed upon completion of error checking.
}
\details{
\strong{Primary stopping functions}
\tabular{ll}{  \code{stopperr}        \tab Stops execution by:                                                                                                                                                                                                             \cr
                    \tab \enumerate{\item Posting an \code{\link{alert}} header the console with the following components: an error \code{'ERROR'} title, a subheader identifying the function where the error originated (from \code{FUN}), and another subheader identifying the package that function belongs to (from \code{PKG}).
\item Posting one or more error message to the console following the header, each preceded by a bullet, where each element of each \code{...} arg is a separate error message.
\item Creating a \code{\link[base]{simpleError}} object with an error message consisting of an \link[=lineage]{abbreviated function call lineage} given as a vector in \code{STACK}.
\item Attaching the function identity, package identity, and associated message(s) to the \code{simpleError} object as attributes.
\item Archiving the \code{simpleError} object in the global variable \code{.last_UJ_error.} (which can be retrieved by calling \code{getter()} and can be purged by calling \code{purger()}). Allows for error tracing in the circumstance that R purges the last error in final error processing.
\item Calling \code{stop} with the \code{simpleError} object as the argument.                                                                                                                                   } \cr   \tab   \cr
  \code{checkerr}        \tab Calls \code{stopper} with any error messages banked by the functions described in sections \emph{error banking} \emph{utilities functions} and \emph{condition-based error-checking functions}. If none are banked, does nothing.      \cr   \tab   \cr
  \code{purgerr}         \tab Purges the most recent \code{\link[base]{simpleError}} object generated by this family of functions.                                                                                                               \cr   \tab   \cr
  \code{getterr}         \tab Gets the most recent \code{simpleError} object generated by this family of functions.                                                                                                                                                  }
\cr Both \code{stopperr} and \code{checkerr} can identify error-generating functions further up the call stack than the function in which they are called:
\itemize{\item \code{stopper} uses args \code{FUN}, \code{PKG}, and \code{STACK} to identify the error-generating function.
\item \code{checker} uses args \code{GENS} and \code{PKG} to identify the error-generating function.}
\cr\cr \strong{Secondary stopping functions}
\cr\cr These functions are designed to be called directly from the function where an error is generated. It gathers the name of the function generating the error rather than requiring the user to provide the function name. These functions operate as follows:
\tabular{ll}{  \code{errs}            \tab Calls \code{stopperr} treating each element of each \code{...} arg as a separate error message, allowing for compiling multiple error message before processing.                                                              \cr   \tab   \cr
  \code{err}             \tab Calls \code{stopperr} with a single error message constructed by \link[=collapse_dots]{collapsing} all elements of all \code{...} args into a character scalar error message before processing.                                              }
\cr\cr \strong{Multiple-error conditional stopping functions}
\cr\cr These functions conditionally compile multiple errors, and if any are compiled, they notify the user and stop execution.
\tabular{ll}{  \code{errs_if_nots}    \tab Conditionally compiles errors, treating each odd-numbered \code{...} arg as a test and each even-numbered \code{...} arg as the corresponding error message if the test is \code{FALSE}, and calls \code{stopperr} if any are compiled. \cr   \tab   \cr
  \code{errs_if_pop}     \tab Calls \code{stopperr} if there are any \code{...} args, treating each \code{...} arg as a separate error message.                                                                                                                  \cr   \tab   \cr
  \code{errs_ifs}        \tab Conditionally compiles errors, treating each odd-numbered \code{...} arg as a test and each even-numbered \code{...} arg as the corresponding error message if the test is \code{TRUE}, and calls \code{stopperr} if any are compiled.                 }
\cr\cr \strong{Single-error conditional stopping functions}
\cr\cr These functions conditionally construct a single error, and if one is constructed, they notify the user and stop execution.
\tabular{ll}{  \code{err_if_pop}      \tab If there are any \code{...} args, collapsing them into a character scalar error message, and calls \code{stopperr}.                                                                                                           \cr   \tab   \cr
  \code{err_if_not}      \tab If \code{TEST = FALSE}, collapses \code{...} args to a character scalar error message and calls \code{stopperr}.                                                                                                                   \cr   \tab   \cr
  \code{err_if}          \tab If \code{TEST = TRUE}, collapses \code{...} args to a character scalar error message and calls \code{stopperr}.                                                                                                                                   }
\cr\cr \strong{Utility functions}
\cr\cr These functions purge and retrieve the most recent error generated by this family of functions.
\cr\cr \strong{Primary error banking functions}
\cr\cr Error banking utility functions: These functions are utilities for banking user-defined error messages within a function to allow for checking for multiple errors in separate statements and banking those error messages as they are checked, waiting to process banked error messages until an error checking block is completed. These functions also allow for generating and checking for error messages further up the call stack than the function in which the error banking/processing occurs by specifying the number of generations back in the call stack where error banking/processing occurs in \code{GENS}:
\tabular{ll}{  \code{banked_errs}    \tab Retrieves the bank of error message stored in the environment of the function \code{GENS} generations back in the call stack.                                                                                            \cr   \tab   \cr
  \code{bankerrs}       \tab Banks each element of \link[=cmp_chr_vec]{complete character vec} as an individual error message.                                                                                                                   \cr   \tab   \cr
  \code{bankerr}        \tab Banks an arbitrary error message (built by \link[=collapse_dots]{collapsing} \code{...} args) in the environment of the function \code{GENS} generations back in the call stack.                                                            }
\cr\cr \strong{Error checking / conditional error banking functions}
\cr\cr \strong{\code{checkerr}} checks for any banked error messages. If there are any, processes them and stops execution. Otherwise, does nothing.
\cr\cr The remaining \strong{\verb{check_\{props\}}} functions in the following table check objects for specific properties and automatically generate errors only if those properties are not met:
\tabular{ll}{  \code{check_nas_or}    \tab A named \code{...} arg is neither \code{NULL} nor satisfies any property function named in \code{FUNS}.                                                                                                                           \cr   \tab   \cr
  \code{check_nll_or}    \tab A named \code{...} arg is neither scalar \code{NA} nor satisfies any property function named in \code{FUNS}.                                                                                                                      \cr   \tab   \cr
  \code{check_chars}     \tab A named \code{...} arg contains characters not supplied in \code{CHARS}.                                                                                                                                                     \cr   \tab   \cr
  \code{check_when}      \tab The first named \code{...} arg \emph{is} the \code{n}-th value in \code{WHENS}, but the second \emph{is not} the \code{n}-th value in \code{VALS}.                                                                                                    \cr   \tab   \cr
  \code{check_dots}      \tab A \code{...} arg\eqn{^{(1)}} fails to satisfy the \link[=is_prop_spec]{property spec} in \code{SPEC}.                                                                                                                        \cr   \tab   \cr
  \code{check_spec}      \tab A named \code{...} arg fails to satisfy the \link[=is_prop_spec]{property spec} in \code{SPEC}\eqn{^{(2)}}.                                                                                                                  \cr   \tab   \cr
  \code{check_funs}      \tab A named \code{...} arg fails to satisfy \emph{any} of the \link[=prop_funs]{property function(s)} named in \code{FUNS}.                                                                                                           \cr   \tab   \cr
  \code{check_vals}      \tab A named \code{...} arg contains values not supplied in \code{VALS}.                                                                                                                                                          \cr   \tab   \cr
  \code{check_fail}      \tab A named \code{...} arg produces an error when submitted to \code{\link[base]{identity}}.                                                                                                                                \cr   \tab   \cr
  \code{check_cls}       \tab A named \code{...} arg is not of any class named in \code{CLS}.                                                                                                                                                              \cr   \tab   \cr
  \code{check_lgl}       \tab A named \code{...} arg is neither \code{TRUE}, \code{FALSE}, \code{NA} (if \code{NAS = TRUE}), nor contained in \code{EXTRAS}.                                                                                                                   \cr   \tab   \cr
  \code{check_pop}       \tab A named \code{...} arg is either \code{NULL} or otherwise of length \code{0}.                                                                                                                                                     \cr   \tab   \cr
  \code{check_tf}        \tab A named \code{...} arg is neither scalar \code{TRUE} nor scalar \code{FALSE}.                                                                                                                                                     \cr   \tab   \cr
  \code{check_t}         \tab A named \code{...} arg is \code{FALSE}\eqn{^{(3)}}.                                                                                                                                                                                         }
\tabular{l}{  \eqn{^{(1)}} Named if \code{NAMED = TRUE}.                                                                                                             \cr
  \eqn{^{(2)}} May be scalar \code{NA} if \code{NAS = TRUE}.                                                                                                  \cr
  \eqn{^{(3)}} Collapses \emph{unnamed} \code{...} args to an error message template, replacing the escape sequence \code{'{@}'} with the \emph{named} \code{...} arg's name. }
}
\section{The \code{...} arguments}{
 Arguments supplied in \code{...} differ across functions in terms of whether they are named, how many named and/or unnamed \code{...} args there are, and their \link[=ppp]{property requirements} as follows:
\tabular{llll}{                  \tab    \strong{Number of} \code{...} \strong{args}          \tab                                            \tab           \cr
  \strong{Function}    \tab    \emph{NAMED}                               \tab   \emph{UNNAMED}                                \tab   \emph{TOTAL} \cr
  \code{check_chars}   \tab    \verb{1+} (\code{\link{atm_str}})          \tab   \verb{1+} (\code{\link{atm_chr}}\eqn{^{(1)}}) \tab   \verb{2+}    \cr
  \code{check_when}    \tab    \code{2 } (\code{\link{atm_scl}})          \tab   \code{2 } (\code{\link{atm_scl}})             \tab   \code{4}     \cr
  \code{check_vals}    \tab    \verb{1+} (\code{\link{ATM}}\eqn{^{(1)}})  \tab   \verb{1+} (\code{\link{ATM}}\eqn{^{(1)}})     \tab   \verb{2+}    \cr
  \code{check_dots}    \tab    \verb{1+} (any object\eqn{^{(2)}})         \tab   \code{0 } (any object\eqn{^{(2)}})            \tab   \verb{1+}    \cr
  \code{check_fail}    \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_funs}    \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_spec}    \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_cls}     \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_lgl}     \tab    \verb{1+} (\code{\link{atm_scl}})          \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_pop}     \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_tf}      \tab    \verb{1+} (any object)                     \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{check_t}       \tab    \verb{1+} (\code{\link{isTF1}})            \tab   \code{0}                                      \tab   \verb{1+}    \cr
  \code{stopperr}      \tab    \verb{0+} (\code{\link{cmp_chr_vec}})      \tab   \verb{0+} (\code{\link{cmp_chr_vec}})         \tab   \verb{1+}    \cr
  \code{errs}          \tab    \verb{0+} (\code{\link{cmp_chr_vec}})      \tab   \verb{0+} (\code{\link{cmp_chr_vec}})         \tab   \verb{1+}    \cr
  \code{err}           \tab    \verb{0+} (\code{\link{cmp_chr_vec}})      \tab   \verb{0+} (\code{\link{cmp_chr_vec}})         \tab   \verb{1+}      }
\tabular{l}{  \eqn{^{(1)}} When \verb{A = TRUE}.                    \cr
  \eqn{^{(2)}} When \verb{NAMED = TRUE} (otherwise \verb{0+}). }
}

\examples{
egStopper <- function() {stopperr('stopper demo', PKG = 'uj')}
egErrs <- function() {errs('errs demo1', 'errs demo2', PKG = 'uj')}
egErr <- function() {err('err', 'demo', PKG = 'uj')}
egErrors <- function(..., tf = NA, lgl = 42, not = FALSE, pop = NULL,
                     fail = simpleError('error'), funs = 2:4, spec = 42,
                     vals = 42, class = 42, nas.or = NULL, nll.or = NA,
                     chars = '5', whenA = "errorA", whenB = "errorB") {
  bankerr(...elt(1))
  bankerrs(...elt(2), ...elt(3))
  check_tf(tf = tf)
  check_lgl(lgl = lgl)
  check_t(not = not)
  check_pop(pop = pop)
  check_fail(fail = fail)
  check_funs(c('cmp_ch1_vec', 'cmp_ngw_vec'), funs = funs)
  check_spec('cmp_ch1_vec|nll|nas', spec = spec)
  check_vals(letters, vals = vals)
  check_cls('data.frame', class)
  check_nas_or(c('cmp_ch1_vec', 'cmp_ngw_vec'), nas.or = nas.or)
  check_nll_or(c('cmp_ch1_vec', 'cmpNGWvec'), nll.or = nll.or)
  check_chars(letters, chars = chars)
  check_when(whenA = whenA, whenB = whenB, c('errorA', ''), c('errorB', ''))
  checkerr(PKG = 'uj')
}
\dontrun{
  egstopperr()
  getterr()
  purgerr()
  getter()
  egErrs()
  egErrs()
  egErrors()
}
}
\seealso{
Other properties: 
\code{\link{asMODE}()},
\code{\link{bbb_mmm}()},
\code{\link{bbb}()},
\code{\link{cls}()},
\code{\link{cmp_ccc}()},
\code{\link{cmp_mmm}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{ddd}()},
\code{\link{eee}()},
\code{\link{iii}()},
\code{\link{is_unique}()},
\code{\link{meets}()},
\code{\link{mmm_ccc}()},
\code{\link{mmm}()},
\code{\link{ppp}()},
\code{\link{sss}()},
\code{\link{unq_ccc}()}

Other errs: 
\code{\link{failsafe}()}
}
\concept{errs}
\concept{properties}
