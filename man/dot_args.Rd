% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dot_args.R
\encoding{UTF-8}
\name{dot_args}
\alias{dot_args}
\alias{dot_by_name}
\alias{dots_by_name}
\alias{dot_names}
\alias{named_dots}
\alias{anon_dots}
\alias{named_dot}
\alias{anon_dot}
\alias{flex_dot}
\alias{flex_dots}
\alias{glue_dot}
\alias{glue_dots}
\alias{gf_dots}
\alias{gf_dot}
\title{Manage \code{...} arguments}
\usage{
dot_args()

dot_by_name(.name, .def, ...)

dots_by_name(.names, .defs, ...)

dot_names(..., .subs = NULL, .req = TRUE, .bl = FALSE, .u = TRUE)

named_dots(...)

anon_dots(...)

named_dot(.n, ...)

anon_dot(.n, ...)

flex_dot(.n, ..., .glue = FALSE, .def = "", .d = " ")

flex_dots(..., .glue = FALSE, .def = "", .d = " ")

glue_dot(..., .n = 1, .def = "", .d = " ")

glue_dots(..., .def = "", .d = " ")

gf_dots(..., .def = "", .d = " ")

gf_dot(..., .n = 1, .def = "", .d = " ")
}
\arguments{
\item{.name}{\code{NULL} or \link[=cmp_scl]{complete atomic scalar}. \code{NULL} is replaced with \code{'NULL'} and \code{NA} is replaced with \code{'NA'}.}

\item{.def}{A default object/value to return if a specified argument is not in \code{...}. For \code{glue_dots} and \code{glue_dot}, must be a \link[=cmp_chr_vec]{complete character vec}. For all others, may be, but does not need to be, a list.}

\item{...}{An arbitrary number of arguments.}

\item{.names}{\code{NULL} or an \link[=atm_vec]{atomic vec} (may include \code{NA} values). Is split along the delimiter \code{'|'} to allow for compactness in submitting multiple .names \code{NULL} will match either an argument in \code{...} or element of \code{.defs} with the Name \code{'NULL'}. \code{NA} values will match an argument in \code{...} or an element of \code{.defs} with the Name \code{'NA'}.}

\item{.defs}{A named \link[=VLS]{vlist} of default objects/values to return if the specified arguments are not in \code{...}. Elements of \code{.defs} must be uniquely nameD If \code{.defs} is a tibble, columns with matching names are returned.}

\item{.subs}{\code{NULL} or \link[=cmp_chr_vec]{complete character vec}. If not \code{NULL}, it is split using pipes \code{'|'} as a delimiter. If there are no pipes contained in \code{.names}, it remains unchangeD When this argument is not \code{NULL}, it is substituted for the names of \code{...} arguments; thus, after splitting, its length must equal the number of \code{...} arguments. For example, \code{.names = c('one', 'two', 'three|four|five')} indicates that there should be five \code{...} arguments and the vector \code{c('one', 'two', 'three', 'four', 'five')} is substituted for their names.}

\item{.req}{\code{TRUE} or \code{FALSE} indicating whether names are required.}

\item{.bl}{\code{TRUE} or \code{FALSE} indicating whether blank names are allowed or what to return when \code{...} args resolve to a blank string (\code{""}).}

\item{.u}{\code{TRUE} or \code{FALSE} indicating whether \code{.names} must be unique.}

\item{.n}{A positive integer indicating which \code{...} arg to return.}

\item{.glue}{\code{TRUE} or \code{FALSE} indicating whether to glue the result (collapse into a character scalar) using the delimiter \code{.d}.}

\item{.d}{A \link[=cmp_chr_scl]{complete character scalar} for collapsing results to a character scalar.}
}
\value{
\strong{A character vector} (when \code{.glue = FALSE}) \cr\cr \verb{flex_dots, flex_dot}
\cr     \strong{A character scalar} (when \code{.glue = TRUE})  \cr\cr \verb{flex_dots, flex_dot}
\cr\cr  \strong{A character vector}                        \cr\cr \verb{dot_names, dnames}
\cr\cr  \strong{A character scalar}                        \cr\cr \verb{glue_dots, glue_dot} \cr \verb{gf_dots, gf_dot}
\cr\cr  \strong{An object}                                 \cr\cr \verb{dot_by_name, named_dot, anon_dot}
\cr\cr  \strong{A list}                                    \cr\cr \verb{dots_by_name, named_dots, anon_dots}
}
\description{
Enhanced of functions for managing \code{...} arguments.
}
\details{
\strong{\code{dot_names}} and \strong{\code{dnames}} are enhancements of \code{...names} that flexibly retrieves names of all \code{...} args by substituting the corresponding value of \code{.subs} If a \code{...} arg's name is missing or blank (\code{""}), the corresponding value of \code{.names} is substituted Throws an error in the following circumstances:
\itemize{\item \code{...length() == 0}
\item \code{length(.names) > 0 & length(.names) < ...length()}
\item \code{is.null(.names) & ..bl & any(...names() == "")}
\item \code{is.null(.names) & .req & !any(...names() != "")}
\item \code{is.null(.names) & .u & any(duplicated(...names()))}}
\cr The remaining functions in this family are as follows:
\tabular{ll}{  \code{dots_by_name}   \tab Enhancement of \code{list(...)} that extracts one or more\code{...} args based on matching values supplied in \code{.names}. If a supplied Name matches the Name of a \code{...}
arg, that arg is returned. Otherwise, the element of \code{.defs} with a matching Name is returned. \code{.names = NULL} and \code{.names = NA} are converted to \code{'NULL'} and
\code{'NA'}. Reserved words should be backtick quoted.                                                                                                               \cr   \tab   \cr
  \code{named_dots}     \tab Get a named list containing named \code{...} arg values.                                                                                                             \cr   \tab   \cr
  \code{anon_dots}      \tab Get an unnamed list containing unnamed (anonymous) \code{...} arg values.                                                                                            \cr   \tab   \cr
  \code{flex_dots}      \tab Retrieve a list of \code{...length()} elements where the \code{.n}\eqn{^{th}} element is the flexibly evaluated value of \code{...elt(.n)}, where flexible evaluation of \code{...}
arg values means that a \code{...} arg takes on the unadjusted value if \link[=base:force]{forcing} evaluation does not generate an error. Otherwise, it takes as
its value the string literal representing it in a function call. For example, \code{f(exactly, 5-2, words)} and \code{f("exactly", "3", "words")} give identical results
in the following circumstances: The usage of \code{f} is defined as \code{f(...)}, \code{f} treats each \code{...} arg as a flexdot, and in the immediate environment that calls
\code{f(...)} there are no defined objects with the names \code{exactly} and \code{words}.                                                                                     \cr   \tab   \cr
  \code{glue_dots}      \tab Collapse \code{...} args to a character scalar by calling \code{\link[base]{paste0}}\code{(}\code{\link{av}}\verb{(...), collapse = .d)}.                                       \cr   \tab   \cr
  \code{gf_dots}        \tab Combo functionality of \code{glue_dots} and \code{flex_dots} to glue flexibly evaluated \code{...} args into a character scalar.                                               \cr   \tab   \cr
  \code{dot_by_name}    \tab Get a single \code{...} arg by name.                                                                                                                                 \cr   \tab   \cr
  \code{named_dot}      \tab Get the \code{.n}-th named \code{...} arg.                                                                                                                                 \cr   \tab   \cr
  \code{anon_dot}       \tab Get the \code{.n}-th unnamed (anonymous) \code{...} arg.                                                                                                                   \cr   \tab   \cr
  \code{flex_dot}       \tab Get the \code{.n}-th \code{...} arg, flexibly evaluated.                                                                                                                   \cr   \tab   \cr
  \code{glue_dot}       \tab Get the \code{.n}-th \code{...} arg, glued.                                                                                                                                \cr   \tab   \cr
  \code{gf_dot}         \tab Get the \code{.n}-th \code{...} arg, flexibly evaluated and glued.                                                                                                                        }
}
\examples{
egdot_args <- function(...) {
  nDots <- ...length()
  if (nDots > 1) {
    sub.names <- paste0(letters[1:nDots], LETTERS[1:nDots])
    defaults <- as.list(LETTERS[1:nDots])
    default <- "{missing}"
  } else {
    sub.names <- NULL
    defaults <- "{no Dot args}"
    default <- "{no Dot args}"
  }
  list(glue.flex.dots = flex_dots(..., .glue = TRUE, .def = default, .d = "_") ,
       glue.flex.dot2 = flex_dot(..., .n = 2, .glue = TRUE)                   ,
       subbed.names   = failsafe(dot_names(..., .subs = sub.names))          ,
       named.dots     = failsafe(named_dots(...))                           ,
       anon.dots      = failsafe(anon_dots(...))                            ,
       DotNames      = failsafe(dot_names(...))                            ,
       flex.dots      = flex_dots(..., .defs = default)                      ,
       flex.dot2      = flex_dot(..., .n = 2)                                ,
       glue.dots      = failsafe(glue_dots(..., .defs = default))            ,
       gf.dots        = gf_dots(..., .def = default)                         ,
       dots           = failsafe(dots_by_name(sub.names, defaults, ...))     ,
       dot1           = failsafe(dot_by_name(sub.names[1], defaults[1], ...)))
}

egdot_args(     "a",  b ,      "c",  d ,      "e")
egdot_args(Aa = "a",  b , Cc = "c",  d , Ee = "e")
egdot_args(Aa = "a", "b", Cc = "c", "d", Ee = "e")
egdot_args(letters, digits = 0:9, data.frame(letters, 0:26))
}
\seealso{
Other meta: 
\code{\link{callers}()},
\code{\link{console_basics}()},
\code{\link{pause}()},
\code{\link{ply}()},
\code{\link{purge}()},
\code{\link{recyclable_ns}()},
\code{\link{run}()}
}
\concept{args}
\concept{meta}
