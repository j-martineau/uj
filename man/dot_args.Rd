% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dot_args.R
\encoding{UTF-8}
\name{dot_args}
\alias{dot_args}
\alias{d_args}
\alias{dot_by_name}
\alias{d_by_name}
\alias{dots_by_name}
\alias{ds_by_name}
\alias{dot_names}
\alias{dnames}
\alias{dn}
\alias{named_dots}
\alias{name_ds}
\alias{anon_dots}
\alias{anon_ds}
\alias{named_dot}
\alias{named_d}
\alias{anon_dot}
\alias{anon_d}
\alias{flex_dot}
\alias{flex_d}
\alias{flex_dots}
\alias{flex_ds}
\alias{glue_dot}
\alias{glue_d}
\alias{glue_dots}
\alias{glue_ds}
\alias{glue_flex_dots}
\alias{glue_flex_ds}
\alias{gf_dots}
\alias{gf_ds}
\alias{gfds}
\alias{glue_flex_dot}
\alias{glue_flex_d}
\alias{gf_dot}
\alias{gfd}
\title{Manage \code{...} arguments}
\usage{
dot_args()

d_args()

dot_by_name(.name, .def, ...)

d_by_name(.name, .def, ...)

dots_by_name(.names, .defs, ...)

ds_by_name(.names, .defs, ...)

dot_names(..., .subs = NULL, .req = TRUE)

dnames(..., .subs = NULL, .req = TRUE)

dn(..., .subs = NULL, .req = TRUE)

named_dots(...)

name_ds(...)

anon_dots(...)

anon_ds(...)

named_dot(.n, ...)

named_d(.n, ...)

anon_dot(.n, ...)

anon_d(.n, ...)

flex_dot(.n, ..., .glue = FALSE, .def = "", .d = " ")

flex_d(.n, ..., .glue = FALSE, .def = "", .d = " ")

flex_dots(..., .glue = FALSE, .def = "", .d = " ")

flex_ds(..., .glue = FALSE, .def = "", .d = " ")

glue_dot(..., .n = 1, .def = "", .d = " ")

glue_d(..., .n = 1, .def = "", .d = " ")

glue_dots(..., .def = "", .d = " ")

glue_ds(..., .def = "", .d = " ")

glue_flex_dots(..., .def = "", .d = " ")

glue_flex_ds(..., .def = "", .d = " ")

gf_dots(..., .def = "", .d = " ")

gf_ds(..., .def = "", .d = " ")

gfds(..., .def = "", .d = " ")

glue_flex_dot(..., .n = 1, .def = "", .d = " ")

glue_flex_d(..., .n = 1, .def = "", .d = " ")

gf_dot(..., .n = 1, .def = "", .d = " ")

gfd(..., .n = 1, .def = "", .d = " ")
}
\arguments{
\item{.name}{\code{NULL} or \link[=cmp_scl]{complete atomic scalar}. \code{NULL} is replaced with \code{'NULL'} and \code{NA} is replaced with \code{'NA'}.}

\item{.def}{A default object/value to return if a specified argument is not in \code{...}. For \code{glue_dots} and \code{glue_dot}, must be a \link[=cmp_chr_vec]{complete character vec}. For all others, may be, but does not need to be, a list.}

\item{...}{An arbitrary number of arguments.}

\item{.names}{\code{NULL} or an \link[=atm_vec]{atomic vec} (may include \code{NA} values). Is split along the delimiter \code{'|'} to allow for compactness in submitting multiple .names \code{NULL} will match either an argument in \code{...} or element of \code{.defs} with the Name \code{'NULL'}. \code{NA} values will match an argument in \code{...} or an element of \code{.defs} with the Name \code{'NA'}.}

\item{.defs}{A named \link[=VLS]{vlist} of default objects/values to return if the specified arguments are not in \code{...}. Elements of \code{.defs} must be uniquely nameD If \code{.defs} is a tibble, columns with matching names are returned.}

\item{.subs}{\code{NULL} or \link[=cmp_chr_vec]{complete character vec}. If not \code{NULL}, it is split using pipes \code{'|'} as a delimiter. If there are no pipes contained in \code{.names}, it remains unchangeD When this argument is not \code{NULL}, it is substituted for the names of \code{...} arguments; thus, after splitting, its length must equal the number of \code{...} arguments. For example, \code{.names = c('one', 'two', 'three|four|five')} indicates that there should be five \code{...} arguments and the vector \code{c('one', 'two', 'three', 'four', 'five')} is substituted for their names.}

\item{.req}{\code{TRUE} or \code{FALSE} indicating whether names are required.}

\item{.n}{A positive integer indicating which \code{...} arg to return.}

\item{.glue}{\code{TRUE} or \code{FALSE} indicating whether to glue the result (collapse into a character scalar) using the delimiter \code{.d}.}

\item{.d}{A \link[=cmp_chr_scl]{complete character scalar} for collapsing results to a character scalar.}
}
\value{
\strong{An object}                                 \cr\cr \verb{dot_by_name, d_by_name}        \cr \verb{named_dot, named_d}   \cr \verb{anon_dot, anon_d}
\cr\cr  \strong{A list}                                    \cr\cr \verb{dots_by_name, ds_by_name}      \cr \verb{named_dots, named_ds} \cr \verb{anon_dots, anon_ds}
\cr\cr  \strong{A character scalar}                        \cr\cr \verb{glue_dots, glue_dot, gdot, gd} \cr \verb{glue_flex_dots, gf_dots, gf_dot, gfdot, gfd}
\cr\cr  \strong{A character vector} (when \code{.glue = FALSE}) \cr\cr \verb{flex_dots, flex_ds}            \cr \verb{flex_dot, flex_d}
\cr\cr  \strong{A character scalar} (when \code{.glue = TRUE})  \cr\cr \verb{flex_dots, flex_ds}            \cr \verb{flex_dot, flex_d}
\cr\cr  \strong{A character vector}                        \cr\cr \verb{dot_names, dnames, dn}
}
\description{
Enhanced of functions for managing \code{...} arguments.
}
\details{
\strong{\code{dot_names}} and \strong{\code{dnames}} are enhancements of \code{...names} that flexibly retrieves names of all \code{...} args by substituting the corresponding value of \code{.subs} If a \code{...} arg's name is missing or blank (\code{""}), the corresponding value of \code{.names} is substituted Throws an error in the following circumstances:
\itemize{\item \code{...length() == 0}
\item \code{length(.names) > 0 & length(.names) < ...length()}
\item \code{is.null(.names) & ..bl & any(...names() == "")}
\item \code{is.null(.names) & .req & !any(...names() != "")}
\item \code{is.null(.names) & .u & any(duplicated(...names()))}}
\cr The remaining functions in this family are as follows:
\tabular{ll}{  \verb{dots_by_name, ds_by_name}      \tab Enhancement of \code{list(...)} that extracts one or more\code{...} args based on matching values supplied in \code{.names}. If a supplied Name matches the Name of a \code{...}
arg, that arg is returned. Otherwise, the element of \code{.defs} with a matching Name is returned. \code{.names = NULL} and \code{.names = NA} are converted to \code{'NULL'} and
\code{'NA'}. Reserved words should be backtick quoted.                                                                                                               \cr   \tab   \cr
  \verb{dot_by_name, d_by_name}        \tab Get a single \code{...} arg by name.                                                                                                                                 \cr   \tab   \cr
  \verb{named_dots, named_ds}          \tab Get a named list containing named \code{...} arg values.                                                                                                             \cr   \tab   \cr
  \verb{named_dot, named_d}            \tab Get the \code{.n}-th named \code{...} arg.                                                                                                                                \cr   \tab   \cr
  \verb{anon_dots, anon_ds}            \tab Get an unnamed list containing unnamed (anonymous) \code{...} arg values.                                                                                            \cr   \tab   \cr
  \verb{anon_dot, anon_d}              \tab Get the \code{.n}-th unnamed (anonymous) \code{...} arg.                                                                                                                  \cr   \tab   \cr
  \verb{flex_dots, flex_ds}            \tab Retrieve a list of \code{...length()} elements where the \code{.n}\eqn{^{th}} element is the flexibly evaluated value of \code{...elt(.n)}, where flexible evaluation of \code{...}
arg values means that a \code{...} arg takes on the unadjusted value if \link[=base:force]{forcing} evaluation does not generate an error. Otherwise, it takes as
its value the string literal representing it in a function call. For example, \code{f(exactly, 5-2, words)} and \code{f("exactly", "3", "words")} give identical results
in the following circumstances: The usage of \code{f} is defined as \code{f(...)}, \code{f} treats each \code{...} arg as a flexdot, and in the immediate environment that calls
\code{f(...)} there are no defined objects with the names \code{exactly} and \code{words}.                                                                                     \cr   \tab   \cr
  \verb{flex_dot, flex_d}              \tab Get the \code{.n}-th \code{...} arg, flexibly evaluated.                                                                                                                  \cr   \tab   \cr
  \verb{dot_names, dnames, dn}         \tab Get all \code{...} arg names, substituting names if necessary.                                                                                                       \cr   \tab   \cr
  \verb{glue_dots, g_dots, gdots, gds} \tab Collapse \code{...} args to a character scalar by calling \code{\link[base]{paste0}}\code{(}\code{\link{av}}\verb{(...), collapse = .d)}.                                      \cr   \tab   \cr
  \verb{glue_dot, gdot, gd}            \tab Get the \code{.n}-th \code{...} arg, glued.                                                                                                                               \cr   \tab   \cr
  \verb{glue_flex_dots, gf_dots, gfds} \tab Combo functionality of \code{glue_dots} and \code{flex_dots} to glue flexibly evaluated \code{...} args into a character scalar.                                               \cr   \tab   \cr
  \verb{glue_flex_dot, gf_dot, gfd}    \tab Get the \code{.n}-th \code{...} arg, flexibly evaluated and glued.                                                                                                                       }
}
\examples{
egdot_args <- function(...) {
  nDots <- ...length()
  if (nDots > 1) {
    sub.names <- paste0(letters[1:nDots], LETTERS[1:nDots])
    defaults <- as.list(LETTERS[1:nDots])
    default <- "{missing}"
  } else {
    sub.names <- NULL
    defaults <- "{no Dot args}"
    default <- "{no Dot args}"
  }
  glue.flex.dots <- flex_dots(..., .glue = TRUE, .def = default, .d = "_")
  glue.flex.dot2 <- flex_dot(..., .n = 2, .glue = TRUE)
  subbed.names   <- failsafe(dot_names(..., .subs = sub.names))
  named.dots     <- failsafe(named_dots(...))
  anon.dots      <- failsafe(anon_dots(...))
  dot.names      <- failsafe(dot_names(...))
  flex.dots      <- flex_dots(..., .defs = default)
  flex.dot2      <- flex_dot(..., .n = 2)
  glue.dots      <- failsafe(glue_dots(..., .defs = default))
  gf.dots        <- gf_dots(..., .def = default)
  dots           <- failsafe(dots_by_name(sub.names, defaults, ...))
  dot1           <- failsafe(dot_by_name(sub.names[1], defaults[1], ...))

  list(glue.flex.dots = glue.flex.dots,
       glue.flex.dot2 = glue.flex.dot2,
       subbed.names   = subbed.names ,
       named.dots     = named.dots   ,
       anon.dots      = anon.dots    ,
       dot.names      = dot.names    ,
       flex.dots      = flex.dots    ,
       flex.dot2      = flex.dot2    ,
       glue.dots      = glue.dots    ,
       gf.dots        = gf.dots      ,
       dots           = dots         ,
       dot1           = dot1         )
}

egdot_args(     "a",  b ,      "c",  d ,      "e")
egdot_args(Aa = "a",  b , Cc = "c",  d , Ee = "e")
egdot_args(Aa = "a", "b", Cc = "c", "d", Ee = "e")
egdot_args(letters, digits = 0:9, data.frame(letters, 0:26))
}
\seealso{
Other meta: 
\code{\link{callers}()},
\code{\link{console_help}()},
\code{\link{pause}()},
\code{\link{ply_help}()},
\code{\link{purge_help}()},
\code{\link{recycling_help}()},
\code{\link{run}()}
}
\concept{args}
\concept{meta}
