% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mkstr.R
\name{mkstr}
\alias{mkstr}
\alias{geq}
\alias{geq0}
\alias{gcat}
\alias{gelt}
\alias{gfun}
\alias{glst}
\alias{gform}
\alias{gtick}
\alias{gwrap}
\alias{gbrace}
\alias{gcolon}
\alias{gparen}
\alias{gquote}
\alias{gquote2}
\alias{gbracket}
\alias{pcat}
\alias{peq}
\alias{peq0}
\alias{pelt}
\alias{pfun}
\alias{plst}
\alias{pform}
\alias{ptick}
\alias{pwrap}
\alias{pbrace}
\alias{pcolon}
\alias{pparen}
\alias{pquote}
\alias{pquote2}
\alias{pbracket}
\title{Specialized String Building Functions}
\usage{
geq(x, ...)

geq0(x, ...)

gcat(...)

gelt(x, ...)

gfun(x, ...)

glst(...)

gform(x, ...)

gtick(...)

gwrap(l, r, ...)

gbrace(...)

gcolon(...)

gparen(...)

gquote(...)

gquote2(...)

gbracket(...)

pcat(...)

peq(x, ...)

peq0(x, ...)

pelt(x, ...)

pfun(x, ...)

plst(...)

pform(x, ...)

ptick(...)

pwrap(l, r, ...)

pbrace(...)

pcolon(...)

pparen(...)

pquote(...)

pquote2(...)

pbracket(...)
}
\arguments{
\item{x}{An object containing atomic values (atomized).}

\item{...}{An arbitrary number of objects to be atomized into a single atomic
vector.}

\item{l, r}{\link[=cmp_chr_scl]{Complete character scalars} giving left and
right side enclosures for \code{...} after \link[=a]{atomization}.}
}
\value{
Character vector
}
\description{
Build strings where function name components have the following
meaning:\tabular{ll}{
prefix = \code{g}         \tab Glue/collapse values within.           \cr
prefix = \code{p}         \tab Paste values across.                   \cr
                     \tab                                        \cr
suffix = \code{eq}        \tab Space-padded equality statement.       \cr
suffix = \code{eq0}       \tab Non-padded equality statement.         \cr
suffix = \code{cat}       \tab Vector concatenation statement.        \cr
suffix = \code{elt}       \tab Element extraction statement.          \cr
suffix = \code{fun}       \tab Function call statement.               \cr
suffix = \code{lst}       \tab Comma-separated list.                  \cr
suffix = \code{form}      \tab Formula statement.                     \cr
suffix = \code{colon}     \tab Separate by colons.                    \cr
suffix = \code{wrap}      \tab Enclose on left and right.             \cr
suffix = \code{tick}      \tab Enclose in back-ticks.                 \cr
suffix = \code{quote}     \tab Enclose in single quotes.              \cr
suffix = \code{quote2}    \tab Enclose in double quotes.              \cr
suffix = \code{brace}     \tab Enclose in curly braces.               \cr
suffix = \code{paren}     \tab Enclose in parentheses.                \cr
suffix = \code{bracket}   \tab Enclose in square brackets.              }
Each prefix is joined with each suffix to create a unique function. The
action indicated by the prefix happens first, followed by the action
indicated in the suffix. How each function works is illustrated in the
details.
}
\details{
\tabular{ll}{
FUNCTION CALL                             \tab RESULT OF FUNCTION CALL    \cr
\verb{geq(c('x', 'y', 'z'), 0, 1, 2)}          \tab \code{'xyz = 012'}              \cr
\verb{peq(c('x', 'y', 'z'), 0, 1, 2)}          \tab \code{c('x = 012', 'y = 012',
                                               'z = 012')}                \cr
                                          \tab                            \cr
\verb{geq0(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'xyz=012'}                \cr
\verb{peq0(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{c('x=012', 'y=012',
                                               'z=012')}                  \cr
                                          \tab                            \cr
\verb{gcat(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'c(xyz012)'}              \cr
\verb{pcat(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'c(x, y, z, 0, 1, 2)'}    \cr
                                          \tab                            \cr
\verb{gelt(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'xyz[012]'}               \cr
\verb{pelt(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{c('x[0]', 'y[1]', 'z[2]')}\cr
                                          \tab                            \cr
\verb{gfun(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'xyz(012)'}               \cr
\verb{pfun(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{c('x(0)', 'y(1)', 'z(2)')}\cr
                                          \tab                            \cr
\verb{glst(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{'x, y, z, 0, 1, 2'}       \cr
\verb{plst(c('x', 'y', 'z'), 0, 1, 2)}         \tab \code{c('x, 0, 1, 2',
                                                       'y, 0, 1, 2',
                                                       'z, 0, 1, 2')}     \cr
                                          \tab                            \cr
\verb{gform(c('x', 'y', 'z'), 0, 1, 2)}        \tab \code{'xyz ~ 0 + 1 + 2'}        \cr
\verb{pform(c('x', 'y', 'z'), 0, 1, 2)}        \tab \code{c('x ~ 0 + 1 + 2',
                                                      'y ~ 0 + 1 + 2',
                                                      'z ~ 0 + 1 + 2')}   \cr
                                          \tab                            \cr
\verb{gtick(c('x', 'y', 'z'), 0, 1, 2)}        \tab \verb{'}xyz012\verb{'}               \cr
\verb{ptick(c('x', 'y', 'z'), 0, 1, 2)}        \tab \code{c('`x012`', '`y012`',
                                                       '`z012`')}         \cr
                                          \tab                            \cr
\verb{gwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)}   \tab \code{'lLl012r'}                \cr
\verb{pwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)}   \tab \code{c('l012r', 'L012r',
                                                       'l012r')}          \cr
                                          \tab                            \cr
\verb{gbrace(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{'\\{xyz012\\}'}             \cr
\verb{pbrace(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{c('\{x012\}',
                                                       '\{y012\}',
                                                       '\{z012\`')}       \cr
                                          \tab                            \cr
\verb{gcolon(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{'x:y:z:0:1:2'}            \cr
\verb{pcolon(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{c('x:0:1:2', 'y:0:1:2',
                                                       'z:0:1:2')}        \cr
                                          \tab                            \cr
\verb{gparen(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{'(xyz012)'}               \cr
\verb{pparen(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{c('(x012)', '(y012)',
                                                       '(z012)')}         \cr
                                          \tab                            \cr
\verb{gquote(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{"'xyz012'"}               \cr
\verb{pquote(c('x', 'y', 'z'), 0, 1, 2)}       \tab \code{c('"x012"', '"y012"',
                                                       '"z012"')}         \cr
                                          \tab                            \cr
\verb{gquote2(c('x', 'y', 'z'), 0, 1, 2)}      \tab \code{"'xyz012'"}               \cr
\verb{pquote2(c('x', 'y', 'z'), 0, 1, 2)}      \tab \code{c('"x012"', '"y012"',
                                                       '"z012"')}         \cr
                                          \tab                            \cr
\verb{gbracket(c('x', 'y', 'z'), 0, 1, 2)}     \tab \code{'[xyz012]'}               \cr
\verb{pbracket(c('x', 'y', 'z'), 0, 1, 2)}     \tab \code{c('[x012]', '[y012]',
                                                       '[z012]')}           }
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{charn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{ipat}()},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spacing}},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
