% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mkstr.R
\name{mkstr}
\alias{mkstr}
\alias{geq}
\alias{geq0}
\alias{gcat}
\alias{gelt}
\alias{gfun}
\alias{glst}
\alias{gform}
\alias{gtick}
\alias{gwrap}
\alias{gbrace}
\alias{gcolon}
\alias{gparen}
\alias{gquote}
\alias{gquote2}
\alias{gbracket}
\alias{pcat}
\alias{peq}
\alias{peq0}
\alias{pelt}
\alias{pfun}
\alias{plst}
\alias{pform}
\alias{ptick}
\alias{pwrap}
\alias{pbrace}
\alias{pcolon}
\alias{pparen}
\alias{pquote}
\alias{pquote2}
\alias{pbracket}
\title{Specialized string building functions}
\usage{
geq(x, ...)

geq0(x, ...)

gcat(...)

gelt(x, ...)

gfun(x, ...)

glst(...)

gform(x, ...)

gtick(...)

gwrap(l, r, ...)

gbrace(...)

gcolon(...)

gparen(...)

gquote(...)

gquote2(...)

gbracket(...)

pcat(...)

peq(x, ...)

peq0(x, ...)

pelt(x, ...)

pfun(x, ...)

plst(...)

pform(x, ...)

ptick(...)

pwrap(l, r, ...)

pbrace(...)

pcolon(...)

pparen(...)

pquote(...)

pquote2(...)

pbracket(...)
}
\arguments{
\item{x}{An object containing atomic values (atomized before processing).}

\item{...}{An arbitrary number of objects to be atomized into a single atomic vector.}

\item{l, r}{\link[=cmp_chr_scl]{Complete character scalars} giving left and right side enclosures for \code{...} after \link[=a]{atomization}.}
}
\value{
A character scalar or vector
}
\description{
Build strings where function names are composed of a single-letter prefix and a longer suffix. Prefixes and their meanings are \itemize{
\item \strong{\code{g}}: glue/collapse \code{...} arguments
\item \strong{\code{p}}: paste across corresponding elements of \code{...} arguments.
}
Suffixes and their meanings are \itemize{
\item \strong{\code{eq}}: space-padded equality statement.
\item \strong{\code{eq0}}: non-padded equality statement.
\item \strong{\code{cat}}: vector concatenation statement.
\item \strong{\code{elt}}: element extraction statement.
\item \strong{\code{fun}}: function call statement.
\item \strong{\code{form}}: formula statement.
\item \strong{\code{lst}}: delimit with comma + space.
\item \strong{\code{colon}}: delimit with colons.
\item \strong{\code{wrap}}: enclose in different left and right values.
\item \strong{\code{tick}}: enclose in back-ticks.
\item \strong{\code{brace}}: enclose in curly braces.
\item \strong{\code{paren}}: enclose in parentheses.
\item \strong{\code{quote}}: enclose in single quotes.
\item \strong{\code{quote2}}: enclose in double quotes.
\item \strong{\code{bracket}}: enclose in square brackets.
}
Each prefix is joined with each suffix to create a unique function. The action indicated by the prefix happens first, followed by the action indicated in the suffix. How each function works is illustrated in the details.
}
\examples{
geq(c('x', 'y', 'z'), 0, 1, 2)
geq0(c('x', 'y', 'z'), 0, 1, 2)
gcat(c('x', 'y', 'z'), 0, 1, 2)
gelt(c('x', 'y', 'z'), 0, 1, 2)
gfun(c('x', 'y', 'z'), 0, 1, 2)
gform(c('x', 'y', 'z'), 0, 1, 2)

peq(c('x', 'y', 'z'), 0, 1, 2)
peq0(c('x', 'y', 'z'), 0, 1, 2)
pcat(c('x', 'y', 'z'), 0, 1, 2)
pelt(c('x', 'y', 'z'), 0, 1, 2)
pfun(c('x', 'y', 'z'), 0, 1, 2)
pform(c('x', 'y', 'z'), 0, 1, 2)

glst(c('x', 'y', 'z'), 0, 1, 2)
gtick(c('x', 'y', 'z'), 0, 1, 2)

plst(c('x', 'y', 'z'), 0, 1, 2)
ptick(c('x', 'y', 'z'), 0, 1, 2)

gbrace(c('x', 'y', 'z'), 0, 1, 2)
gcolon(c('x', 'y', 'z'), 0, 1, 2)
gparen(c('x', 'y', 'z'), 0, 1, 2)
gquote(c('x', 'y', 'z'), 0, 1, 2)
gquote2(c('x', 'y', 'z'), 0, 1, 2)
gbracket(c('x', 'y', 'z'), 0, 1, 2)
gwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)

pbrace(c('x', 'y', 'z'), 0, 1, 2)
pcolon(c('x', 'y', 'z'), 0, 1, 2)
pparen(c('x', 'y', 'z'), 0, 1, 2)
pquote(c('x', 'y', 'z'), 0, 1, 2)
pquote2(c('x', 'y', 'z'), 0, 1, 2)
pbracket(c('x', 'y', 'z'), 0, 1, 2)
pwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{charn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{ipat}()},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spacing}},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
