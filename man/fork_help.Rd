% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fork.R
\encoding{UTF-8}
\name{fork_help}
\alias{fork_help}
\alias{f0}
\alias{fork}
\alias{f1}
\alias{nll_if}
\alias{nll_ifs}
\alias{nll_if_any}
\alias{nll_if_all}
\alias{nll_if_none}
\title{Enhancements of \code{\link[base]{ifelse}}.}
\usage{
fork_help()

f0(x, y, n)

fork(x, y, n, na = n)

f1(x, y, n, na = n, err = n)

nll_if(x, ..., d = " ")

nll_ifs(..., .d = " ", .cond = "all")

nll_if_any(..., .d = " ")

nll_if_all(..., .d = " ")

nll_if_none(..., .d = " ")
}
\arguments{
\item{x}{A logical scalar (if not,\code{x} it is replaced by \code{FALSE}).}

\item{y, n}{Any valid R object.}

\item{na}{An object of any type for \code{f1}. An atomic scalar \link[=compatible]{compatible} with \code{y} and \code{n} for \code{fork}, with the additional possibility of \code{na = 'err'} to indicate an error should be thrown if any values in \code{x} are \code{NA}.}

\item{err}{Either \code{'err'} or an object to be returned when \code{x} is not an atomic scalar in \code{c(TRUE, FALSE, NA)}.}

\item{d, .d}{A character scalar delimiter for collapsing objects into scalar character objects. If \code{.d} is not a character scalar, it is replaced by \code{" "}.}

\item{.cond}{A character scalar in \code{c('all', 'any', 'none')}. If \code{.cond} is not of an allowed value, it is replaced by \code{'all'}.}
}
\description{
Return different types of objects for \code{TRUE} and \code{FALSE} and return \code{NULL}  conditional on the number of \code{TRUE} values.
}
\section{Functions}{
\itemize{
\item \code{f0()}: If \code{x} is scalar \code{TRUE}, returns \code{y}. If \code{x} is anything else, returns \code{n}.

\item \code{fork()}: Evaluates logical scalar or logical vector \code{x} and return an object of the same length as \code{x} where:
\itemize{\item \code{TRUE} values of \code{x} are replaced by corresponding values of \code{y}.
\item \code{FALSE} values of \code{x} are replaced by corresponding values of \code{n}.
\item \code{NA} values of \code{x} are replaced by \code{na} (unless \code{na = 'err'}, in which case if there are any \code{NA} values in \code{x}, throws an error). }
Returns a length-\code{length(x)} atomic object.

\item \code{f1()}: Error-checked version of \code{f0}. Evaluates and processes logical scalar \code{x} in the following manner:
\itemize{\item If \code{x = TRUE}, returns \code{y}.
\item If \code{x = FALSE}, returns \code{y}.
\item If \code{x = NA}, returns \code{na} unless \code{na = 'err'}, in which case, an error is thrown.
\item If \code{x} is neither a logical scalar nor scalar \code{NA}, returns \code{err} unless \code{err = 'err'}, in which case an error is thrown. }

\item \code{nll_if()}: If \code{x} is scalar \code{TRUE}, returns \code{NULL}, otherwise collapses \code{...} args to a character scalar using delimiter \code{d} and returns the result.

\item \code{nll_ifs()}: Calls \code{nll_if_none(..., d = .d)} when \code{.cond = 'none'}. Calls \code{nll_if_any(..., d = .d)} when \verb{.cond = 'any}. Calls \code{nll_if_all(..., d = .d)} when \code{.cond} takes any other value (including \code{'all'})

\item \code{nll_if_any()}: Returns \code{NULL} if any named \code{...} argument is scalar \code{TRUE}. Otherwise, returns a message composed of unnamed \code{...} args collapsed into a character scalar using the delimiter \code{.d}.

\item \code{nll_if_all()}: Returns \code{NULL} if all named \code{...} arguments are scalar \code{TRUE}. Otherwise, returns a message composed of unnamed \code{...} args collapsed into a character scalar using the delimiter \code{.d}.

\item \code{nll_if_none()}: Returns \code{NULL} if no named \code{...} argument is scalar \code{TRUE}. Otherwise, returns a message composed of unnamed \code{...} args collapsed into a character scalar using the delimiter \code{.d}.

}}
\examples{
fork(c(TRUE, FALSE, TRUE, NA), 1, 2)
fork(c(TRUE, FALSE, TRUE, NA), 1, 2, na = 0)
fork(c(TRUE, FALSE, TRUE, NA), 1, 2, na = NA)
fork(c(TRUE, FALSE, TRUE, NA), 1:4, 5:8)

f0(NA, data.frame(letters = letters), 0:26)
f0(TRUE, data.frame(letters = letters), 0:26)
f0(FALSE, data.frame(letters = letters), 0:26)
f0(list(1, "a"), data.frame(letters = letters), 0:26)
f0(c(.bad.varname.), data.frame(letters = letters), 0:26)

f1(NA, data.frame(letters = letters), 0:26)
f1(NA, data.frame(letters = letters), 0:26, na = NA)
f1(TRUE, data.frame(letters = letters), 0:26)
f1(FALSE, data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26)
f1(c(.bad.varname.), data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26, err = "error")
f1(c(.bad.varname.), data.frame(letters = letters), 0:26, err = "error")

nll_if(TRUE, "an error", "message")
nll_if(FALSE, "an error", "message")
nll_if(41, "an error", "message")

nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "any", .cond = "all")
nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "all", .cond = "any")
nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "none", .cond = "none")
nll_if_any(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "any")
nll_if_all(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "all")
nll_if_none(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "none")
}
\seealso{
Other forks: 
\code{\link{case}()},
\code{\link{swap_help}()}
}
\concept{forks}
