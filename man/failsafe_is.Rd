% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/failsafe_is.R
\encoding{UTF-8}
\name{failsafe_is}
\alias{failsafe_is}
\alias{isNAS}
\alias{isOKS}
\alias{isOUT}
\alias{isIN}
\alias{isID}
\alias{isEQ}
\alias{isT}
\alias{isF}
\alias{isTF}
\alias{isLG}
\alias{isBL}
\alias{notIN}
\alias{notOUT}
\alias{notID}
\alias{notEQ}
\alias{notTF}
\alias{notLG}
\alias{notT}
\alias{notF}
\alias{notNAS}
\alias{notOKS}
\alias{notBL}
\alias{norIN}
\alias{norOUT}
\alias{norID}
\alias{norEQ}
\alias{norT}
\alias{norF}
\alias{norNAS}
\alias{norOKS}
\alias{norTF}
\alias{norLG}
\alias{norBL}
\alias{anyIN}
\alias{anyOUT}
\alias{anyID}
\alias{anyEQ}
\alias{anyT}
\alias{anyF}
\alias{anyNAS}
\alias{anyOKS}
\alias{anyTF}
\alias{anyLG}
\alias{anyBL}
\alias{allIN}
\alias{allOUT}
\alias{allID}
\alias{allEQ}
\alias{allT}
\alias{allF}
\alias{allNAS}
\alias{allOKS}
\alias{allTF}
\alias{allLG}
\alias{allBL}
\alias{oneIN}
\alias{oneOUT}
\alias{oneID}
\alias{oneEQ}
\alias{oneT}
\alias{oneF}
\alias{oneNAS}
\alias{oneOKS}
\alias{oneTF}
\alias{oneLG}
\alias{oneBL}
\alias{twoIN}
\alias{twoOUT}
\alias{twoID}
\alias{twoEQ}
\alias{twoT}
\alias{twoF}
\alias{twoNAS}
\alias{twoOKS}
\alias{twoTF}
\alias{twoLG}
\alias{twoBL}
\title{Failsafe \code{is} functions}
\usage{
isNAS(x)

isOKS(x)

isOUT(x, ...)

isIN(x, ...)

isID(x, y)

isEQ(x, y)

isT(x)

isF(x)

isTF(x)

isLG(x)

isBL(x)

notIN(x, ...)

notOUT(x, ...)

notID(x, y)

notEQ(x, y)

notTF(x)

notLG(x)

notT(x)

notF(x)

notNAS(x)

notOKS(x)

notBL(x)

norIN(x, ...)

norOUT(x, ...)

norID(x, y)

norEQ(x, y)

norT(x)

norF(x)

norNAS(x)

norOKS(x)

norTF(x)

norLG(x)

norBL(x)

anyIN(x, ...)

anyOUT(x, ...)

anyID(x, y)

anyEQ(x, y)

anyT(x)

anyF(x)

anyNAS(x)

anyOKS(x)

anyTF(x)

anyLG(x)

anyBL(x)

allIN(x, ...)

allOUT(x, ...)

allID(x, y)

allEQ(x, y)

allT(x)

allF(x)

allNAS(x)

allOKS(x)

allTF(x)

allLG(x)

allBL(x)

oneIN(x, ...)

oneOUT(x, ...)

oneID(x, y)

oneEQ(x, y)

oneT(x)

oneF(x)

oneNAS(x)

oneOKS(x)

oneTF(x)

oneLG(x)

oneBL(x)

twoIN(x, ...)

twoOUT(x, ...)

twoID(x, y)

twoEQ(x, y)

twoT(x)

twoF(x)

twoNAS(x)

twoOKS(x)

twoTF(x)

twoLG(x)

twoBL(x)
}
\arguments{
\item{x, y}{Any R object.}

\item{...}{Objects to check \code{x} against for functions with the suffix \code{IN} or \code{OUT}.}
}
\value{
Scalar \code{TRUE} or \code{FALSE}.
}
\description{
These functions \emph{always} produce \code{TRUE} or \code{FALSE} results unless calling \code{identity(.)} produce an error.
\cr\cr Function names are constructed of prefixes and suffixes, where the suffix specifies what type of check is conducted and the prefix specifies how the check is modified or applied and swept across multiple values.
\cr\cr \emph{Type-of-check suffixes}
\tabular{rl}{
  \code{NAS}   \tab \code{NA} scalar.
\cr \code{OKS}   \tab Non-\code{NA} scalar.
\cr \code{OUT}   \tab Atomic scalar \code{x} \emph{is not in} \code{...}\eqn{^1}.
\cr  \code{IN}   \tab Atomic scalar \code{x} \emph{is in} \code{...}\eqn{^1}.
\cr  \code{EQ}   \tab Calls \code{\link[base:setequal]{setequal(x, y)}}.
\cr  \code{ID}   \tab Calls \code{\link[base:identical]{identical(x, y)}}.
\cr  \code{LG}   \tab Scalar logical (\code{TRUE}, \code{FALSE}, or \code{NA}).
\cr  \code{TF}   \tab Scalar \code{TRUE} or \code{FALSE}.
\cr  \code{BL}   \tab Scalar blank (\code{""}).
\cr   \code{F}   \tab Scalar \code{FALSE}.
\cr   \code{T}   \tab Scalar \code{TRUE}.
}
\verb{ }\eqn{^{1.}} Evaluates membership in any \link[=av]{atomized} \code{...} argument.
\cr\cr \emph{Modifying prefixes} \tabular{rl}{
  \code{not}   \tab Negation
\cr \code{is}   \tab Identity
}
\cr \emph{Apply-and-sweep prefixes to count} \code{TRUE} \emph{values} \tabular{rl}{
  \code{nor}   \tab \code{0}
\cr \code{one}   \tab \code{1}
\cr \code{any}   \tab \verb{1+}
\cr \code{two}   \tab \verb{2+}
\cr \code{all}   \tab All
}
\cr \emph{Combining prefixes and suffixes}
\cr\cr All prefixes combine with all suffixes to form function names.
}
\examples{
Blank. <- ""
MssScl. <- NA
LglScl. <- FALSE
FacScl. <- factor("q", levels = c("x", "q"))
FacVec. <- factor(c("x", "q"), levels = c("x", "q"))
ChrMat. <- matrix(c("a", "b", "c", "NA"), nrow = 2)
ChrDtf. <- data.frame(abc = letters[1:3], def = letters[4:6])
NumVls. <- list(first3 = c(1:3, NA), next3 = c(4:6, NA))
Combo. <- list(MssScl., LglScl., FacVec., ChrMat., ChrDtf., NumVls.)

isIN(ChrMat., Blank., Combo.)
notIN(ChrMat., Blank., Combo.)
norIN(ChrMat., Blank., Combo.)
anyIN(ChrMat., Blank., Combo.)
allIN(ChrMat., Blank., Combo.)
oneIN(ChrMat., Blank., Combo.)
twoIN(ChrMat., Blank., Combo.)

isOUT(ChrMat., Blank., Combo.)
notOUT(ChrMat., Blank., Combo.)
norOUT(ChrMat., Blank., Combo.)
anyOUT(ChrMat., Blank., Combo.)
allOUT(ChrMat., Blank., Combo.)
oneOUT(ChrMat., Blank., Combo.)
twoOUT(ChrMat., Blank., Combo.)

isIN(NULL, Blank., Combo.)
notIN(NULL, Blank., Combo.)
norIN(NULL, Blank., Combo.)
anyIN(NULL, Blank., Combo.)
allIN(NULL, Blank., Combo.)
oneIN(NULL, Blank., Combo.)
twoIN(NULL, Blank., Combo.)

isOUT(NULL, Blank., Combo.)
notOUT(NULL, Blank., Combo.)
norOUT(NULL, Blank., Combo.)
anyOUT(NULL, Blank., Combo.)
allOUT(NULL, Blank., Combo.)
oneOUT(NULL, Blank., Combo.)
twoOUT(NULL, Blank., Combo.)

isID(LglScl., FALSE)
notID(LglScl., FALSE)
norID(Combo., ChrDtf.)
anyID(Combo., ChrDtf.)
allID(Combo., ChrDtf.)
oneID(Combo., ChrDtf.)
twoID(Combo., ChrDtf.)

isEQ(FacVec., Combo.)
notEQ(FacVec., Combo.)
norEQ(FacVec., Combo.)
anyEQ(FacVec., Combo.)
allEQ(FacVec., Combo.)
oneEQ(FacVec., Combo.)
twoEQ(FacVec., Combo.)

isT(c(list(Blank.), Combo.))
notT(c(list(Blank.), Combo.))
norT(c(list(Blank.), Combo.))
anyT(c(list(Blank.), Combo.))
allT(c(list(Blank.), Combo.))
oneT(c(list(Blank.), Combo.))
twoT(c(list(Blank.), Combo.))

isF(c(list(Blank.), Combo.))
notF(c(list(Blank.), Combo.))
norF(c(list(Blank.), Combo.))
anyF(c(list(Blank.), Combo.))
allF(c(list(Blank.), Combo.))
oneF(c(list(Blank.), Combo.))
twoF(c(list(Blank.), Combo.))

isTF(c(list(Blank.), Combo.))
notTF(c(list(Blank.), Combo.))
norTF(c(list(Blank.), Combo.))
anyTF(c(list(Blank.), Combo.))
allTF(c(list(Blank.), Combo.))
oneTF(c(list(Blank.), Combo.))
twoTF(c(list(Blank.), Combo.))

isLG(c(list(Blank.), Combo.))
notLG(c(list(Blank.), Combo.))
norLG(c(list(Blank.), Combo.))
anyLG(c(list(Blank.), Combo.))
allLG(c(list(Blank.), Combo.))
oneLG(c(list(Blank.), Combo.))
twoLG(c(list(Blank.), Combo.))

isBL(c(list(Blank.), Combo.))
notBL(c(list(Blank.), Combo.))
norBL(c(list(Blank.), Combo.))
anyBL(c(list(Blank.), Combo.))
allBL(c(list(Blank.), Combo.))
oneBL(c(list(Blank.), Combo.))
twoBL(c(list(Blank.), Combo.))

uj::isNAS(ChrMat.)
notNAS(ChrMat.)
norNAS(ChrMat.)
anyNAS(ChrMat.)
allNAS(ChrMat.)
oneNAS(ChrMat.)
twoNAS(ChrMat.)

isOKS(ChrMat.)
notOKS(ChrMat.)
norOKS(ChrMat.)
anyOKS(ChrMat.)
allOKS(ChrMat.)
oneOKS(ChrMat.)
twoOKS(ChrMat.)
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{envir_vals}},
\code{\link{evals}},
\code{\link{failsafe_binaries}},
\code{\link{failsafe}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{n_is}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{stats0}},
\code{\link{swap}()}

Other failsafe: 
\code{\link{failsafe_binaries}},
\code{\link{failsafe}()}

Other logicals: 
\code{\link{evals}},
\code{\link{failsafe_binaries}},
\code{\link{meets}()}
}
\concept{extensions}
\concept{failsafe}
\concept{logicals}
