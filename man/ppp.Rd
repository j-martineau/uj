% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppp.R
\name{ppp}
\alias{ppp}
\alias{prop_vals}
\alias{prop_funs}
\alias{is_prop}
\alias{is_prop_fun}
\alias{is_prop_spec}
\alias{is_prop_combo}
\alias{props_from_spec}
\alias{combos_from_spec}
\alias{props_from_combo}
\alias{ippp}
\alias{nll_or}
\alias{nas_or}
\alias{prop_defs}
\alias{prop_verbose}
\alias{combo_concise}
\alias{spec_concise}
\title{All purpose property checking}
\usage{
ppp(x)

prop_vals(as.dtf = F)

prop_funs(as.dtf = F)

is_prop(prop)

is_prop_fun(fun)

is_prop_spec(spec)

is_prop_combo(combo)

props_from_spec(spec, valid = prop_vals())

combos_from_spec(spec, valid = prop_vals())

props_from_combo(combo, valid = prop_vals())

ippp(x, spec, ...)

nll_or(x, spec, ...)

nas_or(x, spec, ...)

prop_defs()

prop_verbose(prop, print = TRUE)

combo_concise(combo)

spec_concise(spec)
}
\arguments{
\item{x}{An R object.}

\item{as.dtf}{A non-\code{NA} logical scalar indicating whether to return the result as a data.frame with column \code{1} containing property values and column \code{2} containing the property families.}

\item{valid}{A \link[=cmp_chr_vec]{complete character vec} containing all properties considered valid.}

\item{...}{
  Arguments passed on to \code{\link[=meets]{meets}}
  \describe{
    \item{\code{}}{}
  }}

\item{print}{A non-\code{NA} logical scalar indicating whether to print the property definition to the console.}

\item{ppp}{A \link[=cmp_chr_scl]{complete character scalar} containing one or more values from \code{ppp_vals()} separated by pipes and/or underscores. Combinations of properties can be specified by separating them with underscores. Separating properties or combinations of properties with pipes will result in a value of \code{TRUE} if any of them applies to \code{x}.}
}
\value{
\tabular{rl}{
  \code{combos_from_spec}   \tab A character vector.
\cr \code{props_from_combo}   \tab   
\cr  \code{props_from_spec}   \tab   
\cr        \code{prop_funs}   \tab   
\cr        \code{prop_vals}   \tab   
\cr              \code{ppp}   \tab   
\cr                      \tab   
\cr   \code{is_valid_combo}   \tab A logical scalar.
\cr    \code{is_valid_spec}   \tab   
\cr    \code{is_valid_prop}   \tab   
\cr      \code{is_prop_fun}   \tab   
\cr           \code{nas_or}   \tab   
\cr           \code{nll_or}   \tab   
\cr             \code{ippp}   \tab   
\cr                      \tab   
\cr    \code{combo_concise}   \tab A character scalar.
\cr     \code{spec_concise}   \tab   
\cr     \code{prop_verbose}   \tab   
\cr                      \tab   
\cr        \code{prop_defs}   \tab A \link[=tb]{tibble}.
}
}
\description{
This set of functions provide utilities that bring together seven families of object properties defined by this package:
\tabular{rl}{
  \code{\link{bbb}}   \tab \code{basic}
\cr \code{\link{ccc}}   \tab \code{xclass}
\cr \code{\link{ddd}}   \tab \code{defined-D}
\cr \code{\link{eee}}   \tab \code{effective-D}
\cr \code{\link{iii}}   \tab \code{integrity}
\cr \code{\link{mmm}}   \tab \code{xmode}
\cr \code{\link{sss}}   \tab \code{shape}
}
\strong{single property specs} are character scalars containing exactly \code{3} characters (e.g., \verb{'ord', 'dtf', 'd1D', 'rct'}).
\cr\cr
\strong{Combination (conjunctive) property specs} are for properties that must co-occur. They are constructed by delimiting multiple single properties with underscores (e.g., \code{'ord_dtf_d1D_rct'} or an equivalent underscore-delimited permutation).
\cr\cr
\strong{Alternate (compensatory) property specs} are to indicate that if any one (single or combination) property spec is satisfied the entire spec is satisfied. They are constructed by pipe-delimiting multiple single or combination properties. For example, the spec \code{'ord|dtf_d1D||dtf_rct'} would be satisfied by an object with single property \code{'ord'}, combined property \code{'dtf_d1D'}, or combined property \code{'dtf_rct'}.
\cr\cr
\strong{Property and property spec manipulation functions}
\tabular{rl}{
  \code{combos_from_spec}   \tab Convert spec to constituent combos.
\cr \code{props_from_combo}   \tab Convert combo to constituent properties.
\cr  \code{props_from_spec}   \tab Convert spec to constituent properties.
}
\strong{Property and property spec validation functions}
\tabular{rl}{
  \code{is_prop_combo}   \tab Is \code{combo} a combo/conjunctive spec?
\cr \code{is_prop_spec}   \tab Is \code{spec} a property spec of any type?
\cr  \code{is_prop_fun}   \tab Is \code{fun} a property-function name?
\cr      \code{is_prop}   \tab Is \code{prop} a value from \code{prop_vals()}?
}
\strong{Comprehensive property and common property-specs}
\tabular{rl}{
  \code{prop_funs}   \tab Names of functions checking for specific single and combo properties matched to \code{x}.
}
\strong{Family-specific object property listing functions}
\tabular{rl}{
   \code{ppp}   \tab gets all single properties matching \code{x}.
\cr \code{bbb}   \tab    \code{base} properties
\cr \code{ccc}   \tab    \code{xclass} properties
\cr \code{ddd}   \tab    \code{defined-D} properties
\cr \code{eee}   \tab    \code{effective-D} properties
\cr \code{iii}   \tab    \code{integrity} properties
\cr \code{mmm}   \tab    \code{xmode} properties
\cr \code{sss}   \tab    \code{shape} properties
}
\strong{Property and property spec definition functions}
\tabular{rl}{
  \code{combo_concise}   \tab Concisely define a combo/conjunctive property.
\cr \code{spec_concise}   \tab Concisely define a property spec.
\cr \code{prop_verbose}   \tab Verbosely define a single property.
\cr    \code{prop_defs}   \tab Gets a table of property definitions.
}
\strong{Multi-family property spec matching functions}
\tabular{rl}{
  \code{nll_or}   \tab Is \code{x} either \code{NULL} or a match to \code{spec}?
\cr \code{nas_or}   \tab Is \code{x} either scalar \code{NA} or a match to \code{spec}?
\cr   \code{ippp}   \tab Is \code{x} a match to property spec \code{spec}?
}
\strong{Single-property  matching functions}
\tabular{rl}{
  \code{iPPP}   \tab does \code{x} match single property \code{'PPP'}.
}
\strong{Single-family, single-property matching functions}
\tabular{rl}{
  \code{ibbb}   \tab Does \code{x} match \code{base} property spec \code{spec}?
\cr \code{iccc}   \tab    \code{xclass}
\cr \code{iddd}   \tab    \code{defined-D}
\cr \code{ieee}   \tab    \code{effective-D}
\cr \code{iiii}   \tab    \code{integrity}
\cr \code{immm}   \tab    \code{xmode}
\cr \code{isss}   \tab    \code{shape}
}
\strong{Functions testing for combination/conjunctive properties}
\tabular{rl}{
  \code{cmp_MMM_CCC}   \tab Complete\verb{ + xmode 'MMM' + xclass 'CCC'}.
\cr   \code{cmp_MMM}   \tab Complete\verb{ + xmode 'MMM'}.
\cr   \code{cmp_CCC}   \tab Complete\verb{ + xclass 'CCC'}
\cr   \code{BBB_CCC}   \tab \code{Base} property\verb{ 'BBB' + xclass 'CCC'}.
\cr   \code{BBB_MMM}   \tab \code{Base} property\verb{ 'BBB' + xmode 'MMM'}.
\cr   \code{MMM_CCC}   \tab \verb{xmode 'MMM' + xclass 'CCC'}.
}
\strong{Comprehensive lists of single and common combination properties}
\tabular{rl}{
  \code{cmp_mmm_ccc_props}   \tab Complete\verb{ emode + xclass }properties.
\cr                     \tab   
\cr   \code{cmp_ccc_props}   \tab Complete\code{+ xclass }properties.
\cr   \code{cmp_mmm_props}   \tab Complete\code{+ xmode }properties.
\cr   \code{bbb_ccc_props}   \tab \code{Basic + xclass }properties.
\cr   \code{bbb_mmm_props}   \tab \code{Basic + xmode }properties.
\cr   \code{mmm_ccc_props}   \tab \code{xmode + xclass }properties.
\cr                     \tab   
\cr       \code{bbb_props}   \tab Single\code{basic}properties.
\cr       \code{ccc_props}   \tab Single\code{xclass}properties.
\cr       \code{ddd_props}   \tab Single\code{defined-D}properties.
\cr       \code{eee_props}   \tab single\code{effective-D}properties.
\cr       \code{iii_props}   \tab single\code{ integrity} properties.
\cr       \code{mmm_props}   \tab single\code{ xmode} properties.
\cr       \code{sss_props}   \tab single\code{ shape} properties.
\cr                     \tab   
\cr       \code{prop_vals}   \tab All possible single properties.
}
}
\section{Specifying count and value restrictions}{
 Specifying restrictions in \code{...} is optional. The full set of recognized arguments names are defined in the following table along with the properties each specifies:
\tabular{rl}{
  \verb{max, maxr, maxc}   \tab Scalar maximum valid numbers of element, rows, and columns, respectively.
\cr                     \tab   
\cr \verb{min, minr, minc}   \tab Scalar minimum valid numbers of element, rows, and columns, respectively.
\cr                     \tab   
\cr  \verb{lt, le, ge, gt}   \tab Scalar less-than, less-than-or-equal, greater-than-or-equal, and greater-than bounds, respectively.
\cr                     \tab   
\cr       \verb{n, nr, nc}   \tab A vector of valid numbers of elements, rows, and columns, respectively.
\cr                     \tab   
\cr            \code{vals}   \tab A vector of valid values.
}
}

\examples{
prop_vals()
prop_funs()
prop_verbose("srt")
prop_verbose("nnw")
combo_concise("cmp_psw_vls")
spec_concise("nll|cmp_psw_vls|ch1_scl")
props_from_spec("nll|cmp_psw_vls|ch1_scl")
combos_from_spec("nll|cmp_psw_vls|ch1_scl")
props_from_combo("cmp_psw_vls")
nll_or("1", "ch1")
nll_or(NULL, "ch1")
nll_or(7, "ch1")
nas_or(NA, "ch1")
nas_or("5", "ch1")
ippp("7", "nll|cmp_psw_vls|ch1_scl")
ippp(NULL, "nll|cmp_psw_vls|ch1_scl")
ippp("35", "nll|cmp_psw_vls|ch1_scl")
is_prop_combo("letter")
is_prop_combo("cmp_psw_vls")
is_prop_spec("nll|cmp_psw_vls|ch1_scl")
is_prop_fun("18")
is_prop_fun("cmp_psw_vls")
is_prop("18")
is_prop("vls")
ppp(letters)
prop_defs()
}
\seealso{
Other props: 
\code{\link{as_mmm}},
\code{\link{bbb_ccc}()},
\code{\link{bbb_mmm}()},
\code{\link{bbb}()},
\code{\link{ccc}()},
\code{\link{cmp_ccc}()},
\code{\link{cmp_mmm_ccc}()},
\code{\link{cmp_mmm}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{ddd}()},
\code{\link{eee}()},
\code{\link{iii}()},
\code{\link{meets}()},
\code{\link{mmm_ccc}()},
\code{\link{mmm}()},
\code{\link{sss}()}
}
\concept{props}
