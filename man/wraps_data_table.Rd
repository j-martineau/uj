% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wraps_data_table.R
\name{wraps_data_table}
\alias{wraps_data_table}
\alias{dtas}
\alias{dtis}
\alias{dtie}
\alias{dtsub}
\alias{dtcols}
\alias{dtmerge}
\alias{dtrows}
\alias{dtwide}
\title{Wraps of Functions from Package \code{data.table}}
\usage{
dtas(x, say = TRUE)

dtis(x)

dtie(x, say = TRUE)

dtsub(x, ir, ic)

dtcols(x, ic)

dtmerge(
  x,
  y,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  all = FALSE,
  all.x = all,
  all.y = all,
  sort = TRUE,
  suffixes = c(".x", ".y"),
  no.dups = TRUE,
  allow.cartesian = getOption("datatable.allow.cartesian"),
  say = TRUE
)

dtrows(x, ir)

dtwide(
  data,
  formula,
  fun.aggregate = NULL,
  sep = "_",
  ...,
  margins = NULL,
  subset = NULL,
  fill = NULL,
  drop = TRUE,
  value.var = data.table:::guess(data),
  verbose = getOption("datatable.verbose"),
  say = TRUE
)
}
\arguments{
\item{x}{An R object (\code{dtas}, \code{dtis}, and \code{dtie}). A
\code{\link[data.table]{data.table}} for all other functions.}

\item{say}{Non-\code{NA} logical scalar indicating whether to notify user of
starting a potentially time-consuming process (i.e., converting to
data.table, joining two large data.tables, and reshaping from long to
wide).}

\item{ir, ic}{\link[=cmp_ind_vec]{Complete indexer vecs} or
\link[=cmp_chr_vec]{complete character vecs} identifying rows and columns
of \code{x}, respectively.}

\item{by}{A vector of shared column names in \code{x} and \code{y} to merge on.
This defaults to the shared key columns between the two tables.
If \code{y} has no key columns, this defaults to the key of \code{x}.}

\item{by.x, by.y}{Vectors of column names in \code{x} and \code{y} to merge on.}

\item{all}{logical; \code{all = TRUE} is shorthand to save setting both
\code{all.x = TRUE} and \code{all.y = TRUE}.}

\item{all.x}{logical; if \code{TRUE}, then extra rows will be added to the
output, one for each row in \code{x} that has no matching row in \code{y}.
These rows will have 'NA's in those columns that are usually filled with values
from \code{y}.  The default is \code{FALSE}, so that only rows with data from both
\code{x} and \code{y} are included in the output.}

\item{all.y}{logical; analogous to \code{all.x} above.}

\item{sort}{logical. If \code{TRUE} (default), the merged \code{data.table} is
sorted by setting the key to the \code{by / by.x} columns. If \code{FALSE}, the
result is not sorted.}

\item{suffixes}{A \code{character(2)} specifying the suffixes to be used for
making non-\code{by} column names unique. The suffix behaviour works in a similar
fashion as the \code{\link{merge.data.frame}} method does.}

\item{no.dups}{logical indicating that \code{suffixes} are also appended to
non-\code{by.y} column names in \code{y} when they have the same column name
as any \code{by.x}.}

\item{allow.cartesian}{See \code{allow.cartesian} in \code{\link[data.table]{[.data.table}}.}

\item{data}{ A \code{data.table}.}

\item{formula}{A formula of the form LHS ~ RHS to cast, see Details.}

\item{fun.aggregate}{Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to \code{length} with a message.

  To use multiple aggregation functions, pass a \code{list}; see Examples. }

\item{sep}{Character vector of length 1, indicating the separating character in variable names generated during casting. Default is \code{_} for backwards compatibility. }

\item{...}{Additional arguments to be passed to or from other methods.}

\item{margins}{Not implemented yet. Should take variable names to compute margins on. A value of \code{TRUE} would compute all margins.}

\item{subset}{Specified if casting should be done on a subset of the data. Ex: \code{subset = .(col1 <= 5)} or \code{subset = .(variable != "January")}.}

\item{fill}{Value with which to fill missing cells. If \code{fun.aggregate} is present, takes the value by applying the function on a 0-length vector.}

\item{drop}{\code{FALSE} will cast by including all missing combinations.

  \code{c(FALSE, TRUE)} will only include all missing combinations of formula \code{LHS}; \code{c(TRUE, FALSE)} will only include all missing combinations of formula RHS. See Examples.}

\item{value.var}{Name of the column whose values will be filled to cast. Function \code{guess()} tries to, well, guess this column automatically, if none is provided.

  Cast multiple \code{value.var} columns simultaneously by passing their names as a \code{character} vector. See Examples. }

\item{verbose}{Not used yet. May be dropped in the future or used to provide informative messages through the console.}
}
\value{
A \code{\link[data.table]{data.table}}.
}
\description{
The following table describes thin wraps in this group of
functions:\tabular{ll}{
WRAPPER     \tab FUNCTION                                             \cr
\code{dtas}      \tab \code{\link[data.table]{as.data.table}}              \cr
\code{dtis}      \tab \code{\link[data.table]{is.data.table}}              \cr
\code{dtmerge}   \tab \code{\link[data.table]{merge}}                      \cr
\code{dtwide}    \tab \code{\link[data.table]{dcast}}                        }
Functionality is stripped down significantly for these wraps.
\cr\cr
There are a few additional wrappers that combine multiple \code{data.table}
operations or that address extraction of data from a data.table without
using the non-standard \code{data.table} indexing functions. The are
described in the table below.
\tabular{ll}{
WRAPPER    \tab FUNCTIONALITY                                         \cr
\code{dtie}     \tab If \code{x} is already a data table, return it as is,
otherwise, convert it to a data.table.                \cr
\code{dtcols}   \tab Select columns from a data.table without non-standard
data.table indexing functions (i.e., \code{x[ , ..var]}).  \cr
\code{dtrows}   \tab Select rows from a data.table with similar syntax as
\code{dtcols} (not strictly necessary as there is no special
data.table syntax for extracting rows).               \cr
\code{dtsub}    \tab Select a sub-table from a data.table without using
non-standard data.table indexing functions (i.e.,
\code{x[row.var, ..col.var]}).                               }
}
\details{
\code{as.data.table} is a generic function with many methods, and other packages can supply further methods.

  If a \code{list} is supplied, each element is converted to a column in the \code{data.table} with shorter elements recycled automatically. Similarly, each column of a \code{matrix} is converted separately.

  \code{character} objects are \emph{not} converted to \code{factor} types unlike \code{as.data.frame}.

  If a \code{data.frame} is supplied, all classes preceding \code{"data.frame"} are stripped. Similarly, for \code{data.table} as input, all classes preceding \code{"data.table"} are stripped. \code{as.data.table} methods returns a \emph{copy} of original data. To modify by reference see \code{\link[data.table]{setDT}} and \code{\link[data.table]{setDF}}.

  \code{keep.rownames} argument can be used to preserve the (row)names attribute in the resulting \code{data.table}.
}
\examples{
nn = c(a=0.1, b=0.2, c=0.3, d=0.4)
as.data.table(nn)
as.data.table(nn, keep.rownames=TRUE)
as.data.table(nn, keep.rownames="rownames")

# char object not converted to factor
cc = c(X="a", Y="b", Z="c")
as.data.table(cc)
as.data.table(cc, keep.rownames=TRUE)
as.data.table(cc, keep.rownames="rownames")

mm = matrix(1:4, ncol=2, dimnames=list(c("r1", "r2"), c("c1", "c2")))
as.data.table(mm)
as.data.table(mm, keep.rownames=TRUE)
as.data.table(mm, keep.rownames="rownames")
as.data.table(mm, key="c1")

ll = list(a=1:2, b=3:4)
as.data.table(ll)
as.data.table(ll, keep.rownames=TRUE)
as.data.table(ll, keep.rownames="rownames")

DF = data.frame(x=rep(c("x","y","z"),each=2), y=c(1,3,6), row.names=LETTERS[1:6])
as.data.table(DF)
as.data.table(DF, keep.rownames=TRUE)
as.data.table(DF, keep.rownames="rownames")

DT = data.table(x=rep(c("x","y","z"),each=2), y=c(1:6))
as.data.table(DT)
as.data.table(DT, key='x')

ar = rnorm(27)
ar[sample(27, 15)] = NA
dim(ar) = c(3L,3L,3L)
as.data.table(ar)
}
\seealso{
Other wraps: 
\code{\link{wraps_base}},
\code{\link{wraps_dplyr}},
\code{\link{wraps_gg}},
\code{\link{wraps_readr}},
\code{\link{wraps_scales}},
\code{\link{wraps_tibble}}
}
\concept{wraps}
