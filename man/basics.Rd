% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basics..R
\name{basics}
\alias{basics}
\alias{u}
\alias{dn}
\alias{up}
\alias{len}
\alias{mid}
\alias{spf}
\alias{levs}
\title{Thin wrappers for \code{base} functions}
\usage{
u(x)

dn(x)

up(x)

len(x, type = "chars", allowNA = FALSE, keepNA = NA)

mid(x, start, stop)

spf(fmt, ...)

levs(x)
}
\arguments{
\item{x}{a vector or a data frame or an array or \code{NULL}.}

\item{type}{character string: partial matching to one of
    \code{c("bytes", "chars", "width")}.  See \sQuote{Details}.}

\item{allowNA}{logical: should \code{NA} be returned for invalid
    multibyte strings or \code{"bytes"}-encoded strings (rather than
    throwing an error)?}

\item{keepNA}{logical: should \code{NA} be returned when
  \code{x} is \code{\link[base]{NA}}?  If false, \code{nchar()} returns
  \code{2}, as that is the number of printing characters used when
  strings are written to output, and \code{nzchar()} is \code{TRUE}.  The
  default for \code{nchar()}, \code{NA}, means to use \code{keepNA = TRUE}
  unless \code{type} is \code{"width"}.}

\item{fmt}{a character vector of format strings, each of up to 8192 bytes.}

\item{...}{arguments for particular methods.}
}
\value{
For a vector, an object of the same type of \code{x}, but with only
  one copy of each duplicated element.  No attributes are copied (so
  the result has no names).

  For a data frame, a data frame is returned with the same columns but
  possibly fewer rows (and with row names from the first occurrences of
  the unique rows).

  A matrix or array is subsetted by \code{[, drop = FALSE]}, so
  dimensions and dimnames are copied appropriately, and the result
  always has the same number of dimensions as \code{x}.
}
\description{
\tabular{rl}{
\code{levs}   \tab Thinly wraps \code{\link[base]{levels}}.
\cr \code{spf}   \tab Thinly wraps \code{\link[base]{sprintf}}.
\cr \code{mid}   \tab Thinly wraps \code{\link[base]{substr}}.
\cr \code{len}   \tab Thinly wraps \code{\link[base]{nchar}}.
\cr  \code{up}   \tab Thinly wraps \code{\link[base]{ceiling}}.
\cr  \code{dn}   \tab Thinly wraps \code{\link[base]{floor}}.
\cr   \code{u}   \tab Thinly wraps \code{\link[base]{unique}}\eqn{^1}.
}
    \eqn{^1} Differs from \code{\link{uv}} because \code{uv} calls \code{unique(av(...))}.
}
\details{
This is a generic function with methods for vectors, data frames and
  arrays (including matrices).

  The array method calculates for each element of the dimension
  specified by \code{MARGIN} if the remaining dimensions are identical
  to those for an earlier element (in row-major order).  This would most
  commonly be used for matrices to find unique rows (the default) or columns
  (with \code{MARGIN = 2}).

  Note that unlike the Unix command \code{uniq} this omits
  \emph{duplicated} and not just \emph{repeated} elements/rows.  That
  is, an element is omitted if it is equal to any previous element and
  not just if it is equal the immediately previous one.  (For the
  latter, see \code{\link[base]{rle}}).

  Missing values (\code{"\link[base]{NA}"}) are regarded as equal, numeric and
  complex ones differing from \code{NaN}; character strings will be compared in a
  \dQuote{common encoding}; for details, see \code{\link[base]{match}} (and
  \code{\link[base]{duplicated}}) which use the same concept.

  Values in \code{incomparables} will never be marked as duplicated.
  This is intended to be used for a fairly small set of values and will
  not be efficient for a very large set.

  When used on a data frame with more than one column, or an array or
  matrix when comparing dimensions of length greater than one, this
  tests for identity of character representations.  This will
  catch people who unwisely rely on exact equality of floating-point
  numbers!
}
\note{
This does \strong{not} by default give the number of characters that
  will be used to \code{print()} the string.  Use
  \code{\link[base]{encodeString}} to find that.
#ifdef windows not active  Where character strings have been marked as UTF-8, the number of
  characters and widths will be computed in UTF-8, even though printing
  may use escapes such as \samp{<U+2642>} in a non-UTF-8 locale.

  The concept of \sQuote{width} is a slippery one even in a monospaced
  font. Some human languages have the concept of \emph{combining}
  characters, in which two or more characters are rendered together: an
  example would be \code{"y\u306"}, which is two characters of width
  one: combining characters are given width zero, and there are other
  zero-width characters such as the zero-width space \code{"\u200b"}.

  Some East Asian languages have \sQuote{wide} characters, ideographs
  which are conventionally printed across two columns when mixed with
  ASCII and other \sQuote{narrow} characters in those languages.  The
  problem is that whether a computer prints wide characters over two or
  one columns depends on the font, with it not being uncommon to use two
  columns in a font intended for East Asian users and a single column in
  a \sQuote{Western} font.  Unicode has encodings for \sQuote{fullwidth}
  versions of ASCII characters and \sQuote{halfwidth} versions of
  Katakana (Japanese) and Hangul (Korean) characters.  Then there is the
  \sQuote{East Asian Ambiguous class} (Greek, Cyrillic, signs, some
  accented Latin chars, etc), for which the historical practice was to
  use two columns in East Asia and one elsewhere.  The width quoted by
  \code{nchar} for characters in that class (and some others) depends on
  the locale, being one except in some East Asian locales on some OSes
  (notably Windows).

  Control characters are usually given width zero: this includes CR and
  LF.  Computing the width of a string containing control characters
  should be avoided (and may depend on the OS and \R version).
}
\section{Warning}{

  Using this for lists is potentially slow, especially if the elements
  are not atomic vectors (see \code{\link[base]{vector}}) or differ only
  in their attributes.  In the worst case it is \eqn{O(n^2)}.



  The realities of computer arithmetic can cause unexpected results,
  especially with \code{floor} and \code{ceiling}.  For example, we
  \sQuote{know} that \code{floor(log(x, base = 8))} for \code{x = 8} is
  \code{1}, but \code{0} has been seen on an \R platform.  It is
  normally necessary to use a tolerance.

  Rounding to decimal digits in binary arithmetic is non-trivial (when
  \code{digits != 0}) and may be surprising.  Be aware that most decimal
  fractions are \emph{not} exactly representable in binary double precision.
  In \R 4.0.0, the algorithm for \code{round(x, d)}, for \eqn{d > 0}, has
  been improved to \emph{measure} and round \dQuote{to nearest even},
  contrary to earlier versions of \R (or also to \code{\link[base]{sprintf}()}
  or \code{\link[base]{format}()} based rounding).



  The realities of computer arithmetic can cause unexpected results,
  especially with \code{floor} and \code{ceiling}.  For example, we
  \sQuote{know} that \code{floor(log(x, base = 8))} for \code{x = 8} is
  \code{1}, but \code{0} has been seen on an \R platform.  It is
  normally necessary to use a tolerance.

  Rounding to decimal digits in binary arithmetic is non-trivial (when
  \code{digits != 0}) and may be surprising.  Be aware that most decimal
  fractions are \emph{not} exactly representable in binary double precision.
  In \R 4.0.0, the algorithm for \code{round(x, d)}, for \eqn{d > 0}, has
  been improved to \emph{measure} and round \dQuote{to nearest even},
  contrary to earlier versions of \R (or also to \code{\link[base]{sprintf}()}
  or \code{\link[base]{format}()} based rounding).



  The format string is passed down the OS's \code{sprintf} function, and
  incorrect formats can cause the latter to crash the \R process .  \R
  does perform sanity checks on the format, but not all possible user
  errors on all platforms have been tested, and some might be terminal.

  The behaviour on inputs not documented here is \sQuote{undefined},
  which means it is allowed to differ by platform.

}

\section{S4 methods}{

  These are all (internally) S4 generic.

  \code{ceiling}, \code{floor} and \code{trunc} are members of the
  \code{\link[=S4groupGeneric]{Math}} group generic.  As an S4
  generic, \code{trunc} has only one argument.

  \code{round} and \code{signif} are members of the
  \code{\link[=S4groupGeneric]{Math2}} group generic.



  These are all (internally) S4 generic.

  \code{ceiling}, \code{floor} and \code{trunc} are members of the
  \code{\link[=S4groupGeneric]{Math}} group generic.  As an S4
  generic, \code{trunc} has only one argument.

  \code{round} and \code{signif} are members of the
  \code{\link[=S4groupGeneric]{Math2}} group generic.

}

\examples{
vals <- c(1:3, 2:4) / 3
vars <- c("a", "bb", "ccc", "dddd", "ccc", "bb")
text <- "\%s = \%0.2f and \%s = \%0.0f"

vals
vars
text

u(vals)
u(vars)
u(data.frame(var = vars, val = vals))

dn(vals)
up(vals)

len(vars)
mid(vars, 1, 3)

spf(text, vars[1:3], vals[1:3], vars[4:6], vals[4:6])
}
\references{
Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
  \emph{The New S Language}.
  Wadsworth & Brooks/Cole.
}
\seealso{
Other wraps: 
\code{\link{dp}},
\code{\link{dt}()},
\code{\link{ggp}()},
\code{\link{gr}},
\code{\link{rd}},
\code{\link{sca}()},
\code{\link{tb}()}
}
\author{
Original code by Jonathan Rougier.
}
\concept{wraps}
