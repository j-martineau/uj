% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fork.R
\encoding{UTF-8}
\name{fork}
\alias{fork}
\alias{f0}
\alias{f1}
\alias{nll_if}
\alias{nll_ifs}
\alias{nll_if_any}
\alias{nll_if_all}
\alias{nll_if_none}
\title{Enhancements of \code{\link[base]{ifelse}}.}
\usage{
f0(x, y, n)

fork(x, y, n, na = n)

f1(x, y, n, na = n, err = n)

nll_if(x, ..., .d = " ")

nll_ifs(..., .d = " ")

nll_if_any(..., .d = " ")

nll_if_all(..., .d = " ")

nll_if_none(..., .d = " ")

nll_ifs(..., .d = " ")
}
\arguments{
\item{x}{A logical scalar (if not,\code{x} it is replaced by \code{FALSE}).}

\item{y, n}{Any valid R object.}

\item{na}{An object of any type for \code{f1}. An atomic scalar \link[=compatible]{compatible} with \code{y} and \code{n} for \code{fork}, with the additional possibility of \code{na = 'err'} to indicate an error should be thrown if any values in \code{x} are \code{NA}.}

\item{err}{Either \code{'err'} or an object to be returned when \code{x} is not an atomic scalar in \code{c(TRUE, FALSE, NA)}.}

\item{.d}{A character scalar delimiter for collapsing objects into scalar character objects. If \code{.d} is not a character scalar, it is replaced by \code{" "}.}

\item{.cond}{A character scalar in \code{c('all', 'any', 'none')}. If \code{.cond} is not of an allowed value, it is replaced by \code{'all'}.}
}
\value{
\strong{A length-}\code{length(x)} \strong{atomic object}      \cr\cr \code{fork}
\cr\cr  \strong{An arbitrary object}                         \cr\cr \verb{f0, f1}
\cr\cr  \strong{A character scalar or the} \code{NULL} \strong{object} \cr\cr \verb{nll_if, nll_ifs, nll_if_all} \cr \verb{nll_if_any, nll_if_none}
}
\description{
Return different types of objects for \code{TRUE} and \code{FALSE} and return \code{NULL}  conditional on the number of \code{TRUE} values.
}
\details{
\strong{\code{fork}}
\cr\cr Evaluates logical scalar or logical vector \code{x} and return an object of the same length as \code{x} where:
\itemize{\item \code{TRUE} values of \code{x} are replaced by corresponding values of \code{y}.
\item \code{FALSE} values of \code{x} are replaced by corresponding values of \code{n}.
\item \code{NA} values of \code{x} are replaced by \code{na} (unless \code{na = 'err'}, in which case if there are any \code{NA} values in \code{x}, throws an error). }
\cr\cr \strong{\code{f0}}
\cr\cr If \code{x} is scalar \code{TRUE}, returns \code{y}. If \code{x} is anything else, returns \code{n}.
\cr\cr \strong{\code{f1}}
\cr\cr Error-checked version of \code{f0}. Evaluates and processes logical scalar \code{x} in the following manner:
\itemize{\item If \code{x = TRUE}, returns \code{y}.
\item If \code{x = FALSE}, returns \code{y}.
\item If \code{x = NA}, returns \code{na} unless \code{na = 'err'}, in which case, an error is thrown.
\item If \code{x} is neither a logical scalar nor scalar \code{NA}, returns \code{err} unless \code{err = 'err'}, in which case an error is thrown. }
\cr\cr \strong{Functions beginning with \code{nll_if}}
\cr\cr These functions are useful for compiling error messages. They thus return \code{NULL} if error checks are passed and a message if they are not.
\cr\cr \strong{\code{nll_if}}
\cr\cr If \code{x} is scalar \code{TRUE}, returns \code{NULL}, otherwise collapses \code{...} args to a character scalar using delimiter \code{.d} and returns the result.
\cr\cr \strong{\verb{nll_if_<cond.>}}
\cr\cr These functions take both named and unnamed \code{...} args. Named \code{...} args other than \code{.d} are evaluated for \code{TRUE}-ness (any value that is not scalar \code{TRUE} is considered \code{FALSE}). Unnamed \code{...} args are \link[=glue_dots]{collapsed} into a character scalar value named \code{.d} using the delimiter in arg \code{.d}
\tabular{ll}{  \code{nll_if_none}   \tab Returns \code{.d} upon encountering a \code{TRUE} named \code{...} arg. Returns \code{NULL} if none is encountered. \cr   \tab   \cr
  \code{nll_if_any}    \tab Returns \code{NULL} upon encountering a \code{TRUE} named \code{...} arg. Returns \code{.d} if none is encountered. \cr   \tab   \cr
  \code{nll_if_all}    \tab Returns \code{.d} upon encountering a non-\code{TRUE} named \code{...} arg. Returns \code{NULL} if none is encountered.            }
\cr\cr \strong{\code{nll_ifs}}
\cr\cr Calls \code{nll_if_none(..., .d = .d)} when \code{.cond = 'none'}. Calls \code{nll_if_any(..., .d = .d)} when \verb{.cond = 'any}. Calls \code{nll_if_all(..., .d = .d)} when \code{.cond} takes any other value (including \code{'all'})
\cr\cr \strong{\code{nlls_ifs}}
\cr\cr Conditionally compiles messages into a character vector. Each non-\code{TRUE} odd-numbered \code{...} arg's message (\link[=glue_dots]{collapsed} from the following \code{...} arg) is added to the compilation. If all odd-numbered \code{...} args are \code{TRUE}, returns \code{NULL}.
}
\examples{
fork(c(TRUE, FALSE, TRUE, NA), 1, 2)
fork(c(TRUE, FALSE, TRUE, NA), 1, 2, na = 0)
fork(c(TRUE, FALSE, TRUE, NA), 1, 2, na = NA)
fork(c(TRUE, FALSE, TRUE, NA), 1:4, 5:8)

f0(NA, data.frame(letters = letters), 0:26)
f0(TRUE, data.frame(letters = letters), 0:26)
f0(FALSE, data.frame(letters = letters), 0:26)
f0(list(1, "a"), data.frame(letters = letters), 0:26)
f0(c(.bad.varname.), data.frame(letters = letters), 0:26)

f1(NA, data.frame(letters = letters), 0:26)
f1(NA, data.frame(letters = letters), 0:26, na = NA)
f1(TRUE, data.frame(letters = letters), 0:26)
f1(FALSE, data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26)
f1(c(.bad.varname.), data.frame(letters = letters), 0:26)
f1(list(1, "a"), data.frame(letters = letters), 0:26, err = "error")
f1(c(.bad.varname.), data.frame(letters = letters), 0:26, err = "error")

nll_if(TRUE, "an error", "message")
nll_if(FALSE, "an error", "message")
nll_if(41, "an error", "message")

nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "any", .cond = "all")
nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "all", .cond = "any")
nll_ifs(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "none", .cond = "none")
nll_if_any(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "any")
nll_if_all(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "all")
nll_if_none(t1 = TRUE, t2 = FALSE, t3 = FALSE, "not", "none")
}
\seealso{
Other extensions: 
\code{\link{N}()},
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{failsafe}()},
\code{\link{flex_rbind}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}()},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}

Other forks: 
\code{\link{case}()},
\code{\link{swap}()}
}
\concept{extensions}
\concept{forks}
