% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pgrid.R
\encoding{UTF-8}
\name{pgrid}
\alias{pgrid}
\alias{pgrid0}
\alias{pgrid1}
\alias{pgridn}
\alias{pgridx}
\title{\code{expand.grid} for \code{paste} and \code{paste0}}
\usage{
pgrid(p, ..., ch = F, crossed = F, na.err = T)

pgrid0(..., ch = F, crossed = F, na.err = T)

pgrid1(..., ch = F, crossed = F, na.err = T)

pgridn(p, ..., ch = F, na.err = T)

pgridx(p, ..., ch = F, na.err = T)
}
\arguments{
\item{p}{A \link[=cmp_chr_scl]{complete character scalar} to use as the 'paste'.}

\item{...}{Non-empty atomic objects.}

\item{ch, na.err}{Non-\code{NA} logical scalars indicating, respectively, whether to split each \code{...} arguments into its constituent characters after conversion to mode 'character' and whether to throw an error if an argument in \code{...} contains an \code{NA} value.}

\item{crossed}{A non-\code{NA} logical scalar indicating whether to construct the result to look like a fully-crossed model. See the section entitled \emph{the} \code{crossed} \emph{argument} section for details.}
}
\value{
A character vector.
}
\description{
\tabular{rl}{
  \code{pgrid}   \tab Converts the \code{n} \code{...} arguments to character (with additional optional pre-processing) and create a character vector with each element consisting of sub-strings from across \code{...} arguments pasted together using the 'paste' \code{p}. See the \emph{value} section for how the value of \code{crossed} affects the return value.
\cr            \tab  
\cr \code{pgrid0}   \tab Calls \code{pgrid} with \code{p = ""} (blank).
\cr \code{pgrid1}   \tab Calls \code{pgrid} with \verb{p = " "} (space).
\cr \code{pgridn}   \tab Calls \code{pgrid} with \verb{crossed = FALSE}\eqn{^a}.
\cr \code{pgridx}   \tab Calls \code{pgrid} with \code{crossed = TRUE}\eqn{^a}.
}
\eqn{^{a.}} See \emph{the} \code{crossed} \emph{argument} section.
}
\section{The \code{crossed} Argument}{
 The following console excerpt shows the effect of the value of \code{crossed}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{> x <- c("A", "B", "C")
> y <- c(1, 2)
> z <- c("a", "b")
> p <- "."
> list(n = sort(pgrid(p, x, y, z, crossed = FALSE)),
       y = sort(pgrid(p, x, y, z, crossed = TRUE )))
$n
[1] "A.1.a" "A.1.b" "A.2.a" "A.2.b" "B.1.a" "B.1.b"
[7] "B.2.a" "B.2.b" "C.1.a" "C.1.b" "C.2.a" "C.2.b"

$y
 [1] "1"     "1.a"   "1.b"   "2"     "2.a"   "2.b"
 [7] "a"     "A"     "A.1"   "A.1.a" "A.1.b" "A.2"
[13] "A.2.a" "A.2.b" "A.a"   "A.b"   "b"     "B"
[19] "B.1"   "B.1.a" "B.1.b" "B.2"   "B.2.a" "B.2.b"
[25] "B.a"   "B.b"   "C"     "C.1"   "C.1.a" "C.1.b"
[31] "C.2"   "C.2.a" "C.2.b" "C.a"   "C.b"
}\if{html}{\out{</div>}}
}

\examples{
x <- c("A", "B", "C")
y <- c(1, 2)
z <- c("a", "b")
pgrid(".", x, y, z, crossed = F)
pgrid(".", x, y, z, crossed = T)
pgridn(".", x, y, y)
pgridx(".", x, y, z)
pgrid0(x, y, z)
pgrid1(x, y, z)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{makestr}},
\code{\link{markdown}},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
