% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/failsafe.R
\encoding{UTF-8}
\name{failsafe}
\alias{failsafe}
\alias{isERR}
\alias{notERR}
\alias{msgERR}
\alias{makeERR}
\alias{fsDEF}
\alias{fsSCL}
\alias{fsVEC}
\alias{fsNULL}
\alias{sclBL}
\alias{sclT}
\alias{sclF}
\alias{sclTF}
\alias{sclLG}
\alias{sclNA}
\alias{vecBL}
\alias{vecT}
\alias{vecF}
\alias{vecTF}
\alias{vecNA}
\alias{fsOR}
\alias{orF}
\alias{orT}
\alias{orBL}
\alias{orC0}
\alias{orI0}
\alias{orL0}
\alias{orN0}
\alias{orNA}
\alias{orNAC}
\alias{orNAI}
\alias{orNAL}
\alias{orNAR}
\alias{orNULL}
\alias{IS}
\alias{ISNT}
\alias{isIN1}
\alias{isMF1}
\alias{HAS1}
\alias{LACKS1}
\alias{isEQ1}
\alias{isGE1}
\alias{isGT1}
\alias{isLE1}
\alias{isLT1}
\alias{isDIF1}
\alias{isF1}
\alias{isT1}
\alias{isBL1}
\alias{isTF1}
\alias{isNA1}
\alias{isOK1}
\alias{isLG1}
\alias{isIN}
\alias{isMF}
\alias{HAS}
\alias{LACKS}
\alias{isEQ}
\alias{isGE}
\alias{isGT}
\alias{isLE}
\alias{isLT}
\alias{isDIF}
\alias{isF}
\alias{isT}
\alias{isBL}
\alias{isTF}
\alias{isNAS}
\alias{isOKS}
\alias{isSEQ}
\alias{isVEQ}
\alias{isSDIF}
\alias{isVDIF}
\alias{or1}
\alias{and1}
\alias{xor1}
\alias{nor1}
\alias{OR}
\alias{AND}
\alias{XOR}
\alias{NOR}
\alias{notIN1}
\alias{notMF1}
\alias{notHAS1}
\alias{notLACKS1}
\alias{notEQ1}
\alias{notGE1}
\alias{notGT1}
\alias{notLE1}
\alias{notLT1}
\alias{notDIF1}
\alias{notF1}
\alias{notT1}
\alias{notTF1}
\alias{notBL1}
\alias{notNA1}
\alias{notOK1}
\alias{notLG1}
\alias{notIN}
\alias{notMF}
\alias{notHAS}
\alias{notLACKS}
\alias{notEQ}
\alias{notGE}
\alias{notGT}
\alias{notLE}
\alias{notLT}
\alias{notDIF}
\alias{notF}
\alias{notT}
\alias{notTF}
\alias{notBL}
\alias{notNAS}
\alias{notOKS}
\alias{notSEQ}
\alias{notVEQ}
\alias{notSDIF}
\alias{notVDIF}
\alias{nIN}
\alias{nMF}
\alias{nHAS}
\alias{nLACKS}
\alias{nEQ}
\alias{nGE}
\alias{nGT}
\alias{nLE}
\alias{nLT}
\alias{nDIF}
\alias{nF}
\alias{nT}
\alias{nTF}
\alias{nBL}
\alias{nNAS}
\alias{nOKS}
\alias{noneF}
\alias{noneT}
\alias{noneTF}
\alias{noneBL}
\alias{noneEQ}
\alias{noneGE}
\alias{noneGT}
\alias{noneLE}
\alias{noneLT}
\alias{noneIN}
\alias{noneMF}
\alias{noneDIF}
\alias{noneNAS}
\alias{noneOKS}
\alias{hasNONE}
\alias{lacksNONE}
\alias{anyF}
\alias{anyT}
\alias{anyBL}
\alias{anyEQ}
\alias{anyGE}
\alias{anyGT}
\alias{anyIN}
\alias{anyLE}
\alias{anyLT}
\alias{anyMF}
\alias{anyTF}
\alias{anyDIF}
\alias{anyNAS}
\alias{anyOKS}
\alias{hasANY}
\alias{lacksANY}
\alias{oneF}
\alias{oneT}
\alias{oneBL}
\alias{oneEQ}
\alias{oneGE}
\alias{oneGT}
\alias{oneIN}
\alias{oneLE}
\alias{oneLT}
\alias{oneMF}
\alias{oneTF}
\alias{oneDIF}
\alias{oneNAS}
\alias{oneOKS}
\alias{hasONE}
\alias{lacksONE}
\alias{allF}
\alias{allT}
\alias{allBL}
\alias{allEQ}
\alias{allGE}
\alias{allGT}
\alias{allIN}
\alias{allLE}
\alias{allLT}
\alias{allMF}
\alias{allTF}
\alias{allDIF}
\alias{allNAS}
\alias{allOKS}
\alias{hasALL}
\alias{lacksALL}
\alias{someF}
\alias{someT}
\alias{someBL}
\alias{someEQ}
\alias{someLE}
\alias{someGE}
\alias{someGT}
\alias{someIN}
\alias{someLT}
\alias{someMF}
\alias{someTF}
\alias{someDIF}
\alias{someNAS}
\alias{someOKS}
\alias{hasSOME}
\alias{lacksSOME}
\alias{twoF}
\alias{twoT}
\alias{twoBL}
\alias{twoEQ}
\alias{twoGE}
\alias{twoGT}
\alias{twoIN}
\alias{twoLE}
\alias{twoLT}
\alias{twoMF}
\alias{twoTF}
\alias{twoDIF}
\alias{twoNAS}
\alias{twoOKS}
\alias{hasTWO}
\alias{lacksTWO}
\alias{manyF}
\alias{manyT}
\alias{manyBL}
\alias{manyEQ}
\alias{manyGE}
\alias{manyGT}
\alias{manyIN}
\alias{manyLE}
\alias{manyLT}
\alias{manyMF}
\alias{manyTF}
\alias{manyDIF}
\alias{manyNAS}
\alias{manyOKS}
\alias{hasMANY}
\alias{lacksMANY}
\alias{\%.in1.\%}
\alias{\%.mf1.\%}
\alias{\%.eq1.\%}
\alias{\%.ge1.\%}
\alias{\%.gt1.\%}
\alias{\%.le1.\%}
\alias{\%.lt1.\%}
\alias{\%.has1.\%}
\alias{\%.dif1.\%}
\alias{\%.lacks1.\%}
\alias{\%.in.\%}
\alias{\%.mf.\%}
\alias{\%.eq.\%}
\alias{\%.ge.\%}
\alias{\%.gt.\%}
\alias{\%.le.\%}
\alias{\%.lt.\%}
\alias{\%.has.\%}
\alias{\%.dif.\%}
\alias{\%.lacks.\%}
\alias{\%.seq.\%}
\alias{\%.veq.\%}
\alias{\%.sdif.\%}
\alias{\%.vdif.\%}
\alias{\%.or1.\%}
\alias{\%.and1.\%}
\alias{\%.xor1.\%}
\alias{\%.nor1.\%}
\alias{\%.or.\%}
\alias{\%.and.\%}
\alias{\%.xor.\%}
\alias{\%.nor.\%}
\title{Failsafe functions that \strong{always} return a valid object.}
\usage{
failsafe(x, def = ".err")

isERR(x)

notERR(x)

msgERR(x)

makeERR()

fsDEF(x)

fsSCL(x, val)

fsVEC(x, val)

fsNULL(x)

sclBL(x)

sclT(x)

sclF(x)

sclTF(x)

sclLG(x)

sclNA(x)

vecBL(x)

vecT(x)

vecF(x)

vecTF(x)

vecNA(x)

fsOR(x, or = NULL)

orF(x)

orT(x)

orBL(x)

orC0(x)

orI0(x)

orL0(x)

orN0(x)

orNA(x)

orNAC(x)

orNAI(x)

orNAL(x)

orNAR(x)

orNULL(x)

IS(x, y)

ISNT(x, y)

isIN1(x, ...)

isMF1(x, ...)

HAS1(x, y)

LACKS1(x, y)

isEQ1(x, y)

isGE1(x, y)

isGT1(x, y)

isLE1(x, y)

isLT1(x, y)

isDIF1(x, y)

isF1(x)

isT1(x)

isBL1(x)

isTF1(x)

isNA1(x)

isOK1(x)

isLG1(x)

isIN(x, ...)

isMF(x, ...)

HAS(x, y)

LACKS(x, y)

isEQ(x, y)

isGE(x, y)

isGT(x, y)

isLE(x, y)

isLT(x, y)

isDIF(x, y)

isF(x)

isT(x)

isBL(x)

isTF(x)

isNAS(x)

isOKS(x)

isSEQ(x, y)

isVEQ(x, y)

isSDIF(x, y)

isVDIF(x, y)

or1(x, y)

and1(x, y)

xor1(x, y)

nor1(x, y)

OR(x, y)

AND(x, y)

XOR(x, y)

NOR(x, y)

notIN1(x, ...)

notMF1(x, ...)

notHAS1(x, y)

notLACKS1(x, y)

notEQ1(x, y)

notGE1(x, y)

notGT1(x, y)

notLE1(x, y)

notLT1(x, y)

notDIF1(x, y)

notF1(x)

notT1(x)

notTF1(x)

notBL1(x)

notNA1(x)

notOK1(x)

notLG1(x)

notIN(x, ...)

notMF(x, ...)

notHAS(x, y)

notLACKS(x, y)

notEQ(x, y)

notGE(x, y)

notGT(x, y)

notLE(x, y)

notLT(x, y)

notDIF(x, y)

notF(x)

notT(x)

notTF(x)

notBL(x)

notNAS(x)

notOKS(x)

notSEQ(x, y)

notVEQ(x, y)

notSDIF(x, y)

notVDIF(x, y)

nIN(x, ...)

nMF(x, ...)

nHAS(x, y)

nLACKS(x, y)

nEQ(x, y)

nGE(x, y)

nGT(x, y)

nLE(x, y)

nLT(x, y)

nDIF(x, y)

nF(x)

nT(x)

nTF(x)

nBL(x)

nNAS(x)

nOKS(x)

noneF(x)

noneT(x)

noneTF(x)

noneBL(x)

noneEQ(x, y)

noneGE(x, y)

noneGT(x, y)

noneLE(x, y)

noneLT(x, y)

noneIN(x, ...)

noneMF(x, ...)

noneDIF(x, y)

noneNAS(x)

noneOKS(x)

hasNONE(x, y)

lacksNONE(x, y)

anyF(x)

anyT(x)

anyBL(x)

anyEQ(x, y)

anyGE(x, y)

anyGT(x, y)

anyIN(x, ...)

anyLE(x, y)

anyLT(x, y)

anyMF(x, ...)

anyTF(x)

anyDIF(x, y)

anyNAS(x)

anyOKS(x)

hasANY(x, y)

lacksANY(x, y)

oneF(x)

oneT(x)

oneBL(x)

oneEQ(x, y)

oneGE(x, y)

oneGT(x, y)

oneIN(x, ...)

oneLE(x, y)

oneLT(x, y)

oneMF(x, ...)

oneTF(x)

oneDIF(x, y)

oneNAS(x)

oneOKS(x)

hasONE(x, y)

lacksONE(x, y)

allF(x)

allT(x)

allBL(x)

allEQ(x, y)

allGE(x, y)

allGT(x, y)

allIN(x, ...)

allLE(x, y)

allLT(x, y)

allMF(x, ...)

allTF(x)

allDIF(x, y)

allNAS(x)

allOKS(x)

hasALL(x, y)

lacksALL(x, y)

someF(x)

someT(x)

someBL(x)

someEQ(x, y)

someLE(x, y)

someGE(x, y)

someGT(x, y)

someIN(x, ...)

someLT(x, y)

someMF(x, ...)

someTF(x)

someDIF(x, y)

someNAS(x)

someOKS(x)

hasSOME(x, y)

lacksSOME(x, y)

twoF(x)

twoT(x)

twoBL(x)

twoEQ(x, y)

twoGE(x, y)

twoGT(x, y)

twoIN(x, ...)

twoLE(x, y)

twoLT(x, y)

twoMF(x, ...)

twoTF(x)

twoDIF(x, y)

twoNAS(x)

twoOKS(x)

hasTWO(x, y)

lacksTWO(x, y)

manyF(x)

manyT(x)

manyBL(x)

manyEQ(x, y)

manyGE(x, y)

manyGT(x, y)

manyIN(x, ...)

manyLE(x, y)

manyLT(x, y)

manyMF(x, ...)

manyTF(x)

manyDIF(x, y)

manyNAS(x)

manyOKS(x)

hasMANY(x, y)

lacksMANY(x, y)

x \%.in1.\% y

x \%.mf1.\% y

x \%.eq1.\% y

x \%.ge1.\% y

x \%.gt1.\% y

x \%.le1.\% y

x \%.lt1.\% y

x \%.has1.\% y

x \%.dif1.\% y

x \%.lacks1.\% y

x \%.in.\% y

x \%.mf.\% y

x \%.eq.\% y

x \%.ge.\% y

x \%.gt.\% y

x \%.le.\% y

x \%.lt.\% y

x \%.has.\% y

x \%.dif.\% y

x \%.lacks.\% y

x \%.seq.\% y

x \%.veq.\% y

x \%.sdif.\% y

x \%.vdif.\% y

x \%.or1.\% y

x \%.and1.\% y

x \%.xor1.\% y

x \%.nor1.\% y

x \%.or.\% y

x \%.and.\% y

x \%.xor.\% y

x \%.nor.\% y
}
\arguments{
\item{x, y}{Any objects for failsafe binary functions and miscellaneous failsafe functions.}

\item{val}{An atomic scalar.}

\item{or}{An object to return if evaluating \code{x} produces an error.}

\item{x}{An object or a call to evaluate in the environment of a parent function where the initial call was made.}
}
\value{
A logical scalar.
}
\description{
Evaluate objects, test if an object has certain properties, and conduct binary logical operations safely. These functions never stop execution; they always produce a valid result, even if that result is an error object.
}
\details{
Failsafe binary comparison functions: These are binary functions that always produce either scalar \code{TRUE} or scalar \code{FALSE}. They return \code{TRUE} when two variables meet the conditions shown in the following table and \code{FALSE} in every other circumstance (where \code{fx} and \code{fy})
\tabular{ll}{  \verb{\%.is.\%}       \tab \code{failsafe(identical(x, y))}                                  \cr
  \verb{\%.isnt.\%}     \tab \code{!(x \%.is.\% y)}                                              \cr   \tab   \cr
  \verb{\%.in.\%}       \tab \code{sapply(failsafe(x \%in\% y), isTRUE)}                         \cr
  \verb{\%.mf.\%}       \tab \code{!(x \%.in.\% y)} (missing from)                               \cr
  \verb{\%.has.\%}      \tab \code{y \%.in.\% x} (\code{x} has each \code{y} value)                        \cr
  \verb{\%.lacks.\%}    \tab \code{y \%.mf.\% x} (\code{x} lacks each \code{y} value)                      \cr   \tab   \cr
  \verb{\%.in1.\%}      \tab if \code{x} is atomic scalar, \code{x \%.in.\% y}, otherwise \code{FALSE}     \cr
  \verb{\%.mf1.\%}      \tab \code{x} is atomic scalar and \code{x \%.mf.\% y}                        \cr
  \verb{\%.has1.\%}     \tab \code{y} is atomic scalar and \code{x \%.has.\% y}                       \cr
  \verb{\%.lacks1.\%}   \tab \code{y} is atomic scalar and \code{x \%.lacks.\% y}                     \cr   \tab   \cr
  \verb{\%.eq.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x = y}, otherwise \code{FALSE} \cr
  \verb{\%.ge.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≥ y}, otherwise \code{FALSE} \cr
  \verb{\%.gt.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x > y}, otherwise \code{FALSE} \cr
  \verb{\%.le.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≤ y}, otherwise \code{FALSE} \cr
  \verb{\%.lt.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x < y}, otherwise \code{FALSE} \cr
  \verb{\%.dif.\%}      \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≠ y}, otherwise \code{TRUE}  \cr   \tab   \cr
  \verb{\%.eq1.\%}      \tab \code{x} and \code{y} are atomic scalar and \code{x = y}  \eqn{^{(2)}}      \cr
  \verb{\%.ge1.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≥ y}  \eqn{^{(2)}}      \cr
  \verb{\%.gt1.\%}      \tab \code{x} and \code{y} are atomic scalar and \code{x > y}  \eqn{^{(2)}}      \cr
  \verb{\%.le1.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≤ y}  \eqn{^{(2)}}      \cr
  \verb{\%.lt1.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≥ y}  \eqn{^{(2)}}      \cr
  \verb{\%.dif1.\%}     \tab \code{x} and \code{y} are \emph{not} atomic scalar equal  \eqn{^{(3)}}      \cr   \tab   \cr
  \verb{\%.seq.\%}      \tab \code{x} and \code{y} are \code{\link[base]{setequal}}\eqn{^{(4)}}     \cr
  \verb{\%.veq.\%}      \tab \code{x} and \code{y} are vector equal\eqn{^{(5)}}                     \cr
  \verb{\%.sdif.\%}     \tab \code{x} and \code{y} are set different\eqn{^{(6)}}                    \cr
  \verb{\%.vdif.\%}     \tab \code{x} and \code{y} are vector different\eqn{^{(7)}}                 \cr   \tab   \cr
  \verb{\%.or.\%}       \tab values of \code{x} \emph{and/or} \code{y} are \code{TRUE}                        \cr
  \verb{\%.and.\%}      \tab values of \code{x} \emph{and} \code{y} are \code{TRUE}                           \cr
  \verb{\%.xor.\%}      \tab values of \emph{either} \code{x} \emph{or} \code{y} are \code{TRUE}                   \cr
  \verb{\%.nor.\%}      \tab values of \emph{neither} \code{x} \emph{nor} \code{y} are \code{TRUE}                 \cr   \tab   \cr
  \verb{\%.or1.\%}      \tab \code{x} \emph{and/or} \code{y} are scalar \code{TRUE}                           \cr
  \verb{\%.and1.\%}     \tab \code{x} \emph{and} \code{y} are scalar \code{TRUE}                              \cr
  \verb{\%.xor1.\%}     \tab \emph{either} \code{x} \emph{or} \code{y} is scalar \code{TRUE}                       \cr
  \verb{\%.nor1.\%}     \tab \emph{neither} \code{x} \emph{nor} \code{y} is scalar \code{TRUE}                       }
\tabular{l}{  \eqn{^{(1)}} Of equal length and \link[=compatible]{compatible modes}.                                                       \cr
  \eqn{^{(2)}} Of \link[=compatible]{compatible modes} and meeting the (in)equality.                                           \cr
  \eqn{^{(3)}} Not meeting the requirements of \verb{\%.eq1.\%}.                                                                      \cr
  \eqn{^{(4)}} Atomic, of the same length, with the same values in the same order.                                             \cr
  \eqn{^{(5)}} Atomic, possibly of different lengths, and containing the same unique values regardless of order or duplicates. \cr
  \eqn{^{(6)}} Not meeting the requirements of \verb{\%.seq.\%}.                                                                      \cr
  \eqn{^{(7)}} Not meeting the requirements of \verb{\%.veq.\%}.                                                                        }
}
\section{Failsafe error management functions}{
 These functions evaluate generate, check for, and manage error objects.
\tabular{ll}{  \code{makeERR}      \tab Generate object of class \code{'simpleError'}.     \cr
  \code{msgERR}       \tab Get error message, if any; otherwise, \code{NULL}. \cr
  \code{notERR}       \tab Does evaluating \code{x} not produce an error?.    \cr
  \code{isERR}        \tab Does evaluating \code{x} produce an error?           }
}

\section{Failsafe check for classes of objects with values}{

\tabular{ll}{  \code{failsafe}     \tab Returns \code{x} if identity evaluation does not cause an error. Return an error object otherwise. \cr   \tab   \cr
  \code{fsNULL}       \tab \code{x} is \code{NULL}.                                                                                \cr
  \code{fsDEF}        \tab \code{x} is defined (not \code{NULL}).                                                                  \cr   \tab   \cr
  \code{fsSCL}        \tab \code{x} is scalar of a specific atomic value.                                                     \cr
  \code{sclF}         \tab \code{x} is scalar \code{FALSE}                                                                         \cr
  \code{sclT}         \tab \code{x} is scalar \code{TRUE}                                                                          \cr
  \code{sclTF}        \tab \code{x} is scalar \code{TRUE} or \code{FALSE}.                                                              \cr
  \code{sclLG}        \tab \code{x} is scalar \code{TRUE}, \code{FALSE}, or \code{NA}.                                                       \cr
  \code{sclBL}        \tab \code{x} is blank string scalar (\code{""}).                                                            \cr
  \code{sclNA}        \tab \code{x} is scalar \code{NA}                                                                            \cr   \tab   \cr
  \code{fsVEC}        \tab Elements of \code{x} are of a specific atomic value.                                               \cr
  \code{vecF}         \tab Elements of \code{x} are \code{FALSE}.                                                                  \cr
  \code{vecT}         \tab Elements of \code{x} are \code{TRUE}.                                                                   \cr
  \code{vecTF}        \tab Elements of \code{x} are \code{TRUE} or \code{FALSE}.                                                        \cr
  \code{vecLG}        \tab Elements of \code{x} are \code{TRUE}, \code{FALSE}, or \code{NA}.                                                 \cr
  \code{vecBL}        \tab Elements of \code{x} are blank strings.                                                            \cr
  \code{vecNA}        \tab Elements of \code{x} are \code{NA}.                                                                       }
}

\section{Failsafe forced-evaluation functions with conditional return values}{
 These functions \link[base:force]{force} evaluation of \code{x} returning values as shown in the following table with the first value returned when forcing evaluation does not produce an error and the second when it does:
\tabular{ll}{  \code{fsOR}         \tab \code{x} or something else if evaluating \code{x} produces an error \cr   \tab   \cr
  \code{orF}          \tab \code{x} or \code{FALSE}                                            \cr
  \code{orT}          \tab \code{x} or \code{TRUE}                                             \cr   \tab   \cr
  \code{orC0}         \tab \code{x} or \code{character(0)}                                     \cr
  \code{orI0}         \tab \code{x} or \code{integer(0)}                                       \cr
  \code{orL0}         \tab \code{x} or \code{logical(0)}                                       \cr
  \code{orN0}         \tab \code{x} or \code{numeric(0)}                                       \cr   \tab   \cr
  \code{orBL}         \tab \code{x} or \code{""}                                               \cr   \tab   \cr
  \code{orNA}         \tab \code{x} or \code{NA}                                               \cr
  \code{orNAC}        \tab \code{x} or \code{NA_character_}                                    \cr
  \code{orNAI}        \tab \code{x} or \code{NA_integer_}                                      \cr
  \code{orNAL}        \tab \code{x} or \code{NA} (logical)                                     \cr
  \code{orNAR}        \tab \code{x} or \code{NA_real_}                                           }
}

\section{Failsafe scalar value, membership, and equality/inequality checking functions}{
 These functions check for class, mode, and/or value and/or count the number of checks passed. They \emph{always} produce \code{TRUE}, \code{FALSE}, or an integer scalar.
\cr\cr Function names are constructed of root words, prefixes, and/or suffixes. Root word specify the type of check conducted. Prefixes and suffixes specify how to modify the results of a check or how to apply the check to each \code{...} argument and check whether a certain number of \code{...} args passed the checks.
\cr\cr \strong{\emph{Root words for atomic scalar value checking functions}}
\tabular{ll}{  \code{nas}     \tab \code{x} is scalar \code{NA} and atomic.                      \cr
  \code{oks}     \tab \code{x} is scalar, non-\code{NA} and atomic.                 \cr
  \code{bl}      \tab \code{x} is a scalar blank string (\code{""}).                \cr
  \code{lg}      \tab \code{x} is a logical scalar (\code{TRUE}, \code{FALSE}, or \code{NA}). \cr
  \code{tf}      \tab \code{x} is scalar \code{TRUE} or scalar \code{FALSE}.             \cr
  \code{f}       \tab \code{x} is scalar \code{TRUE}.                               \cr
  \code{t}       \tab \code{x} is scalar \code{FALSE}.                                }
\cr \strong{\emph{Root words for atomic value membership checking functions}}
\tabular{ll}{  \code{lacks}   \tab \code{x \%.lacks.\% y} \cr
  \code{has}     \tab \code{x \%.has.\% y}   \cr
  \verb{in}      \tab \code{x \%.in.\% y}    \cr
  \code{mf}      \tab \code{x \%.mf.\% y}      }
\cr \strong{\emph{Root words for equality/inequality checking functions}}
\tabular{ll}{  \code{is}      \tab \code{x \%.is.\% y}                         \cr
  \code{isnt}    \tab \code{x \%.isnt.\% y}                       \cr
  \code{eq}      \tab \code{x \%.eq.\% y}                         \cr
  \code{eq1}     \tab \code{x \%.eq1.\% y}                        \cr
  \code{seq}     \tab \code{x \%.seq.\% y}                        \cr
  \code{veq}     \tab \code{x \%.veq.\% y}                        \cr
  \code{dif}     \tab \code{x \%.dif.\% y}                        \cr
  \code{dif1}    \tab \code{x \%.dif1.\% y}                       \cr
  \code{sdif}    \tab \code{x \%.sdif.\% y}                       \cr
  \code{vdif}    \tab \code{x \%.sdif.\% y}                       \cr
  \code{ge}      \tab \code{x} is greater than or equal to \code{y}. \cr
  \code{gt}      \tab \code{x} is greater than \code{y}.             \cr
  \code{le}      \tab \code{x} is less than or equal to \code{y}.    \cr
  \code{lt}      \tab \code{x} is less than \code{y}.                  }
\cr \strong{\emph{Modifier prefixes/suffixes}}
\tabular{ll}{  \code{n}       \tab Count \code{...} args passing the check.  \cr
  \code{is}      \tab Keep the result of a check as is.    \cr
  \code{not}     \tab Negate the result of a check.          }
\cr \strong{\emph{Apply-and-sweep prefixes/suffixes evaluating whether a certain number of checks were passed}}
\cr\cr The following table contains prefixes in the first column, and in the second, the number of checks that must be passed to return \code{TRUE}.
\tabular{ll}{  \code{none}    \tab \code{0} values passed the check.   \cr
  \code{any}     \tab \verb{> 0} values passed the check. \cr
  \code{one}     \tab \code{1} value passed the check.    \cr
  \code{some}    \tab \verb{> 1} values passed the check. \cr
  \code{two}     \tab \code{2} values passed the check.   \cr
  \code{many}    \tab \verb{> 2} values passed the check. \cr
  \code{all}     \tab All values passed the check.     }
\cr \strong{\emph{Identity-equality, set-equality and vector-equality checking functions}}
\tabular{lll}{              \tab \strong{IS}     \tab \strong{NOT}   \cr
  \strong{IS}      \tab \code{IS}       \tab  —        \cr
  \strong{ISNT}    \tab \code{ISNT}     \tab  —        \cr
  \strong{SEQ}     \tab \code{isSEQ}    \tab \code{notSEQ}  \cr
  \strong{VEQ}     \tab \code{isVEQ}    \tab \code{notVEQ}  \cr
  \strong{SDIF}    \tab \code{isSDIF}   \tab \code{notSDIF} \cr
  \strong{VDIF}    \tab \code{isVDIF}   \tab \code{notVDIF}   }
\\cr \strong{\emph{Atomic scalar value checking functions}}
\tabular{lll}{              \tab \strong{IS1}    \tab \strong{NOT1}  \cr
  \strong{T}       \tab \code{isT1}     \tab \code{notT1}   \cr
  \strong{F}       \tab \code{isF1}     \tab \code{notF1}   \cr
  \strong{TF}      \tab \code{isTF1}    \tab \code{notTF1}  \cr
  \strong{LG}      \tab \code{isLG1}    \tab \code{notLG1}  \cr
  \strong{BL}      \tab \code{isBL1}    \tab \code{notBL1}  \cr
  \strong{EQ}      \tab \code{isEQ1}    \tab \code{notEQ1}  \cr
  \strong{GE}      \tab \code{isGE1}    \tab \code{notGE1}  \cr
  \strong{GT}      \tab \code{isGT1}    \tab \code{notGT1}  \cr
  \strong{LE}      \tab \code{isLE1}    \tab \code{notLE1}  \cr
  \strong{LT}      \tab \code{isLT1}    \tab \code{notLT1}  \cr
  \strong{NAS}     \tab \code{isNAS}    \tab \code{notNAS}  \cr
  \strong{OKS}     \tab \code{isOKS}    \tab \code{notOKS}  \cr
  \strong{DIF}     \tab \code{isDIF1}   \tab \code{notDIF1}   }
\cr\cr \strong{\emph{Atomic scalar membership checking functions}}
\tabular{lll}{              \tab \strong{IS1}    \tab \strong{NOT1}    \cr
  \strong{IN}      \tab \code{IN1}      \tab \code{notIN1}    \cr
  \strong{MF}      \tab \code{MF1}      \tab \code{notMF1}    \cr
  \strong{HAS}     \tab \code{HAS1}     \tab \code{notHAS1}   \cr
  \strong{LACKS}   \tab \code{LACKS1}   \tab \code{notLACKS1}   }
\cr\cr \strong{\emph{Atomic value checking functions}}
\tabular{lllllllll}{              \tab \strong{IS}    \tab \strong{N}      \tab \strong{NOT}      \tab \strong{NONE}      \tab \strong{ONE}      \tab \strong{TWO}      \tab \strong{ANY}      \tab  \strong{ALL}   \cr
  \strong{T}       \tab \code{isT}     \tab \code{nT}       \tab \code{notT}       \tab \code{noneT}       \tab \code{oneT}       \tab \code{twoT}       \tab \code{anyT}       \tab \code{allT}     \cr
  \strong{F}       \tab \code{isF}     \tab \code{nF}       \tab \code{notF}       \tab \code{noneF}       \tab \code{oneF}       \tab \code{twoF}       \tab \code{anyF}       \tab \code{allF}     \cr
  \strong{TF}      \tab \code{isTF}    \tab \code{nTF}      \tab \code{notTF}      \tab \code{noneTF}      \tab \code{oneTF}      \tab \code{twoTF}      \tab \code{anyTF}      \tab \code{allTF}    \cr
  \strong{BL}      \tab \code{isBL}    \tab \code{nBL}      \tab \code{notBL}      \tab \code{noneBL}      \tab \code{oneBL}      \tab \code{twoBL}      \tab \code{anyBL}      \tab \code{allBL}    \cr
  \strong{EQ}      \tab \code{isEQ}    \tab \code{nEQ}      \tab \code{notEQ}      \tab \code{noneEQ}      \tab \code{oneEQ}      \tab \code{twoEQ}      \tab \code{anyEQ}      \tab \code{allEQ}    \cr
  \strong{GE}      \tab \code{isGE}    \tab \code{nGE}      \tab \code{notGE}      \tab \code{noneGE}      \tab \code{oneGE}      \tab \code{twoGE}      \tab \code{anyGE}      \tab \code{allGE}    \cr
  \strong{GT}      \tab \code{isGT}    \tab \code{nGT}      \tab \code{notGT}      \tab \code{noneGT}      \tab \code{oneGT}      \tab \code{twoGT}      \tab \code{anyGT}      \tab \code{allGT}    \cr
  \strong{LE}      \tab \code{isLE}    \tab \code{nLE}      \tab \code{notLE}      \tab \code{noneLE}      \tab \code{oneLE}      \tab \code{twoLE}      \tab \code{anyLE}      \tab \code{allLE}    \cr
  \strong{LT}      \tab \code{isLT}    \tab \code{nLT}      \tab \code{notLT}      \tab \code{noneLT}      \tab \code{oneLT}      \tab \code{twoLT}      \tab \code{anyLT}      \tab \code{allLT}    \cr
  \strong{DIF}     \tab \code{isDIF}   \tab \code{nDIF}     \tab \code{notDIF}     \tab \code{noneDIF}     \tab \code{oneDIF}     \tab \code{twoDIF}     \tab \code{anyDIF}     \tab \code{allDIF}   \cr
  \strong{NAS}     \tab \code{isNA}    \tab \code{nNAS}     \tab \code{notNAS}     \tab \code{noneNAS}     \tab \code{oneNAS}     \tab \code{twoNAS}     \tab \code{anyNAS}     \tab \code{allNAS}   \cr
  \strong{OKS}     \tab \verb{isOKS  } \tab \code{nOKS}     \tab \code{notOKS}     \tab \code{noneOKS}     \tab \code{oneOKS}     \tab \code{twoOKS}     \tab \code{anyOKS}     \tab \code{allOKS}     }
\cr\cr \strong{\emph{Atomic value membership checking functions}}
\tabular{lllllllll}{              \tab \strong{IS}     \tab \strong{N}     \tab \strong{NOT}      \tab \strong{NONE}      \tab \strong{ONE}      \tab \strong{TWO}      \tab \strong{ANY}      \tab \strong{ALL}    \cr
  \strong{IN}      \tab \code{isIN}    \tab \code{nIN}      \tab \code{notIN}      \tab \code{inNONE}      \tab \code{inONE}      \tab \code{inTWO}      \tab \code{inANY}      \tab \code{inALL}    \cr
  \strong{MF}      \tab \code{isMF}    \tab \code{nMF}      \tab \code{notMF}      \tab \code{mfNONE}      \tab \code{mfONE}      \tab \code{mfTWO}      \tab \code{mfANY}      \tab \code{mfALL}    \cr
  \strong{HAS}     \tab \code{HAS}     \tab \code{nHAS}     \tab \code{notHAS}     \tab \code{hasNONE}     \tab \code{hasONE}     \tab \code{hasTWO}     \tab \code{hasANY}     \tab \code{hasALL}   \cr
  \strong{ALCKS}   \tab \code{LACKS}   \tab \code{nLACKS}   \tab \code{notLACKS}   \tab \code{lacksNONE}   \tab \code{lacksONE}   \tab \code{lacksTWO}   \tab \code{lacksANY}   \tab \code{lacksALL}   }
}

\examples{
egFailsafe <- function() {
  abc <- c("a", "b", "c")
  ABC <- abc
  Blank. <- ""
  MssScl. <- NA
  LglScl. <- FALSE
  FacScl. <- factor("q", levels = c("x", "q"))
  FacVec. <- factor(c("x", "q"), levels = c("x", "q"))
  ChrMat. <- matrix(c("a", "b", "c", "NA"), nrow = 2)
  ChrDtf. <- data.frame(abc = letters[1:3], def = letters[4:6])
  NumVls. <- list(first3 = c(1:3, NA), next3 = c(4:6, NA))
  Combo. <- list(MssScl., LglScl., FacVec., ChrMat., ChrDtf., NumVls.)
  attr(ABC, "custom") <- "custom"
  list(`"A" \%.and1.\% FALSE`                   = "A" \%.and.\% FALSE                   ,
       `"a" \%.in1.\% abc`                      = "a" \%.in.\% abc                      ,
       `"A" \%.nor1.\% FALSE`                   = "A" \%.or.\% FALSE                    ,
       `"A" \%.xor1.\% FALSE`                   = "A" \%.cor.\% FALSE                   ,
       `"A" \%.or1.\% FALSE`                    = "A" \%.or.\% FALSE                    ,
       `"a" \%.mf1.T\% abc`                     = "a" \%.mf.\% abc                      ,
       `"A" \%.and.\% FALSE`                    = "A" \%.and.\% FALSE                   ,
       `abs \%.in.\% abc`                       = "a" \%.in.\% abc                      ,
       `"A" \%.nor.\% FALSE`                    = "A" \%.or.\% FALSE                    ,
       `"A" \%.xor.\% FALSE`                    = "A" \%.cor.\% FALSE                   ,
       `"A" \%.or.\% FALSE`                     = "A" \%.or.\% FALSE                    ,
       `"a" \%.mf.\% abc`                       = "a" \%.mf.\% abc                      ,
       `1 \%.in.\% abc`                         = 1 \%.in.\% abc                        ,
       `1 \%.mf.\% abc`                         = 1 \%.mf.\% abc                        ,
       `abc \%.eq1.\% ABC`                      = abc \%.eq1.\% ABC                     ,
       `abc \%.eq1.\% letters[1:3]`             = abc \%.eq1.\% letters[1:3]            ,
       `abc \%.eq1.\% NULL`                     = abc \%.eq1.\% NULL                    ,
       `abc \%.has1.\% "a"`                     = abc \%.has.\% "a"                     ,
       `abc \%.has1.\% 1`                       = abc \%.has.\% 1                       ,
       `abc \%.has1.\% NULL`                    = abc \%.has.\% NULL                    ,
       `abc \%.has.\% letters[1:6]`             = abc \%.has.\% "a"                     ,
       `abc \%.has.\% 1:3`                      = abc \%.has.\% 1                       ,
       `abc \%.has.\% NULL`                     = abc \%.has.\% NULL                    ,
       `abc \%.is.\% NULL`                      = abc \%.is.\% NULL                     ,
       `abc \%.lacks1.\% "a"`                   = abc \%.lacks.\% "a"                   ,
       `abc \%.lacks1.\% 1`                     = abc \%.lacks.\% 1                     ,
       `abc \%.lacks1.\% NULL`                  = abc \%.lacks.\% NULL                  ,
       `abc \%.is.\% ABC`                       = abc \%.is.\% ABC                      ,
       `abc \%.is.\% letters[1:3]`              = abc \%.is.\% letters[1:3]             ,
       `abc \%.isnt.\% ABC`                     = abc \%.isnt.\% ABC                    ,
       `abc \%.isnt.\% letters[4:6]`            = abc \%.isnt.\% letters[4:6]           ,
       `allBL(c(Blank., letters))`            = allBL(c(Blank., letters))           ,
       `allDIF("a", c(Blank., NA, letters))`  = allDIF("a", c(Blank., NA, letters)) ,
       `allEQ(NA, c(Blank., NA, letters))`    = allEQ(NA, c(Blank., NA, letters))   ,
       `allF(c(list(Blank.), Combo.))`        = allF(c(list(Blank.), Combo.))       ,
       `allGE("a", c(Blank., NA, letters))`   = allGE("a", c(Blank., NA, letters))  ,
       `allGT("a", c(Blank., NA, letters))`   = allGT("a", c(Blank., NA, letters))  ,
       `allIN(NULL, Blank., Combo.)`          = allIN(NULL, Blank., Combo.)         ,
       `allLE("a", c(Blank., NA, letters))`   = allLE("a", c(Blank., NA, letters))  ,
       `allLG(c(NA, T, F))`                   = allLG(c(NA, T, F))                  ,
       `allLT("a", c(Blank., NA, letters))`   = allLT("a", c(Blank., NA, letters))  ,
       `allMF(NULL, Blank., Combo.)`          = allMF(NULL, Blank., Combo.)         ,
       `allNAS(c(Blank., NA, letters))`       = allNAS(c(Blank., NA, letters))      ,
       `allNAS(ChrMat.)`                      = allNAS(ChrMat.)                     ,
       `allOKS(c(Blank., NA, letters))`       = allOKS(c(Blank., NA, letters))      ,
       `allOKS(ChrMat.)`                      = allOKS(ChrMat.)                     ,
       `allT(c(list(Blank.), Combo.))`        = allT(c(list(Blank.), Combo.))       ,
       `allTF(c(list(Blank.), Combo.))`       = allTF(c(list(Blank.), Combo.))      ,
       `anyBL(c(Blank., letters))`            = anyBL(c(Blank., letters))           ,
       `anyDIF("a", c(Blank., NA, letters))`  = anyDIF("a", c(Blank., NA, letters)) ,
       `anyEQ(NA, c(Blank., NA, letters))`    = anyEQ(NA, c(Blank., NA, letters))   ,
       `anyF(c(list(Blank.), Combo.))`        = anyF(c(list(Blank.), Combo.))       ,
       `anyGE("a", c(Blank., NA, letters))`   = anyGE("a", c(Blank., NA, letters))  ,
       `anyGT("a", c(Blank., NA, letters))`   = anyGT("a", c(Blank., NA, letters))  ,
       `anyIN(NULL, Blank., Combo.)`          = anyIN(NULL, Blank., Combo.)         ,
       `anyLE("a", c(Blank., NA, letters))`   = anyLE("a", c(Blank., NA, letters))  ,
       `anyLG(c(NA, T, F))`                   = anyLG(c(NA, T, F))                  ,
       `anyLT("a", c(Blank., NA, letters))`   = anyLT("a", c(Blank., NA, letters))  ,
       `anyMF(NULL, Blank., Combo.)`          = anyMF(NULL, Blank., Combo.)         ,
       `anyNAS(c(Blank., NA, letters))`       = anyNAS(c(Blank., NA, letters))      ,
       `anyNAS(ChrMat.)`                      = anyNAS(ChrMat.)                     ,
       `anyOKS(c(Blank., NA, letters))`       = anyOKS(c(Blank., NA, letters))      ,
       `anyOKS(ChrMat.)`                      = anyOKS(ChrMat.)                     ,
       `anyT(c(list(Blank.), Combo.))`        = anyT(c(list(Blank.), Combo.))       ,
       `anyTF(c(list(Blank.), Combo.))`       = anyTF(c(list(Blank.), Combo.))      ,
       `failsafe(non.existent.variable)`      = failsafe(non.existent.variable)     ,
       `failsafe(pi)`                         = failsafe(pi)                        ,
       `FALSE \%AND\% FALSE`                    = FALSE \%AND\% FALSE                   ,
       `FALSE \%NOR\% FALSE`                    = FALSE \%NOR\% FALSE                   ,
       `FALSE \%ONE\% FALSE`                    = FALSE \%ONE\% FALSE                   ,
       `FALSE \%OR\% FALSE`                     = FALSE \%OR\% FALSE                    ,
       `hasALL(Blank., Combo.)`               = hasALL(Blank., Combo.)              ,
       `hasANY(Blank., Combo.)`               = hasANY(Blank., Combo.)              ,
       `hasMANY(Blank., Combo.)`              = hasMANY(Blank., Combo.)             ,
       `hasNONE(Blank., Combo.)`              = hasNONE(Blank., Combo.)             ,
       `hasONE(Blank., Combo.)`               = hasONE(Blank., Combo.)              ,
       `hasSOME(Blank., Combo.)`              = hasSOME(Blank., Combo.)             ,
       `hasTWO(Blank., Combo.)`               = hasTWO(Blank., Combo.)              ,
       `isBL("")`                             = isBL("")                            ,
       `isBL("a")`                            = isBL("a")                           ,
       `isBL(c("", ""))`                      = isBL(c("", ""))                     ,
       `isBL(NA)`                             = isBL(NA)                            ,
       `isBL1("")`                            = isBL1("")                           ,
       `isBL1("a")`                           = isBL1("a")                          ,
       `isBL1(c("", ""))`                     = isBL1(c("", ""))                    ,
       `isBL1(NA)`                            = isBL1(NA)                           ,
       `isDIF("", "")`                        = isDIF("", "")                       ,
       `isDIF("word", 7)`                     = isDIF("word", 7)                    ,
       `isDIF(ChrMat., ChrMat.)`              = isDIF(ChrMat., ChrMat.)             ,
       `isDIF(NA, NA)`                        = isDIF(NA, NA)                       ,
       `isDIF1("", "")`                       = isDIF1("", "")                      ,
       `isDIF1("word", 7)`                    = isDIF1("word", 7)                   ,
       `isDIF1(ChrMat., ChrMat.)`             = isDIF1(ChrMat., ChrMat.)            ,
       `isDIF1(NA, NA)`                       = isDIF1(NA, NA)                      ,
       `isEQ("", "")`                         = isEQ("", "")                        ,
       `isEQ("word", 7)`                      = isEQ("word", 7)                     ,
       `isEQ(ChrMat., ChrMat.)`               = isEQ(ChrMat., ChrMat.)              ,
       `isEQ(NA, NA)`                         = isEQ(NA, NA)                        ,
       `isEQ1("", "")`                        = isEQ1("", "")                       ,
       `isEQ1("word", 7)`                     = isEQ1("word", 7)                    ,
       `isEQ1(ChrMat., ChrMat.)`              = isEQ1(ChrMat., ChrMat.)             ,
       `isEQ1(NA, NA)`                        = isEQ1(NA, NA)                       ,
       `isERR(non.existent.variable)`         = isERR(non.existent.variable)        ,
       `isERR(pi)`                            = isERR(pi)                           ,
       `isF(c(T, F))`                         = isF(c(T, F))                        ,
       `isF(ChrMat.)`                         = isF(ChrMat.)                        ,
       `isF(NA)`                              = isF(NA)                             ,
       `isF(T)`                               = isF(T)                              ,
       `isF(T)`                               = isF(T)                              ,
       `isF1(c(T, F))`                        = isF1(c(T, F))                       ,
       `isF1(ChrMat.)`                        = isF1(ChrMat.)                       ,
       `isF1(F)`                              = isF1(F)                             ,
       `isF1(NA)`                             = isF1(NA)                            ,
       `isF1(T)`                              = isF1(T)                             ,
       `isGE("a", "b")`                       = isGE("a", "b")                      ,
       `isGE("b", "a")`                       = isGE("b", "a")                      ,
       `isGE(1, 1)`                           = isGE(1, 1)                          ,
       `isGE(ChrMat., ChrMat.)`               = isGE(ChrMat., ChrMat.)              ,
       `isGE1("a", "b")`                      = isGE1("a", "b")                     ,
       `isGE1("b", "a")`                      = isGE1("b", "a")                     ,
       `isGE1(1, 1)`                          = isGE1(1, 1)                         ,
       `isGE1(ChrMat., ChrMat.)`              = isGE1(ChrMat., ChrMat.)             ,
       `isGT("a", "b")`                       = isGT("a", "b")                      ,
       `isGT("b", "a")`                       = isGT("b", "a")                      ,
       `isGT(1, 1)`                           = isGT(1, 1)                          ,
       `isGT(ChrMat., ChrMat.)`               = isGT(ChrMat., ChrMat.)              ,
       `isGT1("a", "b")`                      = isGT1("a", "b")                     ,
       `isGT1("b", "a")`                      = isGT1("b", "a")                     ,
       `isGT1(1, 1)`                          = isGT1(1, 1)                         ,
       `isGT1(ChrMat., ChrMat.)`              = isGT1(ChrMat., ChrMat.)             ,
       `isIN(1, "", "a", 1:2)`                = isIN(1, "", "a", 1:2)               ,
       `isIN(1, "a", letters)`                = isIN(1, "a", letters)               ,
       `isIN(NULL, Blank., Combo.)`           = isIN(NULL, Blank., Combo.)          ,
       `isIN1(1, "", "a", 1:2)`               = isIN1(1, "", "a", 1:2)              ,
       `isIN1(1, "a", letters)`               = isIN1(1, "a", letters)              ,
       `isIN1(NULL, Blank., Combo.)`          = isIN1(NULL, Blank., Combo.)         ,
       `isLB1(ChrMat.)`                       = isLB1(ChrMat.)                      ,
       `isLE("a", "b")`                       = isLE("a", "b")                      ,
       `isLE("b", "a")`                       = isLE("b", "a")                      ,
       `isLE(1, 1)`                           = isLE(1, 1)                          ,
       `isLE(ChrMat., ChrMat.)`               = isLE(ChrMat., ChrMat.)              ,
       `isLE1("a", "b")`                      = isLE1("a", "b")                     ,
       `isLE1("b", "a")`                      = isLE1("b", "a")                     ,
       `isLE1(1, 1)`                          = isLE1(1, 1)                         ,
       `isLE1(ChrMat., ChrMat.)`              = isLE1(ChrMat., ChrMat.)             ,
       `isLG1(c(T, F))`                       = isLG1(c(T, F))                      ,
       `isLG1(ChrMat.)`                       = isLG1(ChrMat.)                      ,
       `isLG1(F)`                             = isLG1(F)                            ,
       `isLG1(NA)`                            = isLG1(NA)                           ,
       `isLG1(T)`                             = isLG1(T)                            ,
       `isLT("a", "b")`                       = isLT("a", "b")                      ,
       `isLT("b", "a")`                       = isLT("b", "a")                      ,
       `isLT(1, 1)`                           = isLT(1, 1)                          ,
       `isLT(ChrMat., ChrMat.)`               = isLT(ChrMat., ChrMat.)              ,
       `isLT1("a", "b")`                      = isLT1("a", "b")                     ,
       `isLT1("b", "a")`                      = isLT1("b", "a")                     ,
       `isLT1(1, 1)`                          = isLT1(1, 1)                         ,
       `isLT1(ChrMat., ChrMat.)`              = isLT1(ChrMat., ChrMat.)             ,
       `isMF(1, "", "a", 1:2)`                = isMF(1, "", "a", 1:2)               ,
       `isMF(1, "a", letters)`                = isMF(1, "a", letters)               ,
       `isMF(NULL, Blank., Combo.)`           = isMF(NULL, Blank., Combo.)          ,
       `isMF1(1, "", "a", 1:2)`               = isMF1(1, "", "a", 1:2)              ,
       `isMF1(1, "a", letters)`               = isMF1(1, "a", letters)              ,
       `isMF1(NULL, Blank., Combo.)`          = isMF1(NULL, Blank., Combo.)         ,
       `isNA(1)`                              = isNA(1)                             ,
       `isNA(c(NA, NA))`                      = isNA(c(NA, NA))                     ,
       `isNA(ChrMat.)`                        = isNA(ChrMat.)                       ,
       `isNA(NA)`                             = isNA(NA)                            ,
       `isNA1(1)`                             = isNA1(1)                            ,
       `isNA1(c(NA, NA))`                     = isNA1(c(NA, NA))                    ,
       `isNA1(ChrMat.)`                       = isNA1(ChrMat.)                      ,
       `isNA1(NA)`                            = isNA1(NA)                           ,
       `isOK(1)`                              = isOK(1)                             ,
       `isOK(c(NA, NA))`                      = isOK(c(NA, NA))                     ,
       `isOK(ChrMat.)`                        = isOK(ChrMat.)                       ,
       `isOK(NA)`                             = isOK(NA)                            ,
       `isOK1(1)`                             = isOK1(1)                            ,
       `isOK1(c(NA, NA))`                     = isOK1(c(NA, NA))                    ,
       `isOK1(ChrMat.)`                       = isOK1(ChrMat.)                      ,
       `isOK1(NA)`                            = isOK1(NA)                           ,
       `isSEQ(1, letters)`                    = isSEQ(1, letters)                   ,
       `isSEQ(1, letters)`                    = isSEQ(1, letters)                   ,
       `isSEQ(1:3, c(1, 2, 3, 2, 1))`         = isSEQ(1:3, c(1, 2, 3, 2, 1))        ,
       `isSEQ(1:3, c(1, 2, 3, 2, 1))`         = isSEQ(1:3, c(1, 2, 3, 2, 1))        ,
       `isSEQ(1:3, c(1, 2, 3))`               = isSEQ(1:3, c(1, 2, 3))              ,
       `isSEQ(1:3, c(1, 2, 3))`               = isSEQ(1:3, c(1, 2, 3))              ,
       `isT(c(T, F))`                         = isT(c(T, F))                        ,
       `isT(ChrMat.)`                         = isT(ChrMat.)                        ,
       `isT(NA)`                              = isT(NA)                             ,
       `isT(T)`                               = isT(T)                              ,
       `isT(T)`                               = isT(T)                              ,
       `isT1(c(T, F))`                        = isT1(c(T, F))                       ,
       `isT1(ChrMat.)`                        = isT1(ChrMat.)                       ,
       `isT1(F)`                              = isT1(F)                             ,
       `isT1(NA)`                             = isT1(NA)                            ,
       `isT1(T)`                              = isT1(T)                             ,
       `isTF(c(T, F))`                        = isTF(c(T, F))                       ,
       `isTF(ChrMat.)`                        = isTF(ChrMat.)                       ,
       `isTF(ChrMat.)`                        = isTF(ChrMat.)                       ,
       `isTF(NA)`                             = isTF(NA)                            ,
       `isTF(T)`                              = isTF(T)                             ,
       `isTF(T)`                              = isTF(T)                             ,
       `isTF1(c(T, F))`                       = isTF1(c(T, F))                      ,
       `isTF1(ChrMat.)`                       = isTF1(ChrMat.)                      ,
       `isTF1(F)`                             = isTF1(F)                            ,
       `isTF1(NA)`                            = isTF1(NA)                           ,
       `isTF1(T)`                             = isTF1(T)                            ,
       `isVEC(1, letters)`                    = isVEC(1, letters)                   ,
       `isVEQ(1:3, c(1, 2, 3, 2, 1))`         = isVEQ(1:3, c(1, 2, 3, 2, 1))        ,
       `isVEQ(1:3, c(1, 2, 3, 2, 1))`         = isVEQ(1:3, c(1, 2, 3, 2, 1))        ,
       `isVEQ(1:3, letters)`                  = isVEQ(1:3, letters)                 ,
       `isVEQ(1:3, c(1, 2, 3))`               = isVEQ(1:3, c(1, 2, 3))              ,
       `isVEQ(1:3, c(1, 2, 3))`               = isVEQ(1:3, c(1, 2, 3))              ,
       `lacksALL(Blank., Combo.)`             = lacksALL(Blank., Combo.)            ,
       `lacksANY(Blank., Combo.)`             = lacksANY(Blank., Combo.)            ,
       `lacksMANY(Blank., Combo.)`            = lacksMANY(Blank., Combo.)           ,
       `lacksNONE(Blank., Combo.)`            = lacksNONE(Blank., Combo.)           ,
       `lacksONE(Blank., Combo.)`             = lacksONE(Blank., Combo.)            ,
       `lacksSOME(Blank., Combo.)`            = lacksSOME(Blank., Combo.)           ,
       `lacksTWO(Blank., Combo.)`             = lacksTWO(Blank., Combo.)            ,
       `manyBL(c(Blank., letters))`           = manyBL(c(Blank., letters))          ,
       `manyDIF("a", c(Blank., NA, letters))` = manyDIF("a", c(Blank., NA, letters)),
       `manyEQ(NA, c(Blank., NA, letters))`   = manyEQ(NA, c(Blank., NA, letters))  ,
       `manyF(c(list(Blank.), Combo.))`       = manyF(c(list(Blank.), Combo.))      ,
       `manyGE("a", c(Blank., NA, letters))`  = manyGE("a", c(Blank., NA, letters)) ,
       `manyGT("a", c(Blank., NA, letters))`  = manyGT("a", c(Blank., NA, letters)) ,
       `manyIN(NULL, Blank., Combo.)`         = manyIN(NULL, Blank., Combo.)        ,
       `manyLE("a", c(Blank., NA, letters))`  = manyLE("a", c(Blank., NA, letters)) ,
       `manyLG(c(NA, T, F))`                  = manyLG(c(NA, T, F))                 ,
       `manyLT("a", c(Blank., NA, letters))`  = manyLT("a", c(Blank., NA, letters)) ,
       `manyMF(NULL, Blank., Combo.)`         = manyMF(NULL, Blank., Combo.)        ,
       `manyNAS(c(Blank., NA, letters))`      = manyNAS(c(Blank., NA, letters))     ,
       `manyNAS(ChrMat.)`                     = manyNAS(ChrMat.)                    ,
       `manyOKS(c(Blank., NA, letters))`      = manyOKS(c(Blank., NA, letters))     ,
       `manyOKS(ChrMat.)`                     = manyOKS(ChrMat.)                    ,
       `manyT(c(list(Blank.), Combo.))`       = manyT(c(list(Blank.), Combo.))      ,
       `manyTF(c(list(Blank.), Combo.))`      = manyTF(c(list(Blank.), Combo.))     ,
       `msgERR(non.existent.variable)`        = msgERR(non.existent.variable)       ,
       `msgERR(pi)`                           = msgERR(pi)                          ,
       `nBL(c(list(Blank.), Combo.))`         = nBL(c(list(Blank.), Combo.))        ,
       `nF(c(list(Blank.), Combo.))`          = nF(c(list(Blank.), Combo.))         ,
       `nHAS(Blank., Combo.)`                 = nHAS(Blank., Combo.)                ,
       `nIN(NULL, Blank., Combo.)`            = nIN(NULL, Blank., Combo.)           ,
       `nLACKS(Blank., Combo.)`               = nLACKS(Blank., Combo.)              ,
       `nMF(NULL, Blank., Combo.)`            = nMF(NULL, Blank., Combo.)           ,
       `nNAS(ChrMat.)`                        = nNAS(ChrMat.)                       ,
       `nOKS(ChrMat.)`                        = nOKS(ChrMat.)                       ,
       `noneBL(c(Blank., letters))`           = noneBL(c(Blank., letters))          ,
       `noneDIF("a", c(Blank., NA, letters))` = noneDIF("a", c(Blank., NA, letters)),
       `noneEQ(NA, c(Blank., NA, letters))`   = noneEQ(NA, c(Blank., NA, letters))  ,
       `noneF(c(list(Blank.), Combo.))`       = noneF(c(list(Blank.), Combo.))      ,
       `noneGE("a", c(Blank., NA, letters))`  = noneGE("a", c(Blank., NA, letters)) ,
       `noneGT("a", c(Blank., NA, letters))`  = noneGT("a", c(Blank., NA, letters)) ,
       `noneIN(NULL, Blank., Combo.)`         = noneIN(NULL, Blank., Combo.)        ,
       `noneLE("a", c(Blank., NA, letters))`  = noneLE("a", c(Blank., NA, letters)) ,
       `noneLG(c(NA, T, F))`                  = noneLG(c(NA, T, F))                 ,
       `noneLT("a", c(Blank., NA, letters))`  = noneLT("a", c(Blank., NA, letters)) ,
       `noneMF(NULL, Blank., Combo.)`         = noneMF(NULL, Blank., Combo.)        ,
       `noneNAS(c(Blank., NA, letters))`      = noneNAS(c(Blank., NA, letters))     ,
       `noneNAS(ChrMat.)`                     = noneNAS(ChrMat.)                    ,
       `noneOKS(c(Blank., NA, letters))`      = noneOKS(c(Blank., NA, letters))     ,
       `noneOKS(ChrMat.)`                     = noneOKS(ChrMat.)                    ,
       `noneT(c(list(Blank.), Combo.))`       = noneT(c(list(Blank.), Combo.))      ,
       `noneTF(c(list(Blank.), Combo.))`      = noneTF(c(list(Blank.), Combo.))     ,
       `notBL("")`                            = notBL("")                           ,
       `notBL("a")`                           = notBL("a")                          ,
       `notBL(c("", ""))`                     = notBL(c("", ""))                    ,
       `notBL(ChrMat.)`                       = notBL(ChrMat.)                      ,
       `notBL(NA)`                            = notBL(NA)                           ,
       `notBL1("")`                           = notBL1("")                          ,
       `notBL1("a")`                          = notBL1("a")                         ,
       `notBL1(c("", ""))`                    = notBL1(c("", ""))                   ,
       `notBL1(ChrMat.)`                      = notBL1(ChrMat.)                     ,
       `notBL1(NA)`                           = notBL1(NA)                          ,
       `notDIF("", "")`                       = notDIF("", "")                      ,
       `notDIF("word", 7)`                    = notDIF("word", 7)                   ,
       `notDIF(ChrMat., ChrMat.)`             = notDIF(ChrMat., ChrMat.)            ,
       `notDIF(NA, NA)`                       = notDIF(NA, NA)                      ,
       `notDIF1("", "")`                      = notDIF1("", "")                     ,
       `notDIF1("word", 7)`                   = notDIF1("word", 7)                  ,
       `notDIF1(ChrMat., ChrMat.)`            = notDIF1(ChrMat., ChrMat.)           ,
       `notDIF1(NA, NA)`                      = notDIF1(NA, NA)                     ,
       `notEQ("", "")`                        = notEQ("", "")                       ,
       `notEQ("word", 7)`                     = notEQ("word", 7)                    ,
       `notEQ(ChrMat., ChrMat.)`              = notEQ(ChrMat., ChrMat.)             ,
       `notEQ(NA, NA)`                        = notEQ(NA, NA)                       ,
       `notEQ1("", "")`                       = notEQ1("", "")                      ,
       `notEQ1("word", 7)`                    = notEQ1("word", 7)                   ,
       `notEQ1(ChrMat., ChrMat.)`             = notEQ1(ChrMat., ChrMat.)            ,
       `notEQ1(NA, NA)`                       = notEQ1(NA, NA)                      ,
       `notERR(non.existent.variable)`        = notERR(non.existent.variable)       ,
       `notERR(pi)`                           = notERR(pi)                          ,
       `notF(c(T, F))`                        = notF(c(T, F))                       ,
       `notF(ChrMat.)`                        = notF(ChrMat.)                       ,
       `notF(NA)`                             = notF(NA)                            ,
       `notF(T)`                              = notF(T)                             ,
       `notF(T)`                              = notF(T)                             ,
       `notF1(c(T, F))`                       = notF1(c(T, F))                      ,
       `notF1(ChrMat.)`                       = notF1(ChrMat.)                      ,
       `notF1(F)`                             = notF1(F)                            ,
       `notF1(NA)`                            = notF1(NA)                           ,
       `notF1(T)`                             = notF1(T)                            ,
       `notGE("a", "b")`                      = notGE("a", "b")                     ,
       `notGE("b", "a")`                      = notGE("b", "a")                     ,
       `notGE(1, 1)`                          = notGE(1, 1)                         ,
       `notGE(ChrMat., ChrMat.)`              = notGE(ChrMat., ChrMat.)             ,
       `notGE1("a", "b")`                     = notGE1("a", "b")                    ,
       `notGE1("b", "a")`                     = notGE1("b", "a")                    ,
       `notGE1(1, 1)`                         = notGE1(1, 1)                        ,
       `notGE1(ChrMat., ChrMat.)`             = notGE1(ChrMat., ChrMat.)            ,
       `notGT("a", "b")`                      = notGT("a", "b")                     ,
       `notGT("b", "a")`                      = notGT("b", "a")                     ,
       `notGT(1, 1)`                          = notGT(1, 1)                         ,
       `notGT(ChrMat., ChrMat.)`              = notGT(ChrMat., ChrMat.)             ,
       `notGT1("a", "b")`                     = notGT1("a", "b")                    ,
       `notGT1("b", "a")`                     = notGT1("b", "a")                    ,
       `notGT1(1, 1)`                         = notGT1(1, 1)                        ,
       `notGT1(ChrMat., ChrMat.)`             = notGT1(ChrMat., ChrMat.)            ,
       `notIN(1, "", "a", 1:2)`               = notIN(1, "", "a", 1:2)              ,
       `notIN(1, "a", letters)`               = notIN(1, "a", letters)              ,
       `notIN(NULL, Blank., Combo.)`          = notIN(NULL, Blank., Combo.)         ,
       `notIN1(1, "", "a", 1:2)`              = notIN1(1, "", "a", 1:2)             ,
       `notIN1(1, "a", letters)`              = notIN1(1, "a", letters)             ,
       `notIN1(NULL, Blank., Combo.)`         = notIN1(NULL, Blank., Combo.)        ,
       `notLE("a", "b")`                      = notLE("a", "b")                     ,
       `notLE("b", "a")`                      = notLE("b", "a")                     ,
       `notLE(1, 1)`                          = notLE(1, 1)                         ,
       `notLE(ChrMat., ChrMat.)`              = notLE(ChrMat., ChrMat.)             ,
       `notLE1("a", "b")`                     = notLE1("a", "b")                    ,
       `notLE1("b", "a")`                     = notLE1("b", "a")                    ,
       `notLE1(1, 1)`                         = notLE1(1, 1)                        ,
       `notLE1(ChrMat., ChrMat.)`             = notLE1(ChrMat., ChrMat.)            ,
       `notLG1(c(T, F))`                      = notLG1(c(T, F))                     ,
       `notLG1(ChrMat.)`                      = notLG1(ChrMat.)                     ,
       `notLG1(F)`                            = notLG1(F)                           ,
       `notLG1(NA)`                           = notLG1(NA)                          ,
       `notLG1(T)`                            = notLG1(T)                           ,
       `notLT("a", "b")`                      = notLT("a", "b")                     ,
       `notLT("b", "a")`                      = notLT("b", "a")                     ,
       `notLT(1, 1)`                          = notLT(1, 1)                         ,
       `notLT(ChrMat., ChrMat.)`              = notLT(ChrMat., ChrMat.)             ,
       `notLT1("a", "b")`                     = notLT1("a", "b")                    ,
       `notLT1("b", "a")`                     = notLT1("b", "a")                    ,
       `notLT1(1, 1)`                         = notLT1(1, 1)                        ,
       `notLT1(ChrMat., ChrMat.)`             = notLT1(ChrMat., ChrMat.)            ,
       `notMF(1, "", "a", 1:2)`               = notMF(1, "", "a", 1:2)              ,
       `notMF(1, "a", letters)`               = notMF(1, "a", letters)              ,
       `notMF(NULL, Blank., Combo.)`          = notMF(NULL, Blank., Combo.)         ,
       `notMF1(1, "", "a", 1:2)`              = notMF1(1, "", "a", 1:2)             ,
       `notMF1(1, "a", letters)`              = notMF1(1, "a", letters)             ,
       `notMF1(NULL, Blank., Combo.)`         = notMF1(NULL, Blank., Combo.)        ,
       `notNA1(1)`                            = notNA1(1)                           ,
       `notNA1(c(NA, NA))`                    = notNA1(c(NA, NA))                   ,
       `notNA1(ChrMat.)`                      = notNA1(ChrMat.)                     ,
       `notNA1(NA)`                           = notNA1(NA)                          ,
       `notNAS(c(NA, NA)), notNAS(ChrMat.)`   = notNAS(c(NA, NA)), notNAS(ChrMat.)  ,
       `notNAS(NA), notNAS(1)`                = notNAS(NA), notNAS(1)               ,
       `notOK1(1)`                            = notOK1(1)                           ,
       `notOK1(c(NA, NA))`                    = notOK1(c(NA, NA))                   ,
       `notOK1(ChrMat.)`                      = notOK1(ChrMat.)                     ,
       `notOK1(NA)`                           = notOK1(NA)                          ,
       `notOKS(c(NA, NA)), notOKS(ChrMat.)`   = notOKS(c(NA, NA)), notOKS(ChrMat.)  ,
       `notOKS(NA), notOKS(1)`                = notOKS(NA), notOKS(1)               ,
       `notSEQ(1, letters)`                   = notSEQ(1, letters)                  ,
       `notSEQ(1, letters)`                   = notSEQ(1, letters)                  ,
       `notSEQ(1:3, c(1, 2, 3, 2, 1))`        = notSEQ(1:3, c(1, 2, 3, 2, 1))       ,
       `notSEQ(1:3, c(1, 2, 3, 2, 1))`        = notSEQ(1:3, c(1, 2, 3, 2, 1))       ,
       `notSEQ(1:3, c(1, 2, 3))`              = notSEQ(1:3, c(1, 2, 3))             ,
       `notSEQ(1:3, c(1, 2, 3))`              = notSEQ(1:3, c(1, 2, 3))             ,
       `notT(c(T, F))`                        = notT(c(T, F))                       ,
       `notT(ChrMat.)`                        = notT(ChrMat.)                       ,
       `notT(NA)`                             = notT(NA)                            ,
       `notT(T)`                              = notT(T)                             ,
       `notT(T)`                              = notT(T)                             ,
       `notT1(c(T, F))`                       = notT1(c(T, F))                      ,
       `notT1(ChrMat.)`                       = notT1(ChrMat.)                      ,
       `notT1(F)`                             = notT1(F)                            ,
       `notT1(NA)`                            = notT1(NA)                           ,
       `notT1(T)`                             = notT1(T)                            ,
       `notTF(c(T, F))`                       = notTF(c(T, F))                      ,
       `notTF(ChrMat.)`                       = notTF(ChrMat.)                       ,
       `notTF(NA)`                            = notTF(NA)                           ,
       `notTF(T)`                             = notTF(T)                            ,
       `notTF(T)`                             = notTF(T)                            ,
       `notTF1(c(T, F))`                      = notTF1(c(T, F))                     ,
       `notTF1(ChrMat.)`                      = notTF1(ChrMat.)                     ,
       `notTF1(F)`                            = notTF1(F)                           ,
       `notTF1(NA)`                           = notTF1(NA)                          ,
       `notTF1(T)`                            = notTF1(T)                           ,
       `notVEC(1, letters)`                   = notVEC(1, letters)                  ,
       `notVEC(1, letters)`                   = notVEC(1, letters)                  ,
       `notVEQ(1:3, c(1, 2, 3, 2, 1))`        = notVEQ(1:3, c(1, 2, 3, 2, 1))       ,
       `notVEQ(1:3, c(1, 2, 3, 2, 1))`        = notVEQ(1:3, c(1, 2, 3, 2, 1))       ,
       `notVEQ(1:3, c(1, 2, 3))`              = notVEQ(1:3, c(1, 2, 3))             ,
       `notVEQ(1:3, c(1, 2, 3))`              = notVEQ(1:3, c(1, 2, 3))             ,
       `nT(c(list(Blank.), Combo.))`          = nT(c(list(Blank.), Combo.))         ,
       `nTF(c(list(Blank.), Combo.))`         = nTF(c(list(Blank.), Combo.))        ,
       `NULL \%IN\% abc`                        = NULL \%IN\% abc                       ,
       `NULL \%OUT\% abc`                       = NULL \%OUT\% abc                      ,
       `oneBL(c(Blank., letters))`            = oneBL(c(Blank., letters))           ,
       `oneDIF("a", c(Blank., NA, letters))`  = oneDIF("a", c(Blank., NA, letters)) ,
       `oneEQ(NA, c(Blank., NA, letters))`    = oneEQ(NA, c(Blank., NA, letters))   ,
       `oneF(c(list(Blank.), Combo.))`        = oneF(c(list(Blank.), Combo.))       ,
       `oneGE("a", c(Blank., NA, letters))`   = oneGE("a", c(Blank., NA, letters))  ,
       `oneGT("a", c(Blank., NA, letters))`   = oneGT("a", c(Blank., NA, letters))  ,
       `oneIN(NULL, Blank., Combo.)`          = oneIN(NULL, Blank., Combo.)         ,
       `oneLE("a", c(Blank., NA, letters))`   = oneLE("a", c(Blank., NA, letters))  ,
       `oneLG(c(NA, T, F))`                   = oneLG(c(NA, T, F))                  ,
       `oneLT("a", c(Blank., NA, letters))`   = oneLT("a", c(Blank., NA, letters))  ,
       `oneMF(NULL, Blank., Combo.)`          = oneMF(NULL, Blank., Combo.)         ,
       `oneNAS(c(Blank., NA, letters))`       = oneNAS(c(Blank., NA, letters))      ,
       `oneNAS(ChrMat.)`                      = oneNAS(ChrMat.)                     ,
       `oneOKS(c(Blank., NA, letters))`       = oneOKS(c(Blank., NA, letters))      ,
       `oneOKS(ChrMat.)`                      = oneOKS(ChrMat.)                     ,
       `oneT(c(list(Blank.), Combo.))`        = oneT(c(list(Blank.), Combo.))       ,
       `oneTF(c(list(Blank.), Combo.))`       = oneTF(c(list(Blank.), Combo.))      ,
       `someBL(c(Blank., letters))`           = someBL(c(Blank., letters))          ,
       `someDIF("a", c(Blank., NA, letters))` = someDIF("a", c(Blank., NA, letters)),
       `someEQ(NA, c(Blank., NA, letters))`   = someEQ(NA, c(Blank., NA, letters))  ,
       `someF(c(list(Blank.), Combo.))`       = someF(c(list(Blank.), Combo.))      ,
       `someGE("a", c(Blank., NA, letters))`  = someGE("a", c(Blank., NA, letters)) ,
       `someGT("a", c(Blank., NA, letters))`  = someGT("a", c(Blank., NA, letters)) ,
       `someIN(NULL, Blank., Combo.)`         = someIN(NULL, Blank., Combo.)        ,
       `someLE("a", c(Blank., NA, letters))`  = someLE("a", c(Blank., NA, letters)) ,
       `someLG(c(NA, T, F))`                  = someLG(c(NA, T, F))                 ,
       `someLT("a", c(Blank., NA, letters))`  = someLT("a", c(Blank., NA, letters)) ,
       `someMF(NULL, Blank., Combo.)`         = someMF(NULL, Blank., Combo.)        ,
       `someNAS(c(Blank., NA, letters))`      = someNAS(c(Blank., NA, letters))     ,
       `someNAS(ChrMat.)`                     = someNAS(ChrMat.)                    ,
       `someOKS(c(Blank., NA, letters))`      = someOKS(c(Blank., NA, letters))     ,
       `someOKS(ChrMat.)`                     = someOKS(ChrMat.)                    ,
       `someT(c(list(Blank.), Combo.))`       = someT(c(list(Blank.), Combo.))      ,
       `someTF(c(list(Blank.), Combo.))`      = someTF(c(list(Blank.), Combo.))     ,
       `TRUE \%.and.\% 42`                      = TRUE \%.and.\% 42                     ,
       `TRUE \%.and.\% TRUE`                    = TRUE \%.and.\% TRUE                   ,
       `TRUE \%.nor.\% 42`                      = TRUE \%.nor.\% 42                     ,
       `TRUE \%.nor.\% TRUE`                    = TRUE \%.nor.\% TRUE                   ,
       `TRUE \%.xor.\% 42`                      = TRUE \%.xor.\% 42                     ,
       `TRUE \%.xor.\% TRUE`                    = TRUE \%.xor.\% TRUE                   ,
       `TRUE \%.or.\% 42`                       = TRUE \%.or.\% 42                      ,
       `TRUE \%.or.\% TRUE`                     = TRUE \%.or.\% TRUE                    ,
       `twoBL(c(Blank., letters))`            = twoBL(c(Blank., letters))           ,
       `twoDIF("a", c(Blank., NA, letters))`  = twoDIF("a", c(Blank., NA, letters)) ,
       `twoEQ(NA, c(Blank., NA, letters))`    = twoEQ(NA, c(Blank., NA, letters))   ,
       `twoF(c(list(Blank.), Combo.))`        = twoF(c(list(Blank.), Combo.))       ,
       `twoGE("a", c(Blank., NA, letters))`   = twoGE("a", c(Blank., NA, letters))  ,
       `twoGT("a", c(Blank., NA, letters))`   = twoGT("a", c(Blank., NA, letters))  ,
       `twoIN(NULL, Blank., Combo.)`          = twoIN(NULL, Blank., Combo.)         ,
       `twoLE("a", c(Blank., NA, letters))`   = twoLE("a", c(Blank., NA, letters))  ,
       `twoLG(c(NA, T, F))`                   = twoLG(c(NA, T, F))                  ,
       `twoLT("a", c(Blank., NA, letters))`   = twoLT("a", c(Blank., NA, letters))  ,
       `twoMF(NULL, Blank., Combo.)`          = twoMF(NULL, Blank., Combo.)         ,
       `twoNAS(c(Blank., NA, letters))`       = twoNAS(c(Blank., NA, letters))      ,
       `twoNAS(ChrMat.)`                      = twoNAS(ChrMat.)                     ,
       `twoOKS(c(Blank., NA, letters))`       = twoOKS(c(Blank., NA, letters))      ,
       `twoOKS(ChrMat.)`                      = twoOKS(ChrMat.)                     ,
       `twoT(c(list(Blank.), Combo.))`        = twoT(c(list(Blank.), Combo.))       ,
       `twoTF(c(list(Blank.), Combo.))`       = twoTF(c(list(Blank.), Combo.))      )
}
egFailsafe()
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{evals}},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{nis}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}

Other logicals: 
\code{\link{evals}},
\code{\link{meets}()}

Other errs: 
\code{\link{checker}}
}
\concept{errs}
\concept{extensions}
\concept{logicals}
