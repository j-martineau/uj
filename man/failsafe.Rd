% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/failsafe.R
\encoding{UTF-8}
\name{failsafe}
\alias{failsafe}
\alias{is_err}
\alias{not_err}
\alias{msg_err}
\alias{make_err}
\alias{fs_def}
\alias{fs_nll}
\alias{fs_scl}
\alias{fs_t}
\alias{fs_f}
\alias{fs_tf}
\alias{fs_na}
\alias{fs_ok}
\alias{fs_bl}
\alias{fs_lg}
\alias{fs_vec}
\alias{fs_null}
\alias{scl_bl}
\alias{scl_t}
\alias{scl_f}
\alias{scl_tf}
\alias{scl_lg}
\alias{scl_na}
\alias{vec_bl}
\alias{vec_t}
\alias{vec_f}
\alias{vec_tf}
\alias{vec_na}
\alias{fs_or}
\alias{or_f}
\alias{or_t}
\alias{or_bl}
\alias{or_c0}
\alias{or_i0}
\alias{or_l0}
\alias{or_n0}
\alias{or_na}
\alias{or_nac}
\alias{or_nai}
\alias{or_nal}
\alias{or_nar}
\alias{or_null}
\alias{is_id}
\alias{not_id}
\alias{is_IN}
\alias{is_MF}
\alias{HAS}
\alias{LACKS}
\alias{is_EQ}
\alias{is_GE}
\alias{is_GT}
\alias{is_LE}
\alias{is_LT}
\alias{is_DIF}
\alias{is_F}
\alias{is_T}
\alias{is_BL}
\alias{is_TF}
\alias{is_NAV}
\alias{is_OKV}
\alias{is_LG}
\alias{is_in}
\alias{is_mf}
\alias{has}
\alias{not}
\alias{lacks}
\alias{is_eq}
\alias{is_ge}
\alias{is_gt}
\alias{is_le}
\alias{is_lt}
\alias{is_dif}
\alias{is_f}
\alias{is_t}
\alias{is_bl}
\alias{is_tf}
\alias{is_nav}
\alias{is_okv}
\alias{is_seq}
\alias{is_veq}
\alias{is_sdif}
\alias{is_vdif}
\alias{OR}
\alias{AND}
\alias{XOR}
\alias{NOR}
\alias{or}
\alias{and}
\alias{one}
\alias{nor}
\alias{not_IN}
\alias{not_MF}
\alias{not_HAS}
\alias{not_LACKS}
\alias{not_EQ}
\alias{not_GE}
\alias{not_GT}
\alias{not_LE}
\alias{not_LT}
\alias{not_DIF}
\alias{not_F}
\alias{not_T}
\alias{not_TF}
\alias{not_BL}
\alias{not_NAV}
\alias{not_OKV}
\alias{not_LG}
\alias{not_in}
\alias{not_mf}
\alias{not_has}
\alias{not_lacks}
\alias{not_eq}
\alias{not_ge}
\alias{not_gt}
\alias{not_le}
\alias{not_lt}
\alias{not_dif}
\alias{not_f}
\alias{not_t}
\alias{not_tf}
\alias{not_bl}
\alias{not_nav}
\alias{not_okv}
\alias{not_seq}
\alias{not_veq}
\alias{not_sdif}
\alias{not_vdif}
\alias{n_in}
\alias{n_mf}
\alias{n_has}
\alias{n_lacks}
\alias{n_eq}
\alias{n_ge}
\alias{n_gt}
\alias{n_le}
\alias{n_lt}
\alias{n_dif}
\alias{n_f}
\alias{n_t}
\alias{n_tf}
\alias{n_bl}
\alias{n_nav}
\alias{n_okv}
\alias{none_f}
\alias{none_t}
\alias{none_tf}
\alias{none_bl}
\alias{none_eq}
\alias{none_ge}
\alias{none_gt}
\alias{none_le}
\alias{none_lt}
\alias{none_in}
\alias{none_mf}
\alias{none_dif}
\alias{none_nav}
\alias{none_okv}
\alias{has_none}
\alias{lacks_none}
\alias{any_f}
\alias{any_t}
\alias{any_bl}
\alias{any_eq}
\alias{any_ge}
\alias{any_gt}
\alias{any_in}
\alias{any_le}
\alias{any_lt}
\alias{any_mf}
\alias{any_tf}
\alias{any_dif}
\alias{any_nav}
\alias{any_okv}
\alias{has_any}
\alias{lacks_any}
\alias{one_f}
\alias{one_t}
\alias{one_bl}
\alias{one_eq}
\alias{one_ge}
\alias{one_gt}
\alias{one_in}
\alias{one_le}
\alias{one_lt}
\alias{one_mf}
\alias{one_tf}
\alias{one_dif}
\alias{one_nav}
\alias{one_okv}
\alias{has_one}
\alias{lacks_one}
\alias{all_f}
\alias{all_t}
\alias{all_bl}
\alias{all_eq}
\alias{all_ge}
\alias{all_gt}
\alias{all_in}
\alias{all_le}
\alias{all_lt}
\alias{all_mf}
\alias{all_tf}
\alias{all_dif}
\alias{all_nav}
\alias{all_okv}
\alias{has_all}
\alias{lacks_all}
\alias{some_f}
\alias{some_t}
\alias{some_bl}
\alias{some_eq}
\alias{some_le}
\alias{some_ge}
\alias{some_gt}
\alias{some_in}
\alias{some_lt}
\alias{some_mf}
\alias{some_tf}
\alias{some_dif}
\alias{some_nav}
\alias{some_okv}
\alias{has_some}
\alias{lacks_some}
\alias{two_f}
\alias{two_t}
\alias{two_bl}
\alias{two_eq}
\alias{two_ge}
\alias{two_gt}
\alias{two_in}
\alias{two_le}
\alias{two_lt}
\alias{two_mf}
\alias{two_tf}
\alias{two_dif}
\alias{two_nav}
\alias{two_okv}
\alias{has_two}
\alias{lacks_two}
\alias{many_f}
\alias{many_t}
\alias{many_bl}
\alias{many_eq}
\alias{many_ge}
\alias{many_gt}
\alias{many_in}
\alias{many_le}
\alias{many_lt}
\alias{many_mf}
\alias{many_tf}
\alias{many_dif}
\alias{many_nav}
\alias{many_okv}
\alias{has_many}
\alias{lacks_many}
\alias{\%.IN.\%}
\alias{\%.MF.\%}
\alias{\%.EQ.\%}
\alias{\%.GE.\%}
\alias{\%.GT.\%}
\alias{\%.LE.\%}
\alias{\%.LT.\%}
\alias{\%.HAS.\%}
\alias{\%.DIF.\%}
\alias{\%.LACKS.\%}
\alias{\%.in.\%}
\alias{\%.mf.\%}
\alias{\%.eq.\%}
\alias{\%.ge.\%}
\alias{\%.gt.\%}
\alias{\%.le.\%}
\alias{\%.lt.\%}
\alias{\%.has.\%}
\alias{\%.dif.\%}
\alias{\%.lacks.\%}
\alias{\%.seq.\%}
\alias{\%.veq.\%}
\alias{\%.neq.\%}
\alias{\%.sdif.\%}
\alias{\%.vdif.\%}
\alias{\%.ndif.\%}
\alias{\%.OR.\%}
\alias{\%.AND.\%}
\alias{\%.XOR.\%}
\alias{\%.NOR.\%}
\alias{\%.or.\%}
\alias{\%.and.\%}
\alias{\%.xor.\%}
\alias{\%.nor.\%}
\title{failsafe functions that \strong{always} return a valid object.}
\usage{
failsafe(X, Def = "uj.failsafe.err")

is_err(X)

not_err(X)

msg_err(X)

make_err()

fs_def(X)

fs_nll(X)

fs_scl(X, Val)

fs_t(X)

fs_f(X)

fs_tf(X)

fs_na(X)

fs_ok(X)

fs_bl(X)

fs_lg(X)

fs_vec(X, Val)

fs_null(X)

scl_bl(X)

scl_t(X)

scl_f(X)

scl_tf(X)

scl_lg(X)

scl_na(X)

vec_bl(X)

vec_t(X)

vec_f(X)

vec_tf(X)

vec_na(X)

fs_or(X, Or = NULL)

or_f(X)

or_t(X)

or_bl(X)

or_c0(X)

or_i0(X)

or_l0(X)

or_n0(X)

or_na(X)

or_nac(X)

or_nai(X)

or_nal(X)

or_nar(X)

or_null(X)

is_id(X, Y)

not_id(X, Y)

is_IN(X, ...)

is_MF(X, ...)

HAS(X, Y)

LACKS(X, Y)

is_EQ(X, Y)

is_GE(X, Y)

is_GT(X, Y)

is_LE(X, Y)

is_LT(X, Y)

is_DIF(X, Y)

is_F(X)

is_T(X)

is_BL(X)

is_TF(X)

is_NAV(X)

is_OKV(X)

is_LG(X)

is_in(X, ...)

is_mf(X, ...)

has(X, Y)

not(X)

lacks(X, Y)

is_eq(X, Y)

is_ge(X, Y)

is_gt(X, Y)

is_le(X, Y)

is_lt(X, Y)

is_dif(X, Y)

is_f(X)

is_t(X)

is_bl(X)

is_tf(X)

is_nav(X)

is_okv(X)

is_seq(X, Y)

is_veq(X, Y)

is_sdif(X, Y)

is_vdif(X, Y)

OR(X, Y)

AND(X, Y)

XOR(X, Y)

NOR(X, Y)

or(X, Y)

and(X, Y)

one(X, Y)

nor(X, Y)

not_IN(X, ...)

not_MF(X, ...)

not_HAS(X, Y)

not_LACKS(X, Y)

not_EQ(X, Y)

not_GE(X, Y)

not_GT(X, Y)

not_LE(X, Y)

not_LT(X, Y)

not_DIF(X, Y)

not_F(X)

not_T(X)

not_TF(X)

not_BL(X)

not_NAV(X)

not_OKV(X)

not_LG(X)

not_in(X, ...)

not_mf(X, ...)

not_has(X, Y)

not_lacks(X, Y)

not_eq(X, Y)

not_ge(X, Y)

not_gt(X, Y)

not_le(X, Y)

not_lt(X, Y)

not_dif(X, Y)

not_f(X)

not_t(X)

not_tf(X)

not_bl(X)

not_nav(X)

not_okv(X)

not_seq(X, Y)

not_veq(X, Y)

not_sdif(X, Y)

not_vdif(X, Y)

n_in(X, ...)

n_mf(X, ...)

n_has(X, Y)

n_lacks(X, Y)

n_eq(X, Y)

n_ge(X, Y)

n_gt(X, Y)

n_le(X, Y)

n_lt(X, Y)

n_dif(X, Y)

n_f(X)

n_t(X)

n_tf(X)

n_bl(X)

n_nav(X)

n_okv(X)

none_f(X)

none_t(X)

none_tf(X)

none_bl(X)

none_eq(X, Y)

none_ge(X, Y)

none_gt(X, Y)

none_le(X, Y)

none_lt(X, Y)

none_in(X, ...)

none_mf(X, ...)

none_dif(X, Y)

none_nav(X)

none_okv(X)

has_none(X, Y)

lacks_none(X, Y)

any_f(X)

any_t(X)

any_bl(X)

any_eq(X, Y)

any_ge(X, Y)

any_gt(X, Y)

any_in(X, ...)

any_le(X, Y)

any_lt(X, Y)

any_mf(X, ...)

any_tf(X)

any_dif(X, Y)

any_nav(X)

any_okv(X)

has_any(X, Y)

lacks_any(X, Y)

one_f(X)

one_t(X)

one_bl(X)

one_eq(X, Y)

one_ge(X, Y)

one_gt(X, Y)

one_in(X, ...)

one_le(X, Y)

one_lt(X, Y)

one_mf(X, ...)

one_tf(X)

one_dif(X, Y)

one_nav(X)

one_okv(X)

has_one(X, Y)

lacks_one(X, Y)

all_f(X)

all_t(X)

all_bl(X)

all_eq(X, Y)

all_ge(X, Y)

all_gt(X, Y)

all_in(X, ...)

all_le(X, Y)

all_lt(X, Y)

all_mf(X, ...)

all_tf(X)

all_dif(X, Y)

all_nav(X)

all_okv(X)

has_all(X, Y)

lacks_all(X, Y)

some_f(X)

some_t(X)

some_bl(X)

some_eq(X, Y)

some_le(X, Y)

some_ge(X, Y)

some_gt(X, Y)

some_in(X, ...)

some_lt(X, Y)

some_mf(X, ...)

some_tf(X)

some_dif(X, Y)

some_nav(X)

some_okv(X)

has_some(X, Y)

lacks_some(X, Y)

two_f(X)

two_t(X)

two_bl(X)

two_eq(X, Y)

two_ge(X, Y)

two_gt(X, Y)

two_in(X, ...)

two_le(X, Y)

two_lt(X, Y)

two_mf(X, ...)

two_tf(X)

two_dif(X, Y)

two_nav(X)

two_okv(X)

has_two(X, Y)

lacks_two(X, Y)

many_f(X)

many_t(X)

many_bl(X)

many_eq(X, Y)

many_ge(X, Y)

many_gt(X, Y)

many_in(X, ...)

many_le(X, Y)

many_lt(X, Y)

many_mf(X, ...)

many_tf(X)

many_dif(X, Y)

many_nav(X)

many_okv(X)

has_many(X, Y)

lacks_many(X, Y)

X \%.IN.\% Y

X \%.MF.\% Y

X \%.EQ.\% Y

X \%.GE.\% Y

X \%.GT.\% Y

X \%.LE.\% Y

X \%.LT.\% Y

X \%.HAS.\% Y

X \%.DIF.\% Y

X \%.LACKS.\% Y

X \%.in.\% Y

X \%.mf.\% Y

X \%.eq.\% Y

X \%.ge.\% Y

X \%.gt.\% Y

X \%.le.\% Y

X \%.lt.\% Y

X \%.has.\% Y

X \%.dif.\% Y

X \%.lacks.\% Y

X \%.seq.\% Y

X \%.veq.\% Y

X \%.neq.\% Y

X \%.sdif.\% Y

X \%.vdif.\% Y

X \%.ndif.\% Y

X \%.OR.\% Y

X \%.AND.\% Y

X \%.XOR.\% Y

X \%.NOR.\% Y

X \%.or.\% Y

X \%.and.\% Y

X \%.xor.\% Y

X \%.nor.\% Y
}
\arguments{
\item{Def}{A character scalar default error message if forcing evaluation produces an error. If not a character scalar, it is replaced with the default.}

\item{Val, Or, X, Y}{Any object/expression to be evaluated, whether or not doing so produces an error.}

\item{...}{Any objects/expressions to be evaluated, whether or not doing so produces an error.}
}
\value{
A logical scalar or vector.
}
\description{
Evaluate objects, test if an object has certain properties, and conduct binary logical operations safely. these functions never stop execution; they always produce a valid result, even if that result is an error object.
}
\details{
\strong{Error management functions}
\cr\cr These functions evaluate generate, check for, and manage error objects.
\tabular{ll}{  \code{make_err}   \tab generate object of class \code{'simpleError'}.     \cr
  \code{msg_err}    \tab get error message, if any; otherwise, \code{NULL}. \cr
  \code{not_err}    \tab Does evaluating \code{X} not produce an error?.    \cr
  \code{is_err}     \tab Does evaluating \code{X} produce an error?           }
\cr \strong{failsafe check for classes of objects with values}
\tabular{ll}{  \code{failsafe}   \tab Returns \code{X} if identity evaluation does not_ cause an error. Returns
an error object otherwise with the attribute \code{stack = uj::callers()}. \cr   \tab   \cr
  \code{fs_null}    \tab \code{X} is \code{NULL}.                                                        \cr
  \code{fs_def}     \tab \code{X} is defined (not \code{NULL}).                                          \cr   \tab   \cr
  \code{fs_scl}     \tab \code{X} is scalar of a specific atomic value.                             \cr
  \code{fs_t}       \tab \code{X} is scalar \code{TRUE}.                                                 \cr
  \code{fs_f}       \tab \code{X} is scalar \code{FALSE}.                                                \cr
  \code{fs_na}      \tab \code{X} is scalar \code{NA}.                                                   \cr
  \code{fs_tf}      \tab \code{X} is scalar \code{TRUE} or scalar \code{FALSE}.                               \cr
  \code{scl_f}      \tab \code{X} is scalar \code{FALSE}                                                 \cr
  \code{scl_t}      \tab \code{X} is scalar \code{TRUE}                                                  \cr
  \code{scl_tf}     \tab \code{X} is scalar \code{TRUE} or \code{FALSE}.                                      \cr
  \code{scl_lg}     \tab \code{X} is scalar \code{TRUE}, \code{FALSE}, or \code{NA}.                               \cr
  \code{scl_bl}     \tab \code{X} is blank string scalar (\code{""}).                                    \cr
  \code{scl_na}     \tab \code{X} is scalar \code{NA}                                                    \cr   \tab   \cr
  \code{fs_vec}     \tab Elements of \code{X} are of a specific atomic value.                       \cr
  \code{vec_f}      \tab Elements of \code{X} are \code{FALSE}.                                          \cr
  \code{vec_t}      \tab Elements of \code{X} are \code{TRUE}.                                           \cr
  \code{vec_tf}     \tab Elements of \code{X} are \code{TRUE} or \code{FALSE}.                                \cr
  \code{vec_lg}     \tab Elements of \code{X} are \code{TRUE}, \code{FALSE}, or \code{NA}.                         \cr
  \code{vec_bl}     \tab Elements of \code{X} are blank strings.                                    \cr
  \code{vec_na}     \tab Elements of \code{X} are \code{NA}.                                               }
\strong{Forced-evaluation functions with conditional return values}
\cr\cr These functions \link[base:force]{force} evaluation of \code{X} returning values as shown in the following table with the first value returned when forcing evaluation does not produce an error and the second when it does:
\tabular{ll}{  \code{fs_or}    \tab \code{X} or something else if evaluating \code{X} produces an error \cr   \tab   \cr
  \code{or_f}     \tab \code{X} or \code{FALSE}                                            \cr
  \code{or_t}     \tab \code{X} or \code{TRUE}                                             \cr   \tab   \cr
  \code{or_c0}    \tab \code{X} or \code{character(0)}                                     \cr
  \code{or_i0}    \tab \code{X} or \code{integer(0)}                                       \cr
  \code{or_l0}    \tab \code{X} or \code{logical(0)}                                       \cr
  \code{or_n0}    \tab \code{X} or \code{numeric(0)}                                       \cr   \tab   \cr
  \code{or_bl}    \tab \code{X} or \code{""}                                               \cr   \tab   \cr
  \code{or_na}    \tab \code{X} or \code{NA}                                               \cr
  \code{or_nac}   \tab \code{X} or \code{NA_character_}                                    \cr
  \code{or_nai}   \tab \code{X} or \code{NA_integer_}                                      \cr
  \code{or_nal}   \tab \code{X} or \code{NA} (logical)                                     \cr
  \code{or_nar}   \tab \code{X} or \code{NA_real_}                                           }
\strong{Binary comparison functions}
\cr\cr These are binary functions that always produce either scalar \code{TRUE} or scalar \code{FALSE}. They return \code{TRUE} when two variables meet the conditions shown in the following table and \code{FALSE} in every other circumstance (where \code{fx} and \code{fy})
\tabular{ll}{  \verb{\%.is.\%}      \tab \code{failsafe(identical(X, Y))}                                  \cr
  \verb{\%.isnt.\%}    \tab \code{!(X \%.is.\% Y)}                                              \cr   \tab   \cr
  \verb{\%.in.\%}      \tab \code{sapply(failsafe(X \%in\% Y), isTRUE)}                         \cr
  \verb{\%.mf.\%}      \tab \code{!(X \%.in.\% Y)} (missing from)                               \cr
  \verb{\%.has.\%}     \tab \code{Y \%.in.\% X} (\code{X} has each \code{Y} value)                        \cr
  \verb{\%.lacks.\%}   \tab \code{Y \%.mf.\% X} (\code{X} lacks each \code{Y} value)                      \cr   \tab   \cr
  \verb{\%.eq.\%}      \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \code{X = Y}, otherwise \code{FALSE} \cr
  \verb{\%.ge.\%}      \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \verb{X ≥ Y}, otherwise \code{FALSE} \cr
  \verb{\%.gt.\%}      \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \code{X > Y}, otherwise \code{FALSE} \cr
  \verb{\%.le.\%}      \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \verb{X ≤ Y}, otherwise \code{FALSE} \cr
  \verb{\%.lt.\%}      \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \code{X < Y}, otherwise \code{FALSE} \cr
  \verb{\%.dif.\%}     \tab If \code{X} and \code{Y} match\eqn{^{(1)}}, \verb{X ≠ Y}, otherwise \code{TRUE}  \cr   \tab   \cr
  \verb{\%.seq.\%}     \tab \code{X} and \code{Y} are \code{\link[base]{setequal}}\eqn{^{(4)}}     \cr
  \verb{\%.veq.\%}     \tab \code{X} and \code{Y} are vector equal\eqn{^{(5)}}                     \cr
  \verb{\%.sdif.\%}    \tab \code{X} and \code{Y} are set different\eqn{^{(6)}}                    \cr
  \verb{\%.vdif.\%}    \tab \code{X} and \code{Y} are vector different\eqn{^{(7)}}                 \cr   \tab   \cr
  \verb{\%.or.\%}      \tab values of \code{X} \emph{and/or} \code{Y} are \code{TRUE}                        \cr
  \verb{\%.and.\%}     \tab values of \code{X} \emph{and} \code{Y} are \code{TRUE}                           \cr
  \verb{\%.xor.\%}     \tab values of \emph{either} \code{X} \emph{or} \code{Y} are \code{TRUE}                   \cr
  \verb{\%.nor.\%}     \tab values of \emph{neither} \code{X} \emph{nor} \code{Y} are \code{TRUE}                 \cr   \tab   \cr
  \verb{\%.IN.\%}      \tab if \code{X} is atomic scalar, \code{X \%.in.\% Y}, otherwise \code{FALSE}     \cr
  \verb{\%.MF.\%}      \tab \code{X} is atomic scalar and \code{X \%.mf.\% Y}                        \cr
  \verb{\%.HAS.\%}     \tab \code{Y} is atomic scalar and \code{X \%.has.\% Y}                       \cr
  \verb{\%.LACKS.\%}   \tab \code{Y} is atomic scalar and \code{X \%.lacks.\% Y}                     \cr   \tab   \cr
  \verb{\%.EQ.\%}      \tab \code{X} and \code{Y} are atomic scalar and \code{X = Y}  \eqn{^{(2)}}      \cr
  \verb{\%.GE.\%}      \tab \code{X} and \code{Y} are atomic scalar and \verb{X ≥ Y}  \eqn{^{(2)}}      \cr
  \verb{\%.GT.\%}      \tab \code{X} and \code{Y} are atomic scalar and \code{X > Y}  \eqn{^{(2)}}      \cr
  \verb{\%.LE.\%}      \tab \code{X} and \code{Y} are atomic scalar and \verb{X ≤ Y}  \eqn{^{(2)}}      \cr
  \verb{\%.LT.\%}      \tab \code{X} and \code{Y} are atomic scalar and \verb{X ≥ Y}  \eqn{^{(2)}}      \cr
  \verb{\%.DIF.\%}     \tab \code{X} and \code{Y} are \emph{not} atomic scalar equal  \eqn{^{(3)}}      \cr   \tab   \cr
  \verb{\%.OR.\%}      \tab \code{X} \emph{and/or} \code{Y} are scalar \code{TRUE}                           \cr
  \verb{\%.AND.\%}     \tab \code{X} \emph{and} \code{Y} are scalar \code{TRUE}                              \cr
  \verb{\%.XOR.\%}     \tab \emph{either} \code{X} \emph{or} \code{Y} is scalar \code{TRUE}                       \cr
  \verb{\%.NOR.\%}     \tab \emph{neither} \code{X} \emph{nor} \code{Y} is scalar \code{TRUE}                     \cr   \tab     }
\tabular{l}{  \eqn{^{(1)}} Of equal length and \link[=compatible]{compatible modes}.                                                       \cr
  \eqn{^{(2)}} Of \link[=compatible]{compatible modes} and meeting the (in)equality.                                           \cr
  \eqn{^{(3)}} not meeting the requirements of \verb{\%.eq0.\%}.                                                                      \cr
  \eqn{^{(4)}} atomic, of the same length, with the same values in the same order.                                             \cr
  \eqn{^{(5)}} atomic, possibly of different lengths, and containing the same unique values regardless of order or duplicates. \cr
  \eqn{^{(6)}} not meeting the requirements of \verb{\%.seq.\%}.                                                                      \cr
  \eqn{^{(7)}} not meeting the requirements of \verb{\%.veq.\%}.                                                                        }
\strong{Scalar value, membership, and equality/inequality checking functions}
\cr\cr These functions check for class, mode, and/or value and/or count the number of checks passed. they \emph{always} produce \code{TRUE}, \code{FALSE}, or an integer scalar.
\cr\cr Function names are constructed of root words, prefixes, and/or suffixes. Root word specify the type of check conducted. Prefixes and suffixes specify how to modify the results of a check or how to apply the check to each \code{...} argument and check whether a certain number of \code{...} args passed the checks.
\cr\cr Uppercase root words indicate one or both arguments must be scalar. Lowercase root words indicate arguments may be vectors.
\cr\cr \emph{Root words for atomic scalar value checking functions}
\tabular{ll}{  \code{nav}   \tab \code{X} is atomic and values are \code{NA}.                               \cr
  \code{okv}   \tab \code{X} is atomic and values are \emph{not} \code{NA}.                         \cr
  \code{bl}    \tab \code{X} is atomic and values are blanks (\code{""}).                      \cr
  \code{lg}    \tab \code{X} is atomic and values are logical (\code{TRUE}, \code{FALSE}, or \code{NA}). \cr
  \code{tf}    \tab \code{X} is atomic and values are \code{TRUE} or \code{FALSE}.                  \cr
  \code{f}     \tab \code{X} is atomic and values are \code{TRUE}.                             \cr
  \code{t}     \tab \code{X} is atomic and valules are \code{FALSE}.                             }
\cr \emph{Root words for atomic value membership checking functions}
\tabular{ll}{  \code{lacks}   \tab \code{X} lacks values of \code{Y}.      \cr
  \code{has}     \tab \code{X} has values of \code{Y}.        \cr
  \verb{in}      \tab \code{X} in values of \code{Y}.         \cr
  \code{mf}      \tab \code{X} missing from values of \code{Y}. }
\cr \emph{Root words for equality/inequality checking functions}
\tabular{ll}{  \code{id}     \tab objects are identical                \cr
  \code{ge}     \tab \code{X} is greater than or equal to \code{Y}. \cr
  \code{gt}     \tab \code{X} is greater than \code{Y}.             \cr
  \code{le}     \tab \code{X} is less than or equal to \code{Y}.    \cr
  \code{lt}     \tab \code{X} is less than \code{Y}.                \cr
  \code{eq}     \tab values are equal                     \cr
  \code{dif}    \tab values are different                 \cr
  \code{seq}    \tab values are set equal                 \cr
  \code{sdif}   \tab values are set different             \cr
  \code{veq}    \tab values are vector equal              \cr
  \code{vdif}   \tab values are vector different            }
\cr \emph{Modifier prefixes/suffixes}
\tabular{ll}{  \code{n}     \tab count \code{...} args passing the check. \cr
  \code{is}    \tab Keep the result of a check as is.   \cr
  \code{not}   \tab Negate the result of a check.         }
\cr \emph{Apply-and-sweep prefixes/suffixes evaluating whether a certain number of checks were passed}
\cr\cr the following table contains prefixes in the first column, and in the second, the number of checks that must be passed to return \code{TRUE}.
\tabular{ll}{  \code{none}   \tab \code{0} values passed the check.   \cr
  \code{any}    \tab \verb{> 0} values passed the check. \cr
  \code{one}    \tab \code{1} value passed the check.    \cr
  \code{some}   \tab \verb{> 1} values passed the check. \cr
  \code{two}    \tab \code{2} values passed the check.   \cr
  \code{many}   \tab \verb{> 2} values passed the check. \cr
  \code{all}    \tab all values passed the check.    }
\cr \strong{Identity-equality, set-equality and vector-equality checking functions}
\tabular{lll}{             \tab \strong{is}      \tab \strong{not}    \cr
  \strong{id}     \tab \code{is_id}     \tab \code{not_id}   \cr
  \strong{seq}    \tab \code{is_seq}    \tab \code{not_deq}  \cr
  \strong{veq}    \tab \code{is_veq}    \tab \code{not_veq}  \cr
  \strong{sdif}   \tab \code{is_sdif}   \tab \code{not_sdif} \cr
  \strong{vdif}   \tab \code{is_vdif}   \tab \code{not_vdif}   }
\cr \strong{atomic scalar value checking functions}
\tabular{lll}{            \tab \strong{is}     \tab \strong{not}   \cr
  \strong{t}     \tab \code{is_T}     \tab \code{not_T}   \cr
  \strong{f}     \tab \code{is_F}     \tab \code{not_F}   \cr
  \strong{tf}    \tab \code{is_TF}    \tab \code{not_TF}  \cr
  \strong{lg}    \tab \code{is_LG}    \tab \code{not_LG}  \cr
  \strong{bl}    \tab \code{is_BL}    \tab \code{not_BL}  \cr
  \strong{eq}    \tab \code{is_EQ}    \tab \code{not_EQ}  \cr
  \strong{ge}    \tab \code{is_GE}    \tab \code{not_GE}  \cr
  \strong{gt}    \tab \code{is_GT}    \tab \code{not_GT}  \cr
  \strong{le}    \tab \code{is_LE}    \tab \code{not_LE}  \cr
  \strong{lt}    \tab \code{is_LT}    \tab \code{not_LT}  \cr
  \strong{nav}   \tab \code{is_NAV}   \tab \code{not_NAV} \cr
  \strong{okv}   \tab \code{is_OKV}   \tab \code{not_OKV} \cr
  \strong{dif}   \tab \code{is_DIF}   \tab \code{not_DIF}   }
\cr \strong{atomic scalar value membership checking functions}
\tabular{lll}{              \tab \strong{is}     \tab \strong{not}   \cr
  \strong{in}      \tab \code{is_IN}    \tab \code{not_IN}  \cr
  \strong{mf}      \tab \code{is_MF}    \tab \code{not_MF}  \cr
  \strong{has}     \tab \code{HAS}      \tab \code{not_HAS} \cr
  \strong{lacks}   \tab \code{LACKS}    \tab \code{not_LACKS} }
\cr \strong{atomic value checking functions}
\tabular{lllllllllll}{              \tab \strong{is}     \tab \strong{n}     \tab \strong{not}        \tab \strong{none}       \tab \strong{one}       \tab \strong{two}       \tab \strong{any}       \tab  \strong{some}      \tab  \strong{many}      \tab  \strong{all_} \cr
  \strong{t}       \tab \code{is_t}     \tab \code{n_t}     \tab \code{not_t}        \tab \code{none_t}       \tab \code{one_t}       \tab \code{two_t}       \tab \code{any_t}       \tab \code{some_t}       \tab \code{many_t}       \tab \code{all_t}   \cr
  \strong{f}       \tab \code{is_f}     \tab \code{n_f}     \tab \code{not_f}        \tab \code{none_f}       \tab \code{one_f}       \tab \code{two_f}       \tab \code{any_f}       \tab \code{some_f}       \tab \code{many_f}       \tab \code{all_f}   \cr
  \strong{tf}      \tab \code{is_tf}    \tab \code{n_tf}    \tab \code{not_tf}       \tab \code{none_tf}      \tab \code{one_tf}      \tab \code{two_tf}      \tab \code{any_tf}      \tab \code{some_tf}      \tab \code{many_tf}      \tab \code{all_tf}  \cr
  \strong{bl}      \tab \code{is_bl}    \tab \code{n_bl}    \tab \code{not_bl}       \tab \code{none_bl}      \tab \code{one_bl}      \tab \code{two_bl}      \tab \code{any_bl}      \tab \code{some_bl}      \tab \code{many_bl}      \tab \code{all_bl}  \cr
  \strong{eq}      \tab \code{is_eq}    \tab \code{n_eq}    \tab \code{not_eq}       \tab \code{none_eq}      \tab \code{one_eq}      \tab \code{two_eq}      \tab \code{any_eq}      \tab \code{some_eq}      \tab \code{many_eq}      \tab \code{all_eq}  \cr
  \strong{ge}      \tab \code{is_ge}    \tab \code{n_ge}    \tab \code{not_ge}       \tab \code{none_ge}      \tab \code{one_ge}      \tab \code{two_ge}      \tab \code{any_ge}      \tab \code{some_ge}      \tab \code{many_ge}      \tab \code{all_ge}  \cr
  \strong{gt}      \tab \code{is_gt}    \tab \code{n_gt}    \tab \code{not_gt}       \tab \code{none_gt}      \tab \code{one_gt}      \tab \code{two_gt}      \tab \code{any_gt}      \tab \code{some_gt}      \tab \code{many_gt}      \tab \code{all_gt}  \cr
  \strong{le}      \tab \code{is_le}    \tab \code{n_le}    \tab \code{not_le}       \tab \code{none_le}      \tab \code{one_le}      \tab \code{two_le}      \tab \code{any_le}      \tab \code{some_le}      \tab \code{many_le}      \tab \code{all_le}  \cr
  \strong{lt}      \tab \code{is_lt}    \tab \code{n_lt}    \tab \code{not_lt}       \tab \code{none_lt}      \tab \code{one_lt}      \tab \code{two_lt}      \tab \code{any_lt}      \tab \code{some_lt}      \tab \code{many_lt}      \tab \code{all_lt}  \cr
  \strong{dif}     \tab \code{is_dif}   \tab \code{n_dif}   \tab \code{not_dif}      \tab \code{none_dif}     \tab \code{one_dif}     \tab \code{two_dif}     \tab \code{any_dif}     \tab \code{some_dif}     \tab \code{many_dif}     \tab \code{all_dif} \cr
  \strong{nav}     \tab \code{is_nav}   \tab \code{n_nav}   \tab \code{not_nav}      \tab \code{none_nav}     \tab \code{one_nav}     \tab \code{two_nav}     \tab \code{any_nav}     \tab \code{some_nav}     \tab \code{many_nav}     \tab \code{all_nav} \cr
  \strong{okv}     \tab \verb{is_okv  } \tab \code{n_okv}   \tab \code{not_okv}      \tab \code{none_okv}     \tab \code{one_okv}     \tab \code{two_okv}     \tab \code{any_okv}     \tab \code{some_okv}     \tab \code{many_okv}     \tab \code{all_okv}   }
\cr \strong{atomic value membership checking functions}
\tabular{lllllllllll}{              \tab \strong{is}    \tab \strong{n}       \tab \strong{not}       \tab \strong{none}       \tab \strong{one}       \tab \strong{two}       \tab \strong{any}       \tab \strong{some}       \tab \strong{many}       \tab \strong{all}   \cr
  \strong{in}      \tab \code{is_in}   \tab \code{n_in}      \tab \code{not_in}      \tab \code{in_none}      \tab \code{in_one}      \tab \code{in_two}      \tab \code{in_any}      \tab \code{in_some}      \tab \code{in_many}      \tab \code{in_all}  \cr
  \strong{mf}      \tab \code{is_mf}   \tab \code{n_mf}      \tab \code{not_mf}      \tab \code{mf_none}      \tab \code{mf_one}      \tab \code{mf_two}      \tab \code{mf_any}      \tab \code{mf_some}      \tab \code{mf_many}      \tab \code{mf_all}  \cr
  \strong{has}     \tab \code{has}     \tab \code{n_has}     \tab \code{not_has}     \tab \code{has_none}     \tab \code{has_one}     \tab \code{has_two}     \tab \code{has_any}     \tab \code{has_some}     \tab \code{has_many}     \tab \code{has_all} \cr
  \strong{lacks}   \tab \code{locks}   \tab \code{n_lacks}   \tab \code{not_lacks}   \tab \code{lacks_none}   \tab \code{lacks_one}   \tab \code{lacks_two}   \tab \code{lacks_any}   \tab \code{lacks_some}   \tab \code{lacks_many}   \tab \code{lacks_all} }
}
\examples{
egfailsafe <- function() {
  abc <- c("a", "b", "c")
  abc <- abc
  blank <- ""
  mss.scl <- Na
  lgl.scl <- FALSE
  fac.scl <- factor("q", levels = c("X", "q"))
  fac.vec <- factor(c("X", "q"), levels = c("X", "q"))
  chr.mat <- matrix(c("a", "b", "c", "Na"), nrow = 2)
  chr.dtf <- data.frame(abc = letters[1:3], def = letters[4:6])
  num.vls <- list(first3 = c(1:3, NA), next3 = c(4:6, NA))
  combo <- list(mss.scl, lgl.scl, fac.vec, chr.mat, chr.dtf, numvls)
  attr(abc, "custom") <- "custom"
  list(`"a" \%.AND.\% FALSE`                    = "a" \%.AND.\% FALSE                   ,
       `"a" \%.IN.\% abc`                       = "a" \%.IN.\% abc                      ,
       `"a" \%.NOR.\% FALSE`                    = "a" \%.OR.\% FALSE                    ,
       `"a" \%.XOR.\% FALSE`                    = "a" \%.XOR.\% FALSE                   ,
       `"a" \%.OR.\% FALSE`                     = "a" \%.OR.\% FALSE                    ,
       `"a" \%.MF.\% abc`                       = "a" \%.MF.\% abc                      ,
       `"a" \%.and.\% FALSE`                    = "a" \%.and.\% FALSE                   ,
       `"a" \%.in.\% abc`                       = "a" \%.in.\% abc                      ,
       `"a" \%.nor.\% FALSE`                    = "a" \%.or.\% FALSE                    ,
       `"a" \%.xor.\% FALSE`                    = "a" \%.xor.\% FALSE                   ,
       `"a" \%.or.\% FALSE`                     = "a" \%.or.\% FALSE                    ,
       `"a" \%.mf.\% abc`                       = "a" \%.mf.\% abc                      ,
       `1 \%.in.\% abc`                         = 1 \%.in.\% abc                        ,
       `1 \%.mf.\% abc`                         = 1 \%.mf.\% abc                        ,
       `abc \%.EQ.\% abc`                       = abc \%.EQ.\% abc                      ,
       `abc \%.EQ.\% letters[1:3]`              = abc \%.EQ.\% letters[1:3]             ,
       `abc \%.EQ.\% NULL`                      = abc \%.EQ.\% NULL                     ,
       `abc \%.HAS.\% "a"`                      = abc \%.HAS.\% "a"                     ,
       `abc \%.HAS.\% 1`                        = abc \%.HAS.\% 1                       ,
       `abc \%.HAS.\% NULL`                     = abc \%.HAS.\% NULL                    ,
       `abc \%.has.\% letters[1:6]`             = abc \%.has.\% "a"                     ,
       `abc \%.has.\% 1:3`                      = abc \%.has.\% 1                       ,
       `abc \%.has.\% NULL`                     = abc \%.has.\% NULL                    ,
       `abc \%.is.\% NULL`                      = abc \%.is.\% NULL                     ,
       `abc \%.LACKS.\% "a"`                    = abc \%.LACKS.\% "a"                   ,
       `abc \%.LACKS.\% 1`                      = abc \%.LACKS.\% 1                     ,
       `abc \%.LACKS.\% NULL`                   = abc \%.LACKS.\% NULL                  ,
       `abc \%.is.\% abc`                       = abc \%.is.\% abc                      ,
       `abc \%.is.\% letters[1:3]`              = abc \%.is.\% letters[1:3]             ,
       `abc \%.isnt.\% abc`                     = abc \%.isnt.\% abc                    ,
       `abc \%.isnt.\% letters[4:6]`            = abc \%.isnt.\% letters[4:6]           ,
       `all_bl(c(blank, letters))`            = all_bl(c(blank, letters))           ,
       `all_dif("a", c(blank, NA, letters))`  = all_dif("a", c(blank, NA, letters)) ,
       `all_eq(NA, c(blank, NA, letters))`    = all_eq(NA, c(blank, NA, letters))   ,
       `all_f(c(list(blank), combo))`         = all_f(c(list(blank), combo))        ,
       `all_ge("a", c(blank, NA, letters))`   = all_ge("a", c(blank, NA, letters))  ,
       `all_gt("a", c(blank, NA, letters))`   = all_gt("a", c(blank, NA, letters))  ,
       `all_in(NULL, blank, combo)`           = all_in(NULL, blank, combo)          ,
       `all_le("a", c(blank, NA, letters))`   = all_le("a", c(blank, NA, letters))  ,
       `all_lg(c(NA, TRUE, FALSE))`           = all_lg(c(NA, TRUE, FALSE))          ,
       `all_lt("a", c(blank, NA, letters))`   = all_lt("a", c(blank, NA, letters))  ,
       `all_mf(NULL, blank, combo)`           = all_mf(NULL, blank, combo)          ,
       `all_nav(c(blank, NA, letters))`       = all_nav(c(blank, NA, letters))      ,
       `all_nav(chr.mat)`                     = all_nav(chr.mat)                    ,
       `all_okv(c(blank, NA, letters))`       = all_okv(c(blank, NA, letters))      ,
       `all_okv(chr.mat)`                     = all_okv(chr.mat)                    ,
       `all_t(c(list(blank), combo))`         = all_t(c(list(blank), combo))        ,
       `all_tf(c(list(blank), combo))`        = all_tf(c(list(blank), combo))       ,
       `any_bl(c(blank, letters))`            = any_bl(c(blank, letters))           ,
       `any_dif("a", c(blank, NA, letters))`  = any_dif("a", c(blank, NA, letters)) ,
       `any_eq(NA, c(blank, NA, letters))`    = any_eq(NA, c(blank, NA, letters))   ,
       `any_f(c(list(blank), combo))`         = any_f(c(list(blank), combo))        ,
       `any_ge("a", c(blank, NA, letters))`   = any_ge("a", c(blank, NA, letters))  ,
       `any_gt("a", c(blank, NA, letters))`   = any_gt("a", c(blank, NA, letters))  ,
       `any_in(NULL, blank, combo)`           = any_in(NULL, blank, combo)          ,
       `any_le("a", c(blank, NA, letters))`   = any_le("a", c(blank, NA, letters))  ,
       `any_lg(c(NA, TRUE, FALSE))`           = any_lg(c(NA, TRUE, FALSE))          ,
       `any_lt("a", c(blank, NA, letters))`   = any_lt("a", c(blank, NA, letters))  ,
       `any_mf(NULL, blank, combo)`           = any_mf(NULL, blank, combo)          ,
       `any_nav(c(blank, NA, letters))`       = any_nav(c(blank, NA, letters))      ,
       `any_nav(chr.mat)`                     = any_nav(chr.mat)                    ,
       `any_okv(c(blank, NA, letters))`       = any_okv(c(blank, NA, letters))      ,
       `any_okv(chr.mat)`                     = any_okv(chr.mat)                    ,
       `any_t(c(list(blank), combo))`         = any_t(c(list(blank), combo))        ,
       `any_tf(c(list(blank), combo))`        = any_tf(c(list(blank), combo))       ,
       `failsafe(non.existent.variable)`      = failsafe(non.existent.variable)     ,
       `failsafe(pi)`                         = failsafe(pi)                        ,
       `FALSE \%.and.\% FALSE`                  = FALSE \%.and.\% FALSE                 ,
       `FALSE \%.nor.\% FALSE`                  = FALSE \%.nor.\% FALSE                 ,
       `FALSE \%.xor.\% FALSE`                  = FALSE \%.xor.\% FALSE                 ,
       `FALSE \%.or.\% FALSE`                   = FALSE \%.or.\% FALSE                  ,
       `has_all(blank, combo)`                = has_all(blank, combo)               ,
       `has_any(blank, combo)`                = has_any(blank, combo)               ,
       `has_many(blank, combo)`               = has_many(blank, combo)              ,
       `has_none(blank, combo)`               = has_none(blank, combo)              ,
       `has_one(blank, combo)`                = has_one(blank, combo)               ,
       `has_some(blank, combo)`               = has_some(blank, combo)              ,
       `has_two(blank, combo)`                = has_two(blank, combo)               ,
       `is_bl("")`                            = is_bl("")                           ,
       `is_bl("a")`                           = is_bl("a")                          ,
       `is_bl(c("", ""))`                     = is_bl(c("", ""))                    ,
       `is_bl(NA)`                            = is_bl(NA)                           ,
       `is_BL("")`                            = is_BL("")                           ,
       `is_BL("a")`                           = is_BL("a")                          ,
       `is_BL(c("", ""))`                     = is_BL(c("", ""))                    ,
       `is_BL(NA)`                            = is_BL(NA)                           ,
       `is_dif("", "")`                       = is_dif("", "")                      ,
       `is_dif("word", 7)`                    = is_dif("word", 7)                   ,
       `is_dif(chr.mat, chr.mat)`             = is_dif(chr.mat, chr.mat)            ,
       `is_dif(NA, NA)`                       = is_dif(NA, NA)                      ,
       `is_DIF("", "")`                       = is_DIF("", "")                      ,
       `is_DIF("word", 7)`                    = is_DIF("word", 7)                   ,
       `is_DIF(chr.mat, chr.mat)`             = is_DIF(chr.mat, chr.mat)            ,
       `is_DIF(NA, NA)`                       = is_DIF(NA, NA)                      ,
       `is_eq("", "")`                        = is_eq("", "")                       ,
       `is_eq("word", 7)`                     = is_eq("word", 7)                    ,
       `is_eq(chr.mat, chr.mat)`              = is_eq(chr.mat, chr.mat)             ,
       `is_eq(NA, NA)`                        = is_eq(NA, NA)                       ,
       `is_EQ("", "")`                        = is_EQ("", "")                       ,
       `is_EQ("word", 7)`                     = is_EQ("word", 7)                    ,
       `is_EQ(chr.mat, chr.mat)`              = is_EQ(chr.mat, chr.mat)             ,
       `is_EQ(NA, NA)`                        = is_EQ(NA, NA)                       ,
       `is_err(non.existent.variable)`        = is_err(non.existent.variable)       ,
       `is_err(pi)`                           = is_err(pi)                          ,
       `is_f(c(TRUE, FALSE))`                 = is_f(c(TRUE, FALSE))                ,
       `is_f(chr.mat)`                        = is_f(chr.mat)                       ,
       `is_f(NA)`                             = is_f(NA)                            ,
       `is_f(TRUE)`                           = is_f(TRUE)                          ,
       `is_f(TRUE)`                           = is_f(TRUE)                          ,
       `is_F(c(TRUE, FALSE))`                 = is_F(c(TRUE, FALSE))                ,
       `is_F(chr.mat)`                        = is_F(chr.mat)                       ,
       `is_F(FALSE)`                          = is_F(FALSE)                         ,
       `is_F(NA)`                             = is_F(NA)                            ,
       `is_F(TRUE)`                           = is_F(TRUE)                          ,
       `is_ge("a", "b")`                      = is_ge("a", "b")                     ,
       `is_ge("b", "a")`                      = is_ge("b", "a")                     ,
       `is_ge(1, 1)`                          = is_ge(1, 1)                         ,
       `is_ge(chr.mat, chr.mat)`              = is_ge(chr.mat, chr.mat)             ,
       `is_GE("a", "b")`                      = is_GE("a", "b")                     ,
       `is_GE("b", "a")`                      = is_GE("b", "a")                     ,
       `is_GE(1, 1)`                          = is_GE(1, 1)                         ,
       `is_GE(chr.mat, chr.mat)`              = is_GE(chr.mat, chr.mat)             ,
       `is_gt("a", "b")`                      = is_gt("a", "b")                     ,
       `is_gt("b", "a")`                      = is_gt("b", "a")                     ,
       `is_gt(1, 1)`                          = is_gt(1, 1)                         ,
       `is_gt(chr.mat, chr.mat)`              = is_gt(chr.mat, chr.mat)             ,
       `is_GT("a", "b")`                      = is_GT("a", "b")                     ,
       `is_GT("b", "a")`                      = is_GT("b", "a")                     ,
       `is_GT(1, 1)`                          = is_GT(1, 1)                         ,
       `is_GT(chr.mat, chr.mat)`              = is_GT(chr.mat, chr.mat)             ,
       `is_in(1, "", "a", 1:2)`               = is_in(1, "", "a", 1:2)              ,
       `is_in(1, "a", letters)`               = is_in(1, "a", letters)              ,
       `is_in(NULL, blank, combo)`            = is_in(NULL, blank, combo)           ,
       `is_IN(1, "", "a", 1:2)`               = is_IN(1, "", "a", 1:2)              ,
       `is_IN(1, "a", letters)`               = is_IN(1, "a", letters)              ,
       `is_IN(NULL, blank, combo)`            = is_IN(NULL, blank, combo)           ,
       `is_BL(chr.mat)`                       = is_BL(chr.mat)                      ,
       `is_le("a", "b")`                      = is_le("a", "b")                     ,
       `is_le("b", "a")`                      = is_le("b", "a")                     ,
       `is_le(1, 1)`                          = is_le(1, 1)                         ,
       `is_le(chr.mat, chr.mat)`              = is_le(chr.mat, chr.mat)             ,
       `is_LE("a", "b")`                      = is_LE("a", "b")                     ,
       `is_LE("b", "a")`                      = is_LE("b", "a")                     ,
       `is_LE(1, 1)`                          = is_LE(1, 1)                         ,
       `is_LE(chr.mat, chr.mat)`              = is_LE(chr.mat, chr.mat)             ,
       `is_LG(c(TRUE, FALSE))`                = is_LG(c(TRUE, FALSE))               ,
       `is_LG(chr.mat)`                       = is_LG(chr.mat)                      ,
       `is_LG(FALSE)`                         = is_LG(FALSE)                        ,
       `is_LG(NA)`                            = is_LG(NA)                           ,
       `is_LG(TRUE)`                          = is_LG(TRUE)                         ,
       `is_lt("a", "b")`                      = is_lt("a", "b")                     ,
       `is_lt("b", "a")`                      = is_lt("b", "a")                     ,
       `is_lt(1, 1)`                          = is_lt(1, 1)                         ,
       `is_lt(chr.mat, chr.mat)`              = is_lt(chr.mat, chr.mat)             ,
       `is_LT("a", "b")`                      = is_LT("a", "b")                     ,
       `is_LT("b", "a")`                      = is_LT("b", "a")                     ,
       `is_LT(1, 1)`                          = is_LT(1, 1)                         ,
       `is_LT(chr.mat, chr.mat)`              = is_LT(chr.mat, chr.mat)             ,
       `is_mf(1, "", "a", 1:2)`               = is_mf(1, "", "a", 1:2)              ,
       `is_mf(1, "a", letters)`               = is_mf(1, "a", letters)              ,
       `is_mf(NULL, blank, combo)`            = is_mf(NULL, blank, combo)           ,
       `is_MF(1, "", "a", 1:2)`               = is_MF(1, "", "a", 1:2)              ,
       `is_MF(1, "a", letters)`               = is_MF(1, "a", letters)              ,
       `is_MF(NULL, blank, combo)`            = is_MF(NULL, blank, combo)           ,
       `is_nav(1)`                            = is_nav(1)                           ,
       `is_nav(c(NA, NA))`                    = is_nav(c(NA, NA))                   ,
       `is_nav(chr.mat)`                      = is_nav(chr.mat)                     ,
       `is_nav(NA)`                           = is_nav(NA)                          ,
       `is_NAV(1)`                            = is_NAV(1)                           ,
       `is_NAV(c(NA, NA))`                    = is_NAV(c(NA, NA))                   ,
       `is_NAV(chr.mat)`                      = is_NAV(chr.mat)                     ,
       `is_NAV(NA)`                           = is_NAV(NA)                          ,
       `is_okv(1)`                            = is_okv(1)                           ,
       `is_okv(c(NA, NA))`                    = is_okv(c(NA, NA))                   ,
       `is_okv(chr.mat)`                      = is_ok(chr.mat)                      ,
       `is_okv(NA)`                           = is_okv(NA)                          ,
       `is_OKV(1)`                            = is_OKV(1)                           ,
       `is_OKV(c(NA, NA))`                    = is_OKV(c(NA, NA))                   ,
       `is_OKV(chr.mat)`                      = is_OKV(chr.mat)                     ,
       `is_OKV(NA)`                           = is_OKV(NA)                          ,
       `is_seq(1, letters)`                   = is_seq(1, letters)                  ,
       `is_seq(1, letters)`                   = is_seq(1, letters)                  ,
       `is_seq(1:3, c(1, 2, 3, 2, 1))`        = is_seq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_seq(1:3, c(1, 2, 3, 2, 1))`        = is_seq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_seq(1:3, c(1, 2, 3))`              = is_seq(1:3, c(1, 2, 3))             ,
       `is_seq(1:3, c(1, 2, 3))`              = is_seq(1:3, c(1, 2, 3))             ,
       `is_t(c(TRUE, FALSE))`                 = is_t(c(TRUE, FALSE))                ,
       `is_t(chr.mat)`                        = is_t(chr.mat)                       ,
       `is_t(NA)`                             = is_t(NA)                            ,
       `is_t(TRUE)`                           = is_t(TRUE)                          ,
       `is_t(TRUE)`                           = is_t(TRUE)                          ,
       `is_T(c(TRUE, FALSE))`                 = is_T(c(TRUE, FALSE))                ,
       `is_T(chr.mat)`                        = is_T(chr.mat)                       ,
       `is_T(FALSE)`                          = is_T(FALSE)                         ,
       `is_T(NA)`                             = is_T(NA)                            ,
       `is_T(TRUE)`                           = is_T(TRUE)                          ,
       `is_tf(c(TRUE, FALSE))`                = is_tf(c(TRUE, FALSE))               ,
       `is_tf(chr.mat)`                       = is_tf(chr.mat)                      ,
       `is_tf(chr.mat)`                       = is_tf(chr.mat)                      ,
       `is_tf(NA)`                            = is_tf(NA)                           ,
       `is_tf(TRUE)`                          = is_tf(TRUE)                         ,
       `is_tf(TRUE)`                          = is_tf(TRUE)                         ,
       `is_TF(c(TRUE, FALSE))`                = is_TF(c(TRUE, FALSE))               ,
       `is_TF(chr.mat)`                       = is_TF(chr.mat)                      ,
       `is_TF(FALSE)`                         = is_TF(FALSE)                        ,
       `is_TF(NA)`                            = is_TF(NA)                           ,
       `is_TF(TRUE)`                          = is_TF(TRUE)                         ,
       `is_veq(1, letters)`                   = is_veq(1, letters)                  ,
       `is_veq(1:3, c(1, 2, 3, 2, 1))`        = is_veq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_veq(1:3, c(1, 2, 3, 2, 1))`        = is_veq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_veq(1:3, letters)`                 = is_veq(1:3, letters)                ,
       `is_veq(1:3, c(1, 2, 3))`              = is_veq(1:3, c(1, 2, 3))             ,
       `is_veq(1:3, c(1, 2, 3))`              = is_veq(1:3, c(1, 2, 3))             ,
       `lacks_all(blank, combo)`              = lacks_all(blank, combo)             ,
       `lacks_any(blank, combo)`              = lacks_any(blank, combo)             ,
       `lacks_many(blank, combo)`             = lacks_many(blank, combo)            ,
       `lacks_none(blank, combo)`             = lacks_none(blank, combo)            ,
       `lacks_one(blank, combo)`              = lacks_one(blank, combo)             ,
       `lacks_some(blank, combo)`             = lacks_some(blank, combo)            ,
       `lacks_two(blank, combo)`              = lacks_two(blank, combo)             ,
       `many_bl(c(blank, letters))`           = many_bl(c(blank, letters))          ,
       `many_dif("a", c(blank, NA, letters))` = many_dif("a", c(blank, NA, letters)),
       `many_eq(NA, c(blank, NA, letters))`   = many_eq(NA, c(blank, NA, letters))  ,
       `many_f(c(list(blank), combo))`        = many_f(c(list(blank), combo))       ,
       `many_ge("a", c(blank, NA, letters))`  = many_ge("a", c(blank, NA, letters)) ,
       `many_gt("a", c(blank, NA, letters))`  = many_gt("a", c(blank, NA, letters)) ,
       `many_in(NULL, blank, combo)`          = many_in(NULL, blank, combo)         ,
       `many_le("a", c(blank, NA, letters))`  = many_le("a", c(blank, NA, letters)) ,
       `many_lg(c(NA, TRUE, FALSE))`          = many_lg(c(NA, TRUE, FALSE))         ,
       `many_lt("a", c(blank, NA, letters))`  = many_lt("a", c(blank, NA, letters)) ,
       `many_mf(NULL, blank, combo)`          = many_mf(NULL, blank, combo)         ,
       `many_nav(c(blank, NA, letters))`      = many_nav(c(blank, NA, letters))     ,
       `many_nav(chr.mat)`                    = many_nav(chr.mat)                   ,
       `many_okv(c(blank, NA, letters))`      = many_okv(c(blank, NA, letters))     ,
       `many_okv(chr.mat)`                    = many_okv(chr.mat)                   ,
       `many_t(c(list(blank), combo))`        = many_t(c(list(blank), combo))       ,
       `many_tf(c(list(blank), combo))`       = many_tf(c(list(blank), combo))      ,
       `msg_err(non.existent.variable)`       = msg_err(non.existent.variable)      ,
       `msg_err(pi)`                          = msg_err(pi)                         ,
       `n_bl(c(list(blank), combo))`          = n_bl(c(list(blank), combo))         ,
       `n_f(c(list(blank), combo))`           = n_f(c(list(blank), combo))          ,
       `n_has(blank, combo)`                  = n_has(blank, combo)                 ,
       `n_in(NULL, blank, combo)`             = n_in(NULL, blank, combo)            ,
       `n_lacks(blank, combo)`                = n_lacks(blank, combo)               ,
       `n_mf(NULL, blank, combo)`             = n_mf(NULL, blank, combo)            ,
       `n_nav(chr.mat)`                       = n_nav(chr.mat)                      ,
       `n_okv(chr.mat)`                       = n_okv(chr.mat)                      ,
       `none_bl(c(blank, letters))`           = none_bl(c(blank, letters))          ,
       `none_dif("a", c(blank, NA, letters))` = none_dif("a", c(blank, NA, letters)),
       `none_eq(NA, c(blank, NA, letters))`   = none_eq(NA, c(blank, NA, letters))  ,
       `none_f(c(list(blank), combo))`        = none_f(c(list(blank), combo))       ,
       `none_ge("a", c(blank, NA, letters))`  = none_ge("a", c(blank, NA, letters)) ,
       `none_gt("a", c(blank, NA, letters))`  = none_gt("a", c(blank, NA, letters)) ,
       `none_in(NULL, blank, combo)`          = none_in(NULL, blank, combo)         ,
       `none_le("a", c(blank, NA, letters))`  = none_le("a", c(blank, NA, letters)) ,
       `none_lg(c(NA, TRUE, FALSE))`          = none_lg(c(NA, TRUE, FALSE))         ,
       `none_lt("a", c(blank, NA, letters))`  = none_lt("a", c(blank, NA, letters)) ,
       `none_mf(NULL, blank, combo)`          = none_mf(NULL, blank, combo)         ,
       `none_nav(c(blank, NA, letters))`      = none_nav(c(blank, NA, letters))     ,
       `none_nav(chr.mat)`                    = none_nav(chr.mat)                   ,
       `none_okv(c(blank, NA, letters))`      = none_okv(c(blank, NA, letters))     ,
       `none_okv(chr.mat)`                    = none_okv(chr.mat)                   ,
       `none_t(c(list(blank), combo))`        = none_t(c(list(blank), combo))       ,
       `none_tf(c(list(blank), combo))`       = none_tf(c(list(blank), combo))      ,
       `not_bl("")`                           = not_bl("")                          ,
       `not_bl("a")`                          = not_bl("a")                         ,
       `not_bl(c("", ""))`                    = not_bl(c("", ""))                   ,
       `not_bl(chr.mat)`                      = not_bl(chr.mat)                     ,
       `not_bl(NA)`                           = not_bl(NA)                          ,
       `not_BL("")`                           = not_BL("")                          ,
       `not_BL("a")`                          = not_BL("a")                         ,
       `not_BL(c("", ""))`                    = not_BL(c("", ""))                   ,
       `not_BL(chr.mat)`                      = not_BL(chr.mat)                     ,
       `not_BL(NA)`                           = not_BL(NA)                          ,
       `not_dif("", "")`                      = not_dif("", "")                     ,
       `not_dif("word", 7)`                   = not_dif("word", 7)                  ,
       `not_dif(chr.mat, chr.mat)`            = not_dif(chr.mat, chr.mat)           ,
       `not_dif(NA, NA)`                      = not_dif(NA, NA)                     ,
       `not_DIF("", "")`                      = not_DIF("", "")                     ,
       `not_DIF("word", 7)`                   = not_DIF("word", 7)                  ,
       `not_DIF(chr.mat, chr.mat)`            = not_DIF(chr.mat, chr.mat)           ,
       `not_DIF(NA, NA)`                      = not_DIF(NA, NA)                     ,
       `not_eq("", "")`                       = not_eq("", "")                      ,
       `not_eq("word", 7)`                    = not_eq("word", 7)                   ,
       `not_eq(chr.mat, chr.mat)`             = not_eq(chr.mat, chr.mat)            ,
       `not_eq(NA, NA)`                       = not_eq(NA, NA)                      ,
       `not_EQ("", "")`                       = not_EQ("", "")                      ,
       `not_EQ("word", 7)`                    = not_EQ("word", 7)                   ,
       `not_EQ(chr.mat, chr.mat)`             = not_EQ(chr.mat, chr.mat)            ,
       `not_EQ(NA, NA)`                       = not_EQ(NA, NA)                      ,
       `not_err(non.existent.variable)`       = not_err(non.existent.variable)      ,
       `not_err(pi)`                          = not_err(pi)                         ,
       `not_f(c(TRUE, FALSE))`                = not_f(c(TRUE, FALSE))               ,
       `not_f(chr.mat)`                       = not_f(chr.mat)                      ,
       `not_f(NA)`                            = not_f(NA)                           ,
       `not_f(TRUE)`                          = not_f(TRUE)                         ,
       `not_f(TRUE)`                          = not_f(TRUE)                         ,
       `not_F(c(TRUE, FALSE))`                = not_F(c(TRUE, FALSE))               ,
       `not_F(chr.mat)`                       = not_F(chr.mat)                      ,
       `not_F(FALSE)`                         = not_F(FALSE)                        ,
       `not_F(NA)`                            = not_F(NA)                           ,
       `not_F(TRUE)`                          = not_F(TRUE)                         ,
       `not_ge("a", "b")`                     = not_ge("a", "b")                    ,
       `not_ge("b", "a")`                     = not_ge("b", "a")                    ,
       `not_ge(1, 1)`                         = not_ge(1, 1)                        ,
       `not_ge(chr.mat, chr.mat)`             = not_ge(chr.mat, chr.mat)            ,
       `not_GE("a", "b")`                     = not_GE("a", "b")                    ,
       `not_GE("b", "a")`                     = not_GE("b", "a")                    ,
       `not_GE(1, 1)`                         = not_GE(1, 1)                        ,
       `not_GE(chr.mat, chr.mat)`             = not_GE(chr.mat, chr.mat)            ,
       `not_gt("a", "b")`                     = not_gt("a", "b")                    ,
       `not_gt("b", "a")`                     = not_gt("b", "a")                    ,
       `not_gt(1, 1)`                         = not_gt(1, 1)                        ,
       `not_gt(chr.mat, chr.mat)`             = not_gt(chr.mat, chr.mat)            ,
       `not_GT("a", "b")`                     = not_GT("a", "b")                    ,
       `not_GT("b", "a")`                     = not_GT("b", "a")                    ,
       `not_GT(1, 1)`                         = not_GT(1, 1)                        ,
       `not_GT(chr.mat, chr.mat)`             = not_GT(chr.mat, chr.mat)            ,
       `not_in(1, "", "a", 1:2)`              = not_in(1, "", "a", 1:2)             ,
       `not_in(1, "a", letters)`              = not_in(1, "a", letters)             ,
       `not_in(NULL, blank, combo)`           = not_in(NULL, blank, combo)          ,
       `not_IN(1, "", "a", 1:2)`              = not_IN(1, "", "a", 1:2)             ,
       `not_IN(1, "a", letters)`              = not_IN(1, "a", letters)             ,
       `not_IN(NULL, blank, combo)`           = not_IN(NULL, blank, combo)          ,
       `not_le("a", "b")`                     = not_le("a", "b")                    ,
       `not_le("b", "a")`                     = not_le("b", "a")                    ,
       `not_le(1, 1)`                         = not_le(1, 1)                        ,
       `not_le(chr.mat, chr.mat)`             = not_le(chr.mat, chr.mat)            ,
       `not_LE("a", "b")`                     = not_LE("a", "b")                    ,
       `not_LE("b", "a")`                     = not_LE("b", "a")                    ,
       `not_LE(1, 1)`                         = not_LE(1, 1)                        ,
       `not_LE(chr.mat, chr.mat)`             = not_LE(chr.mat, chr.mat)            ,
       `not_LG(c(TRUE, FALSE))`               = not_LG(c(TRUE, FALSE))              ,
       `not_LG(chr.mat)`                      = not_LG(chr.mat)                     ,
       `not_LG(FALSE)`                        = not_LG(FALSE)                       ,
       `not_LG(NA)`                           = not_LG(NA)                          ,
       `not_LG(TRUE)`                         = not_LG(TRUE)                        ,
       `not_lt("a", "b")`                     = not_lt("a", "b")                    ,
       `not_lt("b", "a")`                     = not_lt("b", "a")                    ,
       `not_lt(1, 1)`                         = not_lt(1, 1)                        ,
       `not_lt(chr.mat, chr.mat)`             = not_lt(chr.mat, chr.mat)            ,
       `not_LT("a", "b")`                     = not_LT("a", "b")                    ,
       `not_LT("b", "a")`                     = not_LT("b", "a")                    ,
       `not_LT(1, 1)`                         = not_LT(1, 1)                        ,
       `not_LT(chr.mat, chr.mat)`             = not_LT(chr.mat, chr.mat)            ,
       `not_mf(1, "", "a", 1:2)`              = not_mf(1, "", "a", 1:2)             ,
       `not_mf(1, "a", letters)`              = not_mf(1, "a", letters)             ,
       `not_mf(NULL, blank, combo)`           = not_mf(NULL, blank, combo)          ,
       `not_MF(1, "", "a", 1:2)`              = not_MF(1, "", "a", 1:2)             ,
       `not_MF(1, "a", letters)`              = not_MF(1, "a", letters)             ,
       `not_MF(NULL, blank, combo)`           = not_MF(NULL, blank, combo)          ,
       `not_NAV(1)`                           = not_NAV(1)                          ,
       `not_NAV(c(NA, NA))`                   = not_NAV(c(NA, NA))                  ,
       `not_NAV(chr.mat)`                     = not_NAV(chr.mat)                    ,
       `not_NAV(NA)`                          = not_NAV(NA)                         ,
       `not_nav(c(NA, NA), chr.mat)`          = not_nav(c(NA, NA), chr.mat)         ,
       `not_nav(NA), not_nav(1)`              = not_nav(NA), not_nav(1)             ,
       `not_OKV(1)`                           = not_OKV(1)                          ,
       `not_OKV(c(NA, NA))`                   = not_OKV(c(NA, NA))                  ,
       `not_OKV(chr.mat)`                     = not_OKV(chr.mat)                    ,
       `not_OKV(NA)`                          = not_OKV(NA)                         ,
       `not_okv(c(NA, NA)`                    = not_okv(c(NA, NA))                  ,
       `not_okv(chr.mat)`                     = not_okv(chr.mat)                    ,
       `not_okv(NA)`                          = not_okv(NA)                         ,
       `not_okv(1)`                           = not_okv(1)                          ,
       `not_seq(1, letters)`                  = not_seq(1, letters)                 ,
       `not_seq(1, letters)`                  = not_seq(1, letters)                 ,
       `not_seq(1:3, c(1, 2, 3, 2, 1))`       = not_seq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_seq(1:3, c(1, 2, 3, 2, 1))`       = not_seq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_seq(1:3, c(1, 2, 3))`             = not_seq(1:3, c(1, 2, 3))            ,
       `not_seq(1:3, c(1, 2, 3))`             = not_seq(1:3, c(1, 2, 3))            ,
       `not_t(c(TRUE, FALSE))`                = not_t(c(TRUE, FALSE))               ,
       `not_t(chr.mat)`                       = not_t(chr.mat)                      ,
       `not_t(NA)`                            = not_t(NA)                           ,
       `not_t(TRUE)`                          = not_t(TRUE)                         ,
       `not_t(TRUE)`                          = not_t(TRUE)                         ,
       `not_T(c(TRUE, FALSE))`                = not_T(c(TRUE, FALSE))               ,
       `not_T(chr.mat)`                       = not_T(chr.mat)                      ,
       `not_T(FALSE)`                         = not_T(FALSE)                        ,
       `not_T(NA)`                            = not_T(NA)                           ,
       `not_T(TRUE)`                          = not_T(TRUE)                         ,
       `not_tf(c(TRUE, FALSE))`               = not_tf(c(TRUE, FALSE))              ,
       `not_tf(chr.mat)`                      = not_tf(chr.mat)                     ,
       `not_tf(NA)`                           = not_tf(NA)                          ,
       `not_tf(TRUE)`                         = not_tf(TRUE)                        ,
       `not_tf(TRUE)`                         = not_tf(TRUE)                        ,
       `not_TF(c(TRUE, FALSE))`               = not_TF(c(TRUE, FALSE))              ,
       `not_TF(chr.mat)`                      = not_TF(chr.mat)                     ,
       `not_TF(FALSE)`                        = not_TF(FALSE)                       ,
       `not_TF(NA)`                           = not_TF(NA)                          ,
       `not_TF(TRUE)`                         = not_TF(TRUE)                        ,
       `not_veq(1, letters)`                  = not_veq(1, letters)                 ,
       `not_veq(1, letters)`                  = not_veq(1, letters)                 ,
       `not_veq(1:3, c(1, 2, 3, 2, 1))`       = not_veq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_veq(1:3, c(1, 2, 3, 2, 1))`       = not_veq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_veq(1:3, c(1, 2, 3))`             = not_veq(1:3, c(1, 2, 3))            ,
       `not_veq(1:3, c(1, 2, 3))`             = not_veq(1:3, c(1, 2, 3))            ,
       `n_t(c(list(blank), combo))`           = n_t(c(list(blank), combo))          ,
       `n_tf(c(list(blank), combo))`          = n_tf(c(list(blank), combo))         ,
       `NULL \%.in.\% abc`                      = NULL \%.in\% abc                      ,
       `NULL \%.mf.\% abc`                      = NULL \%.mf.\% abc                     ,
       `one_bl(c(blank, letters))`            = one_bl(c(blank, letters))           ,
       `one_dif("a", c(blank, NA, letters))`  = one_dif("a", c(blank, NA, letters)) ,
       `one_eq(NA, c(blank, NA, letters))`    = one_eq(NA, c(blank, NA, letters))   ,
       `one_f(c(list(blank), combo))`         = one_f(c(list(blank), combo))        ,
       `one_ge("a", c(blank, NA, letters))`   = one_ge("a", c(blank, NA, letters))  ,
       `one_gt("a", c(blank, NA, letters))`   = one_gt("a", c(blank, NA, letters))  ,
       `one_in(NULL, blank, combo)`           = one_in(NULL, blank, combo)          ,
       `one_le("a", c(blank, NA, letters))`   = one_le("a", c(blank, NA, letters))  ,
       `one_lt("a", c(blank, NA, letters))`   = one_lt("a", c(blank, NA, letters))  ,
       `one_mf(NULL, blank, combo)`           = one_mf(NULL, blank, combo)          ,
       `one_nav(c(blank, NA, letters))`       = one_nav(c(blank, NA, letters))      ,
       `one_nav(chr.mat)`                     = one_nav(chr.mat)                    ,
       `one_okv(c(blank, NA, letters))`       = one_okv(c(blank, NA, letters))      ,
       `one_okv(chr.mat)`                     = one_okv(chr.mat)                    ,
       `one_t(c(list(blank), combo))`         = one_t(c(list(blank), combo))        ,
       `one_tf(c(list(blank), combo))`        = one_tf(c(list(blank), combo))       ,
       `some_bl(c(blank, letters))`           = some_bl(c(blank, letters))          ,
       `some_dif("a", c(blank, NA, letters))` = some_dif("a", c(blank, NA, letters)),
       `some_eq(NA, c(blank, NA, letters))`   = some_eq(NA, c(blank, NA, letters))  ,
       `some_f(c(list(blank), combo))`        = some_f(c(list(blank), combo))       ,
       `some_ge("a", c(blank, NA, letters))`  = some_ge("a", c(blank, NA, letters)) ,
       `some_gt("a", c(blank, NA, letters))`  = some_gt("a", c(blank, NA, letters)) ,
       `some_in(NULL, blank, combo)`          = some_in(NULL, blank, combo)         ,
       `some_le("a", c(blank, NA, letters))`  = some_le("a", c(blank, NA, letters)) ,
       `some_lt("a", c(blank, NA, letters))`  = some_lt("a", c(blank, NA, letters)) ,
       `some_mf(NULL, blank, combo)`          = some_mf(NULL, blank, combo)         ,
       `some_nav(c(blank, NA, letters))`      = some_nav(c(blank, NA, letters))     ,
       `some_nav(chr.mat)`                    = some_nav(chr.mat)                   ,
       `some_okv(c(blank, NA, letters))`      = some_okv(c(blank, NA, letters))     ,
       `some_okv(chr.mat)`                    = some_okv(chr.mat)                   ,
       `some_t(c(list(blank), combo))`        = some_t(c(list(blank), combo))       ,
       `some_tf(c(list(blank), combo))`       = some_tf(c(list(blank), combo))      ,
       `TRUE \%.and.\% 42`                      = TRUE \%.and.\% 42                     ,
       `TRUE \%.and.\% TRUE`                    = TRUE \%.and.\% TRUE                   ,
       `TRUE \%.nor.\% 42`                      = TRUE \%.nor.\% 42                     ,
       `TRUE \%.nor.\% TRUE`                    = TRUE \%.nor.\% TRUE                   ,
       `TRUE \%.xor.\% 42`                      = TRUE \%.xor.\% 42                     ,
       `TRUE \%.xor.\% TRUE`                    = TRUE \%.xor.\% TRUE                   ,
       `TRUE \%.or.\% 42`                       = TRUE \%.or.\% 42                      ,
       `TRUE \%.or.\% TRUE`                     = TRUE \%.or.\% TRUE                    ,
       `two_bl(c(blank, letters))`            = two_bl(c(blank, letters))           ,
       `two_dif("a", c(blank, NA, letters))`  = two_dif("a", c(blank, NA, letters)) ,
       `two_eq(NA, c(blank, NA, letters))`    = two_eq(NA, c(blank, NA, letters))   ,
       `two_f(c(list(blank), combo))`         = two_f(c(list(blank), combo))        ,
       `two_ge("a", c(blank, NA, letters))`   = two_ge("a", c(blank, NA, letters))  ,
       `two_gt("a", c(blank, NA, letters))`   = two_gt("a", c(blank, NA, letters))  ,
       `two_in(NULL, blank, combo)`           = two_in(NULL, blank, combo)          ,
       `two_le("a", c(blank, NA, letters))`   = two_le("a", c(blank, NA, letters))  ,
       `two_lt("a", c(blank, NA, letters))`   = two_lt("a", c(blank, NA, letters))  ,
       `two_mf(NULL, blank, combo)`           = two_mf(NULL, blank, combo)          ,
       `two_nav(c(blank, NA, letters))`       = two_nav(c(blank, NA, letters))      ,
       `two_nav(chr.mat)`                     = two_nav(chr.mat)                    ,
       `two_okv(c(blank, NA, letters))`       = two_okv(c(blank, NA, letters))      ,
       `two_okv(chr.mat)`                     = two_okv(chr.mat)                    ,
       `two_t(c(list(blank), combo))`         = two_t(c(list(blank), combo))        ,
       `two_tf(c(list(blank), combo))`        = two_tf(c(list(blank), combo))       )
}
egfailsafe()
}
\seealso{
Other extensions: 
\code{\link{N}()},
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{flex_rbind}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}()},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}

Other logicals: 
\code{\link{meets}()}

Other errs: 
\code{\link{stopperr}()}
}
\concept{errs}
\concept{extensions}
\concept{logicals}
