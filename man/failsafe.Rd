% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/failsafe.R
\encoding{UTF-8}
\name{failsafe}
\alias{failsafe}
\alias{is_err}
\alias{not_err}
\alias{msg_err}
\alias{make_err}
\alias{fs_def}
\alias{fs_nll}
\alias{fs_scl}
\alias{fs_t}
\alias{fs_f}
\alias{fs_tf}
\alias{fs_na}
\alias{fs_ok}
\alias{fs_bl}
\alias{fs_lg}
\alias{fs_vec}
\alias{fs_null}
\alias{scl_bl}
\alias{scl_t}
\alias{scl_f}
\alias{scl_tf}
\alias{scl_lg}
\alias{scl_na}
\alias{vec_bl}
\alias{vec_t}
\alias{vec_f}
\alias{vec_tf}
\alias{vec_na}
\alias{fs_or}
\alias{or_f}
\alias{or_t}
\alias{or_bl}
\alias{or_c0}
\alias{or_i0}
\alias{or_l0}
\alias{or_n0}
\alias{or_na}
\alias{or_nac}
\alias{or_naI}
\alias{or_naL}
\alias{or_naR}
\alias{or_null}
\alias{is_id}
\alias{not_id}
\alias{is_in0}
\alias{is_mf0}
\alias{has0}
\alias{lacks0}
\alias{is_eq0}
\alias{is_ge0}
\alias{is_gt0}
\alias{is_le0}
\alias{is_lt0}
\alias{is_dif0}
\alias{is_f0}
\alias{is_t0}
\alias{is_bl0}
\alias{is_tf0}
\alias{is_na0}
\alias{is_ok0}
\alias{is_lg0}
\alias{is_in}
\alias{is_mf}
\alias{has}
\alias{lacks}
\alias{is_eq}
\alias{is_ge}
\alias{is_gt}
\alias{is_le}
\alias{is_lt}
\alias{is_dif}
\alias{is_f}
\alias{is_t}
\alias{is_bl}
\alias{is_tf}
\alias{is_nav}
\alias{is_okv}
\alias{is_seq}
\alias{is_veq}
\alias{is_sdif}
\alias{is_vdif}
\alias{or0}
\alias{and0}
\alias{xor0}
\alias{nor0}
\alias{or}
\alias{and}
\alias{one}
\alias{nor}
\alias{not_in0}
\alias{not_mf0}
\alias{not_has0}
\alias{not_lacks0}
\alias{not_eq0}
\alias{not_ge0}
\alias{not_gt0}
\alias{not_le0}
\alias{not_lt0}
\alias{not_dif0}
\alias{not_f0}
\alias{not_t0}
\alias{not_tf0}
\alias{not_bl0}
\alias{not_na0}
\alias{not_ok0}
\alias{not_lg0}
\alias{not_in}
\alias{not_mf}
\alias{not_has}
\alias{not_lacks}
\alias{not_eq}
\alias{not_ge}
\alias{not_gt}
\alias{not_le}
\alias{not_lt}
\alias{not_dif}
\alias{not_f}
\alias{not_t}
\alias{not_tf}
\alias{not_bl}
\alias{not_nav}
\alias{not_okv}
\alias{not_seq}
\alias{not_veq}
\alias{not_sdif}
\alias{not_vdif}
\alias{n_in}
\alias{n_mf}
\alias{n_has}
\alias{n_lacks}
\alias{n_eq}
\alias{n_ge}
\alias{n_gt}
\alias{n_le}
\alias{n_lt}
\alias{n_dif}
\alias{n_f}
\alias{n_t}
\alias{n_tf}
\alias{n_bl}
\alias{n_nav}
\alias{n_okv}
\alias{none_f}
\alias{none_t}
\alias{none_tf}
\alias{none_bl}
\alias{none_eq}
\alias{none_ge}
\alias{none_gt}
\alias{none_le}
\alias{none_lt}
\alias{none_in}
\alias{none_mf}
\alias{none_dif}
\alias{none_nav}
\alias{none_okv}
\alias{has_none}
\alias{lacks_none}
\alias{any_f}
\alias{any_t}
\alias{any_bl}
\alias{any_eq}
\alias{any_ge}
\alias{any_gt}
\alias{any_in}
\alias{any_le}
\alias{any_lt}
\alias{any_mf}
\alias{any_tf}
\alias{any_dif}
\alias{any_nav}
\alias{any_okv}
\alias{has_any}
\alias{lacks_any}
\alias{one_f}
\alias{one_t}
\alias{one_bl}
\alias{one_eq}
\alias{one_ge}
\alias{one_gt}
\alias{one_in}
\alias{one_le}
\alias{one_lt}
\alias{one_mf}
\alias{one_tf}
\alias{one_dif}
\alias{one_nav}
\alias{one_okv}
\alias{has_one}
\alias{lacks_one}
\alias{all_f}
\alias{all_t}
\alias{all_bl}
\alias{all_eq}
\alias{all_ge}
\alias{all_gt}
\alias{all_in}
\alias{all_le}
\alias{all_lt}
\alias{all_mf}
\alias{all_tf}
\alias{all_dif}
\alias{all_nav}
\alias{all_okv}
\alias{has_all}
\alias{lacks_all}
\alias{some_f}
\alias{some_t}
\alias{some_bl}
\alias{some_eq}
\alias{some_le}
\alias{some_ge}
\alias{some_gt}
\alias{some_in}
\alias{some_lt}
\alias{some_mf}
\alias{some_tf}
\alias{some_dif}
\alias{some_nav}
\alias{some_okv}
\alias{has_some}
\alias{lacks_some}
\alias{two_f}
\alias{two_t}
\alias{two_bl}
\alias{two_eq}
\alias{two_ge}
\alias{two_gt}
\alias{two_in}
\alias{two_le}
\alias{two_lt}
\alias{two_mf}
\alias{two_tf}
\alias{two_dif}
\alias{two_nav}
\alias{two_okv}
\alias{has_two}
\alias{lacks_two}
\alias{many_f}
\alias{many_t}
\alias{many_bl}
\alias{many_eq}
\alias{many_ge}
\alias{many_gt}
\alias{many_in}
\alias{many_le}
\alias{many_lt}
\alias{many_mf}
\alias{many_tf}
\alias{many_dif}
\alias{many_nav}
\alias{many_okv}
\alias{has_many}
\alias{lacks_many}
\alias{\%.in0.\%}
\alias{\%.mf0.\%}
\alias{\%.eq0.\%}
\alias{\%.ge0.\%}
\alias{\%.gt0.\%}
\alias{\%.le0.\%}
\alias{\%.lt0.\%}
\alias{\%.has0.\%}
\alias{\%.dif0.\%}
\alias{\%.lacks0.\%}
\alias{\%.in.\%}
\alias{\%.mf.\%}
\alias{\%.eq.\%}
\alias{\%.ge.\%}
\alias{\%.gt.\%}
\alias{\%.le.\%}
\alias{\%.lt.\%}
\alias{\%.has.\%}
\alias{\%.dif.\%}
\alias{\%.lacks.\%}
\alias{\%.seq.\%}
\alias{\%.veq.\%}
\alias{\%.neq.\%}
\alias{\%.sdif.\%}
\alias{\%.vdif.\%}
\alias{\%.ndif.\%}
\alias{\%.or0.\%}
\alias{\%.and0.\%}
\alias{\%.xor0.\%}
\alias{\%.nor0.\%}
\alias{\%.or.\%}
\alias{\%.and.\%}
\alias{\%.xor.\%}
\alias{\%.nor.\%}
\title{failsafe functions that \strong{always} return a valid object.}
\usage{
failsafe(x, def = "uj.failsafe.err")

is_err(x)

not_err(x)

msg_err(x)

make_err()

fs_def(x)

fs_nll(x)

fs_scl(x, val)

fs_t(x)

fs_f(x)

fs_tf(x)

fs_na(x)

fs_ok(x)

fs_bl(x)

fs_lg(x)

fs_vec(x, val)

fs_null(x)

scl_bl(x)

scl_t(x)

scl_f(x)

scl_tf(x)

scl_lg(x)

scl_na(x)

vec_bl(x)

vec_t(x)

vec_f(x)

vec_tf(x)

vec_na(x)

fs_or(x, or = NULL)

or_f(x)

or_t(x)

or_bl(x)

or_c0(x)

or_i0(x)

or_l0(x)

or_n0(x)

or_na(x)

or_nac(x)

or_naI(x)

or_naL(x)

or_naR(x)

or_null(x)

is_id(x, y)

not_id(x, y)

is_in0(x, ...)

is_mf0(x, ...)

has0(x, y)

lacks0(x, y)

is_eq0(x, y)

is_ge0(x, y)

is_gt0(x, y)

is_le0(x, y)

is_lt0(x, y)

is_dif0(x, y)

is_f0(x)

is_t0(x)

is_bl0(x)

is_tf0(x)

is_na0(x)

is_ok0(x)

is_lg0(x)

is_in(x, ...)

is_mf(x, ...)

has(x, y)

lacks(x, y)

is_eq(x, y)

is_ge(x, y)

is_gt(x, y)

is_le(x, y)

is_lt(x, y)

is_dif(x, y)

is_f(x)

is_t(x)

is_bl(x)

is_tf(x)

is_nav(x)

is_okv(x)

is_seq(x, y)

is_veq(x, y)

is_sdif(x, y)

is_vdif(x, y)

or0(x, y)

and0(x, y)

xor0(x, y)

nor0(x, y)

or(x, y)

and(x, y)

one(x, y)

nor(x, y)

not_in0(x, ...)

not_mf0(x, ...)

not_has0(x, y)

not_lacks0(x, y)

not_eq0(x, y)

not_ge0(x, y)

not_gt0(x, y)

not_le0(x, y)

not_lt0(x, y)

not_dif0(x, y)

not_f0(x)

not_t0(x)

not_tf0(x)

not_bl0(x)

not_na0(x)

not_ok0(x)

not_lg0(x)

not_in(x, ...)

not_mf(x, ...)

not_has(x, y)

not_lacks(x, y)

not_eq(x, y)

not_ge(x, y)

not_gt(x, y)

not_le(x, y)

not_lt(x, y)

not_dif(x, y)

not_f(x)

not_t(x)

not_tf(x)

not_bl(x)

not_nav(x)

not_okv(x)

not_seq(x, y)

not_veq(x, y)

not_sdif(x, y)

not_vdif(x, y)

n_in(x, ...)

n_mf(x, ...)

n_has(x, y)

n_lacks(x, y)

n_eq(x, y)

n_ge(x, y)

n_gt(x, y)

n_le(x, y)

n_lt(x, y)

n_dif(x, y)

n_f(x)

n_t(x)

n_tf(x)

n_bl(x)

n_nav(x)

n_okv(x)

none_f(x)

none_t(x)

none_tf(x)

none_bl(x)

none_eq(x, y)

none_ge(x, y)

none_gt(x, y)

none_le(x, y)

none_lt(x, y)

none_in(x, ...)

none_mf(x, ...)

none_dif(x, y)

none_nav(x)

none_okv(x)

has_none(x, y)

lacks_none(x, y)

any_f(x)

any_t(x)

any_bl(x)

any_eq(x, y)

any_ge(x, y)

any_gt(x, y)

any_in(x, ...)

any_le(x, y)

any_lt(x, y)

any_mf(x, ...)

any_tf(x)

any_dif(x, y)

any_nav(x)

any_okv(x)

has_any(x, y)

lacks_any(x, y)

one_f(x)

one_t(x)

one_bl(x)

one_eq(x, y)

one_ge(x, y)

one_gt(x, y)

one_in(x, ...)

one_le(x, y)

one_lt(x, y)

one_mf(x, ...)

one_tf(x)

one_dif(x, y)

one_nav(x)

one_okv(x)

has_one(x, y)

lacks_one(x, y)

all_f(x)

all_t(x)

all_bl(x)

all_eq(x, y)

all_ge(x, y)

all_gt(x, y)

all_in(x, ...)

all_le(x, y)

all_lt(x, y)

all_mf(x, ...)

all_tf(x)

all_dif(x, y)

all_nav(x)

all_okv(x)

has_all(x, y)

lacks_all(x, y)

some_f(x)

some_t(x)

some_bl(x)

some_eq(x, y)

some_le(x, y)

some_ge(x, y)

some_gt(x, y)

some_in(x, ...)

some_lt(x, y)

some_mf(x, ...)

some_tf(x)

some_dif(x, y)

some_nav(x)

some_okv(x)

has_some(x, y)

lacks_some(x, y)

two_f(x)

two_t(x)

two_bl(x)

two_eq(x, y)

two_ge(x, y)

two_gt(x, y)

two_in(x, ...)

two_le(x, y)

two_lt(x, y)

two_mf(x, ...)

two_tf(x)

two_dif(x, y)

two_nav(x)

two_okv(x)

has_two(x, y)

lacks_two(x, y)

many_f(x)

many_t(x)

many_bl(x)

many_eq(x, y)

many_ge(x, y)

many_gt(x, y)

many_in(x, ...)

many_le(x, y)

many_lt(x, y)

many_mf(x, ...)

many_tf(x)

many_dif(x, y)

many_nav(x)

many_okv(x)

has_many(x, y)

lacks_many(x, y)

x \%.in0.\% y

x \%.mf0.\% y

x \%.eq0.\% y

x \%.ge0.\% y

x \%.gt0.\% y

x \%.le0.\% y

x \%.lt0.\% y

x \%.has0.\% y

x \%.dif0.\% y

x \%.lacks0.\% y

x \%.in.\% y

x \%.mf.\% y

x \%.eq.\% y

x \%.ge.\% y

x \%.gt.\% y

x \%.le.\% y

x \%.lt.\% y

x \%.has.\% y

x \%.dif.\% y

x \%.lacks.\% y

x \%.seq.\% y

x \%.veq.\% y

x \%.neq.\% y

x \%.sdif.\% y

x \%.vdif.\% y

x \%.ndif.\% y

x \%.or0.\% y

x \%.and0.\% y

x \%.xor0.\% y

x \%.nor0.\% y

x \%.or.\% y

x \%.and.\% y

x \%.xor.\% y

x \%.nor.\% y
}
\arguments{
\item{x, y}{Any objects for failsafe binary functions and miscellaneous failsafe functions.}

\item{val}{An atomic scalar.}

\item{or}{An object to return if evaluating \code{x} produces an error.}

\item{x}{An object or a call_ to evaluate in the environment of a parent function where the initial call_ was made.}
}
\value{
A logical scalar or vector.
}
\description{
Evaluate objects, test if an object has certain properties, and conduct binary logical operations safely. these functions never stop execution; they always produce a valid result, even if that result is an error object.
}
\details{
failsafe binary comparison functions: these are binary functions that always produce either scalar \code{TRUE} or scalar \code{FALSE}. they return \code{TRUE} when two variables meet the conditions shown in the following table and \code{FALSE} in every other circumstance (where \code{fx} and \code{fy})
\tabular{ll}{  \verb{\%.is.\%}       \tab \code{failsafe(identical(x, y))}                                  \cr
  \verb{\%.isnt.\%}     \tab \code{!(x \%.is.\% y)}                                              \cr   \tab   \cr
  \verb{\%.in.\%}       \tab \code{sapply(failsafe(x \%in\% y), isTRUE)}                         \cr
  \verb{\%.mf.\%}       \tab \code{!(x \%.in.\% y)} (missing from)                               \cr
  \verb{\%.has.\%}      \tab \code{y \%.in.\% x} (\code{x} has each \code{y} value)                        \cr
  \verb{\%.lacks.\%}    \tab \code{y \%.mf.\% x} (\code{x} lacks each \code{y} value)                      \cr   \tab   \cr
  \verb{\%.in0.\%}      \tab if \code{x} is atomic scalar, \code{x \%.in.\% y}, otherwise \code{FALSE}     \cr
  \verb{\%.mf0.\%}      \tab \code{x} is atomic scalar and \code{x \%.mf.\% y}                        \cr
  \verb{\%.has0.\%}     \tab \code{y} is atomic scalar and \code{x \%.has.\% y}                       \cr
  \verb{\%.lacks0.\%}   \tab \code{y} is atomic scalar and \code{x \%.lacks.\% y}                     \cr   \tab   \cr
  \verb{\%.eq.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x = y}, otherwise \code{FALSE} \cr
  \verb{\%.ge.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≥ y}, otherwise \code{FALSE} \cr
  \verb{\%.gt.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x > y}, otherwise \code{FALSE} \cr
  \verb{\%.le.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≤ y}, otherwise \code{FALSE} \cr
  \verb{\%.lt.\%}       \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \code{x < y}, otherwise \code{FALSE} \cr
  \verb{\%.dif.\%}      \tab If \code{x} and \code{y} match\eqn{^{(1)}}, \verb{x ≠ y}, otherwise \code{TRUE}  \cr   \tab   \cr
  \verb{\%.eq0.\%}      \tab \code{x} and \code{y} are atomic scalar and \code{x = y}  \eqn{^{(2)}}      \cr
  \verb{\%.ge0.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≥ y}  \eqn{^{(2)}}      \cr
  \verb{\%.gt0.\%}      \tab \code{x} and \code{y} are atomic scalar and \code{x > y}  \eqn{^{(2)}}      \cr
  \verb{\%.le0.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≤ y}  \eqn{^{(2)}}      \cr
  \verb{\%.lt0.\%}      \tab \code{x} and \code{y} are atomic scalar and \verb{x ≥ y}  \eqn{^{(2)}}      \cr
  \verb{\%.dif0.\%}     \tab \code{x} and \code{y} are \emph{not} atomic scalar equal  \eqn{^{(3)}}      \cr   \tab   \cr
  \verb{\%.seq.\%}      \tab \code{x} and \code{y} are \code{\link[base]{setequal}}\eqn{^{(4)}}     \cr
  \verb{\%.veq.\%}      \tab \code{x} and \code{y} are vector equal\eqn{^{(5)}}                     \cr
  \verb{\%.sdif.\%}     \tab \code{x} and \code{y} are set different\eqn{^{(6)}}                    \cr
  \verb{\%.vdif.\%}     \tab \code{x} and \code{y} are vector different\eqn{^{(7)}}                 \cr   \tab   \cr
  \verb{\%.or.\%}       \tab values of \code{x} \emph{and/or} \code{y} are \code{TRUE}                        \cr
  \verb{\%.and.\%}      \tab values of \code{x} \emph{and} \code{y} are \code{TRUE}                           \cr
  \verb{\%.xor.\%}      \tab values of \emph{either} \code{x} \emph{or} \code{y} are \code{TRUE}                   \cr
  \verb{\%.nor.\%}      \tab values of \emph{neither} \code{x} \emph{nor} \code{y} are \code{TRUE}                 \cr   \tab   \cr
  \verb{\%.or0.\%}      \tab \code{x} \emph{and/or} \code{y} are scalar \code{TRUE}                           \cr
  \verb{\%.and0.\%}     \tab \code{x} \emph{and} \code{y} are scalar \code{TRUE}                              \cr
  \verb{\%.xor0.\%}     \tab \emph{either} \code{x} \emph{or} \code{y} is scalar \code{TRUE}                       \cr
  \verb{\%.nor0.\%}     \tab \emph{neither} \code{x} \emph{nor} \code{y} is scalar \code{TRUE}                     \cr   \tab     }
\tabular{l}{  \eqn{^{(1)}} Of equal length and \link[=compatible]{compatible modes}.                                                       \cr
  \eqn{^{(2)}} Of \link[=compatible]{compatible modes} and meeting the (in)equality.                                           \cr
  \eqn{^{(3)}} not meeting the requirements of \verb{\%.eq0.\%}.                                                                      \cr
  \eqn{^{(4)}} atomic, of the same length, with the same values in the same order.                                             \cr
  \eqn{^{(5)}} atomic, possibly of different lengths, and containing the same unique values regardless of order or duplicates. \cr
  \eqn{^{(6)}} not meeting the requirements of \verb{\%.seq.\%}.                                                                      \cr
  \eqn{^{(7)}} not meeting the requirements of \verb{\%.veq.\%}.                                                                        }
}
\section{failsafe error management functions}{
 these functions evaluate generate, check for, and manage error objects.
\tabular{ll}{  \code{make_err}   \tab generate object of class \code{'simpleError'}.      \cr
  \code{msg_err}    \tab get error message, if any_; otherwise, \code{NULL}. \cr
  \code{not_err}    \tab Does evaluating \code{x} not_ produce an error?.    \cr
  \code{is_err}     \tab Does evaluating \code{x} produce an error?           }
}

\section{failsafe check for classes of objects with values}{

\tabular{ll}{  \code{failsafe}   \tab Returns \code{x} if identity evaluation does not_ cause an error. Returns
an error object otherwise with the attribute \code{stack = uj::callers()}. \cr   \tab   \cr
  \code{fs_null}    \tab \code{x} is \code{NULL}.                                                        \cr
  \code{fs_def}     \tab \code{x} is defined (not_ \code{NULL}).                                         \cr   \tab   \cr
  \code{fs_scl}     \tab \code{x} is scalar of a specific atomic value.                             \cr
  \code{fs_t}       \tab \code{x} is scalar \code{TRUE}.                                                 \cr
  \code{fs_f}       \tab \code{x} is scalar \code{FALSE}.                                                \cr
  \code{fs_na}      \tab \code{x} is scalar \code{NA}.                                                   \cr
  \code{fs_tf}      \tab \code{x} is scalar \code{TRUE} or scalar \code{FALSE}.                               \cr
  \code{scl_f}      \tab \code{x} is scalar \code{FALSE}                                                 \cr
  \code{scl_t}      \tab \code{x} is scalar \code{TRUE}                                                  \cr
  \code{scl_tf}     \tab \code{x} is scalar \code{TRUE} or \code{FALSE}.                                      \cr
  \code{scl_lg}     \tab \code{x} is scalar \code{TRUE}, \code{FALSE}, or \code{NA}.                               \cr
  \code{scl_bl}     \tab \code{x} is blank string scalar (\code{""}).                                    \cr
  \code{scl_na}     \tab \code{x} is scalar \code{NA}                                                    \cr   \tab   \cr
  \code{fs_vec}     \tab Elements of \code{x} are of a specific atomic value.                       \cr
  \code{vec_f}      \tab Elements of \code{x} are \code{FALSE}.                                          \cr
  \code{vec_t}      \tab Elements of \code{x} are \code{TRUE}.                                           \cr
  \code{vec_tf}     \tab Elements of \code{x} are \code{TRUE} or \code{FALSE}.                                \cr
  \code{vec_lg}     \tab Elements of \code{x} are \code{TRUE}, \code{FALSE}, or \code{NA}.                         \cr
  \code{vec_bl}     \tab Elements of \code{x} are blank strings.                                    \cr
  \code{vec_na}     \tab Elements of \code{x} are \code{NA}.                                               }
}

\section{failsafe forced-evaluation functions with conditional return values}{
 these functions \link[base:force]{force} evaluation of \code{x} returning values as shown in the following table with the first value returned when forcing evaluation does not_ produce an error and the second when it does:
\tabular{ll}{  \code{fs_or}    \tab \code{x} or something else if evaluating \code{x} produces an error \cr   \tab   \cr
  \code{or_f}     \tab \code{x} or \code{FALSE}                                            \cr
  \code{or_t}     \tab \code{x} or \code{TRUE}                                             \cr   \tab   \cr
  \code{or_c0}    \tab \code{x} or \code{character(0)}                                     \cr
  \code{or_i0}    \tab \code{x} or \code{integer(0)}                                       \cr
  \code{or_l0}    \tab \code{x} or \code{logical(0)}                                       \cr
  \code{or_n0}    \tab \code{x} or \code{numeric(0)}                                       \cr   \tab   \cr
  \code{or_bl}    \tab \code{x} or \code{""}                                               \cr   \tab   \cr
  \code{or_na}    \tab \code{x} or \code{NA}                                               \cr
  \code{or_nac}   \tab \code{x} or \code{Na_character_}                                    \cr
  \code{or_nai}   \tab \code{x} or \code{Na_integer_}                                      \cr
  \code{or_nal}   \tab \code{x} or \code{NA} (logical)                                     \cr
  \code{or_nar}   \tab \code{x} or \code{Na_real_}                                           }
}

\section{failsafe scalar value, membership, and equality/inequality checking functions}{
 these functions check for class, mode, and/or value and/or count the number of checks passed. they \emph{always} produce \code{TRUE}, \code{FALSE}, or an integer scalar.
\cr\cr function names are constructed of root words, prefixes, and/or suffixes. Root word specify the type of check conducted. Prefixes and suffixes specify how to modify the results of a check or how to apply the check to each \code{...} argument and check whether a certain number of \code{...} args passed the checks.
\cr\cr \strong{\emph{Root words for atomic scalar value checking functions}}
\tabular{ll}{  \code{nav}   \tab \code{x} is atomic and values are \code{NA}                      \cr
  \code{okv}   \tab \code{x} is atomic and values are \emph{not} \code{NA}                \cr
  \code{bl}    \tab \code{x} is atomic and values are blanks (\code{""})             \cr
  \code{lg}    \tab \code{x} is atomic and values are \code{TRUE}, \code{FALSE}, or \code{NA}. \cr
  \code{tf}    \tab \code{x} is atomic and values are \code{TRUE} or \code{FALSE}.        \cr
  \code{f}     \tab \code{x} is atomic and values are \code{TRUE}.                   \cr
  \code{t}     \tab \code{x} is atomic and valules are \code{FALSE}.                   }
\cr \strong{\emph{Root words for atomic value membership checking functions}}
\tabular{ll}{  \code{lacks}   \tab \code{x \%.lacks.\% y} \cr
  \code{has}     \tab \code{x \%.has.\% y}   \cr
  \verb{in}      \tab \code{x \%.in.\% y}    \cr
  \code{mf}      \tab \code{x \%.mf.\% y}      }
\cr \strong{\emph{Root words for equality/inequality checking functions}}
\tabular{ll}{  \code{id}     \tab objects are identical                \cr
  \code{eq}     \tab values are equal                     \cr
  \code{seq}    \tab values are set equal                 \cr
  \code{veq}    \tab values are vector equal              \cr
  \code{dif}    \tab values are different                 \cr
  \code{sdif}   \tab values are set different             \cr
  \code{vdif}   \tab values are vector different          \cr
  \code{ge}     \tab \code{x} is greater than or equal to \code{y}. \cr
  \code{gt}     \tab \code{x} is greater than \code{y}.             \cr
  \code{le}     \tab \code{x} is less than or equal to \code{y}.    \cr
  \code{lt}     \tab \code{x} is less than \code{y}.                  }
\cr \strong{\emph{Modifier prefixes/suffixes}}
\tabular{ll}{  \code{n}      \tab count \code{...} args passing the check. \cr
  \code{is}     \tab Keep the result of a check as is.   \cr
  \code{not}    \tab Negate the result of a check.         }
\cr \strong{\emph{apply-and-sweep prefixes/suffixes evaluating whether a certain number of checks were passed}}
\cr\cr the following table contains prefixes in the first column, and in the second, the number of checks that must be passed to return \code{TRUE}.
\tabular{ll}{  \code{none}   \tab \code{0} values passed the check.   \cr
  \code{any}    \tab \verb{> 0} values passed the check. \cr
  \code{one}    \tab \code{1} value passed the check.    \cr
  \code{some}   \tab \verb{> 1} values passed the check. \cr
  \code{two}    \tab \code{2} values passed the check.   \cr
  \code{many}   \tab \verb{> 2} values passed the check. \cr
  \code{all}    \tab all values passed the check.    }
\cr \strong{\emph{Identity-equality, set-equality and vector-equality checking functions}}
\tabular{lll}{             \tab \strong{is}       \tab \strong{not}    \cr
  \strong{id}     \tab \code{is_id}      \tab \code{not_id}   \cr
  \strong{seq}    \tab \code{is_seq}     \tab \code{not_deq}  \cr
  \strong{veq}    \tab \code{is_veq}     \tab \code{not_veq}  \cr
  \strong{sdif}   \tab \code{is_sdif}    \tab \code{not_sdif} \cr
  \strong{vdif}   \tab \code{is_vdif}    \tab \code{not_vdif}   }
\cr \strong{\emph{atomic scalar value checking functions}}
\tabular{lll}{              \tab \strong{is}      \tab \strong{not}    \cr
  \strong{TRUE}    \tab \code{is_t0}     \tab \code{not_t0}   \cr
  \strong{FALSE}   \tab \code{is_f0}     \tab \code{not_f0}   \cr
  \strong{tf}      \tab \code{is_tf0}    \tab \code{not_tf0}  \cr
  \strong{lg}      \tab \code{is_lg0}    \tab \code{not_lg0}  \cr
  \strong{bl}      \tab \code{is_bl0}    \tab \code{not_bl0}  \cr
  \strong{eq}      \tab \code{is_eq0}    \tab \code{not_eq0}  \cr
  \strong{ge}      \tab \code{is_ge0}    \tab \code{not_ge0}  \cr
  \strong{gt}      \tab \code{is_gt0}    \tab \code{not_gt0}  \cr
  \strong{le}      \tab \code{is_le0}    \tab \code{not_le0}  \cr
  \strong{lt}      \tab \code{is_lt0}    \tab \code{not_lt0}  \cr
  \strong{nav}     \tab \code{is_nav}    \tab \code{not_nav}  \cr
  \strong{okv}     \tab \code{is_okv}    \tab \code{not_okv}  \cr
  \strong{dif}     \tab \code{is_dif0}   \tab \code{not_dif0}   }
\cr \strong{\emph{atomic scalar value membership checking functions}}
\tabular{lll}{              \tab \strong{is}      \tab \strong{not}    \cr
  \strong{in}      \tab \code{is_in0}    \tab \code{not_in0}  \cr
  \strong{mf}      \tab \code{is_mf0}    \tab \code{not_mf0}  \cr
  \strong{has}     \tab \code{has0}      \tab \code{not_has0} \cr
  \strong{lacks}   \tab \code{lacks0}    \tab \code{not_lacks0} }
\cr \strong{\emph{atomic value checking functions}}
\tabular{lllllllllll}{              \tab \strong{is}     \tab \strong{n}     \tab \strong{not_}       \tab \strong{none}       \tab \strong{one}       \tab \strong{two}       \tab \strong{any}       \tab  \strong{some}      \tab  \strong{many}      \tab  \strong{all_} \cr
  \strong{TRUE}    \tab \code{is_t}     \tab \code{n_t}     \tab \code{not_t}        \tab \code{none_t}       \tab \code{one_t}       \tab \code{two_t}       \tab \code{any_t}       \tab \code{some_t}       \tab \code{many_t}       \tab \code{all_t}   \cr
  \strong{FALSE}   \tab \code{is_f}     \tab \code{n_f}     \tab \code{not_f}        \tab \code{none_f}       \tab \code{one_f}       \tab \code{two_f}       \tab \code{any_f}       \tab \code{some_f}       \tab \code{many_f}       \tab \code{all_f}   \cr
  \strong{tf}      \tab \code{is_tf}    \tab \code{n_tf}    \tab \code{not_tf}       \tab \code{none_tf}      \tab \code{one_tf}      \tab \code{two_tf}      \tab \code{any_tf}      \tab \code{some_tf}      \tab \code{many_tf}      \tab \code{all_tf}  \cr
  \strong{bl}      \tab \code{is_bl}    \tab \code{n_bl}    \tab \code{not_bl}       \tab \code{none_bl}      \tab \code{one_bl}      \tab \code{two_bl}      \tab \code{any_bl}      \tab \code{some_bl}      \tab \code{many_bl}      \tab \code{all_bl}  \cr
  \strong{eq}      \tab \code{is_eq}    \tab \code{n_eq}    \tab \code{not_eq}       \tab \code{none_eq}      \tab \code{one_eq}      \tab \code{two_eq}      \tab \code{any_eq}      \tab \code{some_eq}      \tab \code{many_eq}      \tab \code{all_eq}  \cr
  \strong{ge}      \tab \code{is_ge}    \tab \code{n_ge}    \tab \code{not_ge}       \tab \code{none_ge}      \tab \code{one_ge}      \tab \code{two_ge}      \tab \code{any_ge}      \tab \code{some_ge}      \tab \code{many_ge}      \tab \code{all_ge}  \cr
  \strong{gt}      \tab \code{is_gt}    \tab \code{n_gt}    \tab \code{not_gt}       \tab \code{none_gt}      \tab \code{one_gt}      \tab \code{two_gt}      \tab \code{any_gt}      \tab \code{some_gt}      \tab \code{many_gt}      \tab \code{all_gt}  \cr
  \strong{le}      \tab \code{is_le}    \tab \code{n_le}    \tab \code{not_le}       \tab \code{none_le}      \tab \code{one_le}      \tab \code{two_le}      \tab \code{any_le}      \tab \code{some_le}      \tab \code{many_le}      \tab \code{all_le}  \cr
  \strong{lt}      \tab \code{is_lt}    \tab \code{n_lt}    \tab \code{not_lt}       \tab \code{none_lt}      \tab \code{one_lt}      \tab \code{two_lt}      \tab \code{any_lt}      \tab \code{some_lt}      \tab \code{many_lt}      \tab \code{all_lt}  \cr
  \strong{dif}     \tab \code{is_dif}   \tab \code{n_dif}   \tab \code{not_dif}      \tab \code{none_dif}     \tab \code{one_dif}     \tab \code{two_dif}     \tab \code{any_dif}     \tab \code{some_dif}     \tab \code{many_dif}     \tab \code{all_dif} \cr
  \strong{nav}     \tab \code{is_nav}   \tab \code{n_nav}   \tab \code{not_nav}      \tab \code{none_nav}     \tab \code{one_nav}     \tab \code{two_nav}     \tab \code{any_nav}     \tab \code{some_nav}     \tab \code{many_nav}     \tab \code{all_nav} \cr
  \strong{okv}     \tab \verb{is_okv  } \tab \code{n_okv}   \tab \code{not_okv}      \tab \code{none_okv}     \tab \code{one_okv}     \tab \code{two_okv}     \tab \code{any_okv}     \tab \code{some_okv}     \tab \code{many_okv}     \tab \code{all_okv}   }
\cr \strong{\emph{atomic value membership checking functions}}
\tabular{lllllllllll}{              \tab \strong{is}    \tab \strong{n}       \tab \strong{not_}      \tab \strong{none}       \tab \strong{one}       \tab \strong{two}       \tab \strong{any}       \tab \strong{some}       \tab \strong{many}       \tab \strong{all}   \cr
  \strong{in}      \tab \code{is_in}   \tab \code{n_in}      \tab \code{not_in}      \tab \code{in_none}      \tab \code{in_one}      \tab \code{in_two}      \tab \code{in_any}      \tab \code{in_some}      \tab \code{in_many}      \tab \code{in_all}  \cr
  \strong{mf}      \tab \code{is_mf}   \tab \code{n_mf}      \tab \code{not_mf}      \tab \code{mf_none}      \tab \code{mf_one}      \tab \code{mf_two}      \tab \code{mf_any}      \tab \code{mf_some}      \tab \code{mf_many}      \tab \code{mf_all}  \cr
  \strong{has}     \tab \code{has}     \tab \code{n_has}     \tab \code{not_has}     \tab \code{has_none}     \tab \code{has_one}     \tab \code{has_two}     \tab \code{has_any}     \tab \code{has_some}     \tab \code{has_many}     \tab \code{has_all} \cr
  \strong{lacks}   \tab \code{locks}   \tab \code{n_lacks}   \tab \code{not_lacks}   \tab \code{lacks_none}   \tab \code{lacks_one}   \tab \code{lacks_two}   \tab \code{lacks_any}   \tab \code{lacks_some}   \tab \code{lacks_many}   \tab \code{lacks_all} }
}

\examples{
egfailsafe <- function() {
  abc <- c("a", "b", "c")
  abc <- abc
  blank <- ""
  mss.scl <- Na
  lgl.scl <- FALSE
  fac.scl <- factor("q", levels = c("x", "q"))
  fac.vec <- factor(c("x", "q"), levels = c("x", "q"))
  chr.mat <- matrix(c("a", "b", "c", "Na"), nrow = 2)
  chr.dtf <- data.frame(abc = letters[1:3], def = letters[4:6])
  num.vls <- list(first3 = c(1:3, NA), next3 = c(4:6, NA))
  combo <- list(mss.scl, lgl.scl, fac.vec, chr.mat, chr.dtf, numvls)
  attr(abc, "custom") <- "custom"
  list(`"a" \%.and0.\% FALSE`                   = "a" \%.and.\% FALSE                   ,
       `"a" \%.in0.\% abc`                      = "a" \%.in.\% abc                      ,
       `"a" \%.nor0.\% FALSE`                   = "a" \%.or.\% FALSE                    ,
       `"a" \%.xor0.\% FALSE`                   = "a" \%.cor.\% FALSE                   ,
       `"a" \%.or0.\% FALSE`                    = "a" \%.or.\% FALSE                    ,
       `"a" \%.mf0.TRUE\% abc`                  = "a" \%.mf.\% abc                      ,
       `"a" \%.and.\% FALSE`                    = "a" \%.and.\% FALSE                   ,
       `abs \%.in.\% abc`                       = "a" \%.in.\% abc                      ,
       `"a" \%.nor.\% FALSE`                    = "a" \%.or.\% FALSE                    ,
       `"a" \%.xor.\% FALSE`                    = "a" \%.cor.\% FALSE                   ,
       `"a" \%.or.\% FALSE`                     = "a" \%.or.\% FALSE                    ,
       `"a" \%.mf.\% abc`                       = "a" \%.mf.\% abc                      ,
       `1 \%.in.\% abc`                         = 1 \%.in.\% abc                        ,
       `1 \%.mf.\% abc`                         = 1 \%.mf.\% abc                        ,
       `abc \%.eq0.\% abc`                      = abc \%.eq0.\% abc                     ,
       `abc \%.eq0.\% letters[1:3]`             = abc \%.eq0.\% letters[1:3]            ,
       `abc \%.eq0.\% NULL`                     = abc \%.eq0.\% NULL                    ,
       `abc \%.has0.\% "a"`                     = abc \%.has.\% "a"                     ,
       `abc \%.has0.\% 1`                       = abc \%.has.\% 1                       ,
       `abc \%.has0.\% NULL`                    = abc \%.has.\% NULL                    ,
       `abc \%.has.\% letters[1:6]`             = abc \%.has.\% "a"                     ,
       `abc \%.has.\% 1:3`                      = abc \%.has.\% 1                       ,
       `abc \%.has.\% NULL`                     = abc \%.has.\% NULL                    ,
       `abc \%.is.\% NULL`                      = abc \%.is.\% NULL                     ,
       `abc \%.lacks0.\% "a"`                   = abc \%.lacks.\% "a"                   ,
       `abc \%.lacks0.\% 1`                     = abc \%.lacks.\% 1                     ,
       `abc \%.lacks0.\% NULL`                  = abc \%.lacks.\% NULL                  ,
       `abc \%.is.\% abc`                       = abc \%.is.\% abc                      ,
       `abc \%.is.\% letters[1:3]`              = abc \%.is.\% letters[1:3]             ,
       `abc \%.isnt.\% abc`                     = abc \%.isnt.\% abc                    ,
       `abc \%.isnt.\% letters[4:6]`            = abc \%.isnt.\% letters[4:6]           ,
       `all_bl(c(blank, letters))`            = all_bl(c(blank, letters))           ,
       `all_dif("a", c(blank, NA, letters))`  = all_dif("a", c(blank, NA, letters)) ,
       `all_eq(NA, c(blank, NA, letters))`    = all_eq(NA, c(blank, NA, letters))   ,
       `all_f(c(list(blank), combo))`         = all_f(c(list(blank), combo))        ,
       `all_ge("a", c(blank, NA, letters))`   = all_ge("a", c(blank, NA, letters))  ,
       `all_gt("a", c(blank, NA, letters))`   = all_gt("a", c(blank, NA, letters))  ,
       `all_in(NULL, blank, combo)`           = all_in(NULL, blank, combo)          ,
       `all_le("a", c(blank, NA, letters))`   = all_le("a", c(blank, NA, letters))  ,
       `all_lg(c(NA, TRUE, FALSE))`           = all_lg(c(NA, TRUE, FALSE))          ,
       `all_lt("a", c(blank, NA, letters))`   = all_lt("a", c(blank, NA, letters))  ,
       `all_mf(NULL, blank, combo)`           = all_mf(NULL, blank, combo)          ,
       `all_nav(c(blank, NA, letters))`       = all_nav(c(blank, NA, letters))      ,
       `all_nav(chr.mat)`                     = all_nav(chr.mat)                    ,
       `all_okv(c(blank, NA, letters))`       = all_okv(c(blank, NA, letters))      ,
       `all_okv(chr.mat)`                     = all_okv(chr.mat)                    ,
       `all_t(c(list(blank), combo))`         = all_t(c(list(blank), combo))        ,
       `all_tf(c(list(blank), combo))`        = all_tf(c(list(blank), combo))       ,
       `any_bl(c(blank, letters))`            = any_bl(c(blank, letters))           ,
       `any_dif("a", c(blank, NA, letters))`  = any_dif("a", c(blank, NA, letters)) ,
       `any_eq(NA, c(blank, NA, letters))`    = any_eq(NA, c(blank, NA, letters))   ,
       `any_f(c(list(blank), combo))`         = any_f(c(list(blank), combo))        ,
       `any_ge("a", c(blank, NA, letters))`   = any_ge("a", c(blank, NA, letters))  ,
       `any_gt("a", c(blank, NA, letters))`   = any_gt("a", c(blank, NA, letters))  ,
       `any_in(NULL, blank, combo)`           = any_in(NULL, blank, combo)          ,
       `any_le("a", c(blank, NA, letters))`   = any_le("a", c(blank, NA, letters))  ,
       `any_lg(c(NA, TRUE, FALSE))`           = any_lg(c(NA, TRUE, FALSE))          ,
       `any_lt("a", c(blank, NA, letters))`   = any_lt("a", c(blank, NA, letters))  ,
       `any_mf(NULL, blank, combo)`           = any_mf(NULL, blank, combo)          ,
       `any_nav(c(blank, NA, letters))`       = any_nav(c(blank, NA, letters))      ,
       `any_nav(chr.mat)`                     = any_nav(chr.mat)                    ,
       `any_okv(c(blank, NA, letters))`       = any_okv(c(blank, NA, letters))      ,
       `any_okv(chr.mat)`                     = any_okv(chr.mat)                    ,
       `any_t(c(list(blank), combo))`         = any_t(c(list(blank), combo))        ,
       `any_tf(c(list(blank), combo))`        = any_tf(c(list(blank), combo))       ,
       `failsafe(non.existent.variable)`      = failsafe(non.existent.variable)     ,
       `failsafe(pi)`                         = failsafe(pi)                        ,
       `FALSE \%.and.\% FALSE`                  = FALSE \%.and.\% FALSE                 ,
       `FALSE \%.nor.\% FALSE`                  = FALSE \%.nor.\% FALSE                 ,
       `FALSE \%.xor.\% FALSE`                  = FALSE \%.xor.\% FALSE                 ,
       `FALSE \%.or.\% FALSE`                   = FALSE \%.or.\% FALSE                  ,
       `has_all(blank, combo)`                = has_all(blank, combo)               ,
       `has_any(blank, combo)`                = has_any(blank, combo)               ,
       `has_many(blank, combo)`               = has_many(blank, combo)              ,
       `has_none(blank, combo)`               = has_none(blank, combo)              ,
       `has_one(blank, combo)`                = has_one(blank, combo)               ,
       `has_some(blank, combo)`               = has_some(blank, combo)              ,
       `has_two(blank, combo)`                = has_two(blank, combo)               ,
       `is_bl("")`                            = is_bl("")                           ,
       `is_bl("a")`                           = is_bl("a")                          ,
       `is_bl(c("", ""))`                     = is_bl(c("", ""))                    ,
       `is_bl(NA)`                            = is_bl(NA)                           ,
       `is_bl0("")`                           = is_bl0("")                          ,
       `is_bl0("a")`                          = is_bl0("a")                         ,
       `is_bl0(c("", ""))`                    = is_bl0(c("", ""))                   ,
       `is_bl0(NA)`                           = is_bl0(NA)                          ,
       `is_dif("", "")`                       = is_dif("", "")                      ,
       `is_dif("word", 7)`                    = is_dif("word", 7)                   ,
       `is_dif(chr.mat, chr.mat)`             = is_dif(chr.mat, chr.mat)            ,
       `is_dif(NA, NA)`                       = is_dif(NA, NA)                      ,
       `is_dif0("", "")`                      = is_dif0("", "")                     ,
       `is_dif0("word", 7)`                   = is_dif0("word", 7)                  ,
       `is_dif0(chr.mat, chr.mat)`            = is_dif0(chr.mat, chr.mat)           ,
       `is_dif0(NA, NA)`                      = is_dif0(NA, NA)                     ,
       `is_eq("", "")`                        = is_eq("", "")                       ,
       `is_eq("word", 7)`                     = is_eq("word", 7)                    ,
       `is_eq(chr.mat, chr.mat)`              = is_eq(chr.mat, chr.mat)             ,
       `is_eq(NA, NA)`                        = is_eq(NA, NA)                       ,
       `is_eq0("", "")`                       = is_eq0("", "")                      ,
       `is_eq0("word", 7)`                    = is_eq0("word", 7)                   ,
       `is_eq0(chr.mat, chr.mat)`             = is_eq0(chr.mat, chr.mat)            ,
       `is_eq0(NA, NA)`                       = is_eq0(NA, NA)                      ,
       `is_err(non.existent.variable)`        = is_err(non.existent.variable)       ,
       `is_err(pi)`                           = is_err(pi)                          ,
       `is_f(c(TRUE, FALSE))`                 = is_f(c(TRUE, FALSE))                ,
       `is_f(chr.mat)`                        = is_f(chr.mat)                       ,
       `is_f(NA)`                             = is_f(NA)                            ,
       `is_f(TRUE)`                           = is_f(TRUE)                          ,
       `is_f(TRUE)`                           = is_f(TRUE)                          ,
       `is_f0(c(TRUE, FALSE))`                = is_f0(c(TRUE, FALSE))               ,
       `is_f0(chr.mat)`                       = is_f0(chr.mat)                      ,
       `is_f0(FALSE)`                         = is_f0(FALSE)                        ,
       `is_f0(NA)`                            = is_f0(NA)                           ,
       `is_f0(TRUE)`                          = is_f0(TRUE)                         ,
       `is_ge("a", "b")`                      = is_ge("a", "b")                     ,
       `is_ge("b", "a")`                      = is_ge("b", "a")                     ,
       `is_ge(1, 1)`                          = is_ge(1, 1)                         ,
       `is_ge(chr.mat, chr.mat)`              = is_ge(chr.mat, chr.mat)             ,
       `is_ge0("a", "b")`                     = is_ge0("a", "b")                    ,
       `is_ge0("b", "a")`                     = is_ge0("b", "a")                    ,
       `is_ge0(1, 1)`                         = is_ge0(1, 1)                        ,
       `is_ge0(chr.mat, chr.mat)`             = is_ge0(chr.mat, chr.mat)            ,
       `is_gt("a", "b")`                      = is_gt("a", "b")                     ,
       `is_gt("b", "a")`                      = is_gt("b", "a")                     ,
       `is_gt(1, 1)`                          = is_gt(1, 1)                         ,
       `is_gt(chr.mat, chr.mat)`              = is_gt(chr.mat, chr.mat)             ,
       `is_gt0("a", "b")`                     = is_gt0("a", "b")                    ,
       `is_gt0("b", "a")`                     = is_gt0("b", "a")                    ,
       `is_gt0(1, 1)`                         = is_gt0(1, 1)                        ,
       `is_gt0(chr.mat, chr.mat)`             = is_gt0(chr.mat, chr.mat)            ,
       `is_in(1, "", "a", 1:2)`               = is_in(1, "", "a", 1:2)              ,
       `is_in(1, "a", letters)`               = is_in(1, "a", letters)              ,
       `is_in(NULL, blank, combo)`            = is_in(NULL, blank, combo)           ,
       `is_in0(1, "", "a", 1:2)`              = is_in0(1, "", "a", 1:2)             ,
       `is_in0(1, "a", letters)`              = is_in0(1, "a", letters)             ,
       `is_in0(NULL, blank, combo)`           = is_in0(NULL, blank, combo)          ,
       `is_bl0(chr.mat)`                      = is_bl0(chr.mat)                     ,
       `is_le("a", "b")`                      = is_le("a", "b")                     ,
       `is_le("b", "a")`                      = is_le("b", "a")                     ,
       `is_le(1, 1)`                          = is_le(1, 1)                         ,
       `is_le(chr.mat, chr.mat)`              = is_le(chr.mat, chr.mat)             ,
       `is_le0("a", "b")`                     = is_le0("a", "b")                    ,
       `is_le0("b", "a")`                     = is_le0("b", "a")                    ,
       `is_le0(1, 1)`                         = is_le0(1, 1)                        ,
       `is_le0(chr.mat, chr.mat)`             = is_le0(chr.mat, chr.mat)            ,
       `is_lg0(c(TRUE, FALSE))`               = is_lg0(c(TRUE, FALSE))              ,
       `is_lg0(chr.mat)`                      = is_lg0(chr.mat)                     ,
       `is_lg0(FALSE)`                        = is_lg0(FALSE)                       ,
       `is_lg0(NA)`                           = is_lg0(NA)                          ,
       `is_lg0(TRUE)`                         = is_lg0(TRUE)                        ,
       `is_lt("a", "b")`                      = is_lt("a", "b")                     ,
       `is_lt("b", "a")`                      = is_lt("b", "a")                     ,
       `is_lt(1, 1)`                          = is_lt(1, 1)                         ,
       `is_lt(chr.mat, chr.mat)`              = is_lt(chr.mat, chr.mat)             ,
       `is_lt0("a", "b")`                     = is_lt0("a", "b")                    ,
       `is_lt0("b", "a")`                     = is_lt0("b", "a")                    ,
       `is_lt0(1, 1)`                         = is_lt0(1, 1)                        ,
       `is_lt0(chr.mat, chr.mat)`             = is_lt0(chr.mat, chr.mat)            ,
       `is_mf(1, "", "a", 1:2)`               = is_mf(1, "", "a", 1:2)              ,
       `is_mf(1, "a", letters)`               = is_mf(1, "a", letters)              ,
       `is_mf(NULL, blank, combo)`            = is_mf(NULL, blank, combo)           ,
       `is_mf0(1, "", "a", 1:2)`              = is_mf0(1, "", "a", 1:2)             ,
       `is_mf0(1, "a", letters)`              = is_mf0(1, "a", letters)             ,
       `is_mf0(NULL, blank, combo)`           = is_mf0(NULL, blank, combo)          ,
       `is_nav(1)`                            = is_nav(1)                           ,
       `is_nav(c(NA, NA))`                    = is_nav(c(NA, NA))                   ,
       `is_nav(chr.mat)`                      = is_nav(chr.mat)                     ,
       `is_nav(NA)`                           = is_nav(NA)                          ,
       `is_na0(1)`                            = is_na0(1)                           ,
       `is_na0(c(NA, NA))`                    = is_na0(c(NA, NA))                   ,
       `is_na0(chr.mat)`                      = is_na0(chr.mat)                     ,
       `is_na0(NA)`                           = is_na0(NA)                          ,
       `is_okv(1)`                            = is_okv(1)                           ,
       `is_okv(c(NA, NA))`                    = is_okv(c(NA, NA))                   ,
       `is_okv(chr.mat)`                      = is_ok(chr.mat)                      ,
       `is_okv(NA)`                           = is_okv(NA)                          ,
       `is_ok0(1)`                            = is_ok0(1)                           ,
       `is_ok0(c(NA, NA))`                    = is_ok0(c(NA, NA))                   ,
       `is_ok0(chr.mat)`                      = is_ok0(chr.mat)                     ,
       `is_ok0(NA)`                           = is_ok0(NA)                          ,
       `is_seq(1, letters)`                   = is_seq(1, letters)                  ,
       `is_seq(1, letters)`                   = is_seq(1, letters)                  ,
       `is_seq(1:3, c(1, 2, 3, 2, 1))`        = is_seq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_seq(1:3, c(1, 2, 3, 2, 1))`        = is_seq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_seq(1:3, c(1, 2, 3))`              = is_seq(1:3, c(1, 2, 3))             ,
       `is_seq(1:3, c(1, 2, 3))`              = is_seq(1:3, c(1, 2, 3))             ,
       `is_t(c(TRUE, FALSE))`                 = is_t(c(TRUE, FALSE))                ,
       `is_t(chr.mat)`                        = is_t(chr.mat)                       ,
       `is_t(NA)`                             = is_t(NA)                            ,
       `is_t(TRUE)`                           = is_t(TRUE)                          ,
       `is_t(TRUE)`                           = is_t(TRUE)                          ,
       `is_t0(c(TRUE, FALSE))`                = is_t0(c(TRUE, FALSE))               ,
       `is_t0(chr.mat)`                       = is_t0(chr.mat)                      ,
       `is_t0(FALSE)`                         = is_t0(FALSE)                        ,
       `is_t0(NA)`                            = is_t0(NA)                           ,
       `is_t0(TRUE)`                          = is_t0(TRUE)                         ,
       `is_tf(c(TRUE, FALSE))`                = is_tf(c(TRUE, FALSE))               ,
       `is_tf(chr.mat)`                       = is_tf(chr.mat)                      ,
       `is_tf(chr.mat)`                       = is_tf(chr.mat)                      ,
       `is_tf(NA)`                            = is_tf(NA)                           ,
       `is_tf(TRUE)`                          = is_tf(TRUE)                         ,
       `is_tf(TRUE)`                          = is_tf(TRUE)                         ,
       `is_tf0(c(TRUE, FALSE))`               = is_tf0(c(TRUE, FALSE))              ,
       `is_tf0(chr.mat)`                      = is_tf0(chr.mat)                     ,
       `is_tf0(FALSE)`                        = is_tf0(FALSE)                       ,
       `is_tf0(NA)`                           = is_tf0(NA)                          ,
       `is_tf0(TRUE)`                         = is_tf0(TRUE)                        ,
       `is_veq(1, letters)`                   = is_veq(1, letters)                  ,
       `is_veq(1:3, c(1, 2, 3, 2, 1))`        = is_veq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_veq(1:3, c(1, 2, 3, 2, 1))`        = is_veq(1:3, c(1, 2, 3, 2, 1))       ,
       `is_veq(1:3, letters)`                 = is_veq(1:3, letters)                ,
       `is_veq(1:3, c(1, 2, 3))`              = is_veq(1:3, c(1, 2, 3))             ,
       `is_veq(1:3, c(1, 2, 3))`              = is_veq(1:3, c(1, 2, 3))             ,
       `lacks_all(blank, combo)`              = lacks_all(blank, combo)             ,
       `lacks_any(blank, combo)`              = lacks_any(blank, combo)             ,
       `lacks_many(blank, combo)`             = lacks_many(blank, combo)            ,
       `lacks_none(blank, combo)`             = lacks_none(blank, combo)            ,
       `lacks_one(blank, combo)`              = lacks_one(blank, combo)             ,
       `lacks_some(blank, combo)`             = lacks_some(blank, combo)            ,
       `lacks_two(blank, combo)`              = lacks_two(blank, combo)             ,
       `many_bl(c(blank, letters))`           = many_bl(c(blank, letters))          ,
       `many_dif("a", c(blank, NA, letters))` = many_dif("a", c(blank, NA, letters)),
       `many_eq(NA, c(blank, NA, letters))`   = many_eq(NA, c(blank, NA, letters))  ,
       `many_f(c(list(blank), combo))`        = many_f(c(list(blank), combo))       ,
       `many_ge("a", c(blank, NA, letters))`  = many_ge("a", c(blank, NA, letters)) ,
       `many_gt("a", c(blank, NA, letters))`  = many_gt("a", c(blank, NA, letters)) ,
       `many_in(NULL, blank, combo)`          = many_in(NULL, blank, combo)         ,
       `many_le("a", c(blank, NA, letters))`  = many_le("a", c(blank, NA, letters)) ,
       `many_lg(c(NA, TRUE, FALSE))`          = many_lg(c(NA, TRUE, FALSE))         ,
       `many_lt("a", c(blank, NA, letters))`  = many_lt("a", c(blank, NA, letters)) ,
       `many_mf(NULL, blank, combo)`          = many_mf(NULL, blank, combo)         ,
       `many_nav(c(blank, NA, letters))`      = many_nav(c(blank, NA, letters))     ,
       `many_nav(chr.mat)`                    = many_nav(chr.mat)                   ,
       `many_okv(c(blank, NA, letters))`      = many_okv(c(blank, NA, letters))     ,
       `many_okv(chr.mat)`                    = many_okv(chr.mat)                   ,
       `many_t(c(list(blank), combo))`        = many_t(c(list(blank), combo))       ,
       `many_tf(c(list(blank), combo))`       = many_tf(c(list(blank), combo))      ,
       `msg_err(non.existent.variable)`       = msg_err(non.existent.variable)      ,
       `msg_err(pi)`                          = msg_err(pi)                         ,
       `n_bl(c(list(blank), combo))`          = n_bl(c(list(blank), combo))         ,
       `n_f(c(list(blank), combo))`           = n_f(c(list(blank), combo))          ,
       `n_has(blank, combo)`                  = n_has(blank, combo)                 ,
       `n_in(NULL, blank, combo)`             = n_in(NULL, blank, combo)            ,
       `n_lacks(blank, combo)`                = n_lacks(blank, combo)               ,
       `n_mf(NULL, blank, combo)`             = n_mf(NULL, blank, combo)            ,
       `n_nav(chr.mat)`                       = n_nav(chr.mat)                      ,
       `n_okv(chr.mat)`                       = n_okv(chr.mat)                      ,
       `none_bl(c(blank, letters))`           = none_bl(c(blank, letters))          ,
       `none_dif("a", c(blank, NA, letters))` = none_dif("a", c(blank, NA, letters)),
       `none_eq(NA, c(blank, NA, letters))`   = none_eq(NA, c(blank, NA, letters))  ,
       `none_f(c(list(blank), combo))`        = none_f(c(list(blank), combo))       ,
       `none_ge("a", c(blank, NA, letters))`  = none_ge("a", c(blank, NA, letters)) ,
       `none_gt("a", c(blank, NA, letters))`  = none_gt("a", c(blank, NA, letters)) ,
       `none_in(NULL, blank, combo)`          = none_in(NULL, blank, combo)         ,
       `none_le("a", c(blank, NA, letters))`  = none_le("a", c(blank, NA, letters)) ,
       `none_lg(c(NA, TRUE, FALSE))`          = none_lg(c(NA, TRUE, FALSE))         ,
       `none_lt("a", c(blank, NA, letters))`  = none_lt("a", c(blank, NA, letters)) ,
       `none_mf(NULL, blank, combo)`          = none_mf(NULL, blank, combo)         ,
       `none_nav(c(blank, NA, letters))`      = none_nav(c(blank, NA, letters))     ,
       `none_nav(chr.mat)`                    = none_nav(chr.mat)                   ,
       `none_okv(c(blank, NA, letters))`      = none_okv(c(blank, NA, letters))     ,
       `none_okv(chr.mat)`                    = none_okv(chr.mat)                   ,
       `none_t(c(list(blank), combo))`        = none_t(c(list(blank), combo))       ,
       `none_tf(c(list(blank), combo))`       = none_tf(c(list(blank), combo))      ,
       `not_bl("")`                           = not_bl("")                          ,
       `not_bl("a")`                          = not_bl("a")                         ,
       `not_bl(c("", ""))`                    = not_bl(c("", ""))                   ,
       `not_bl(chr.mat)`                      = not_bl(chr.mat)                     ,
       `not_bl(NA)`                           = not_bl(NA)                          ,
       `not_bl0("")`                          = not_bl0("")                         ,
       `not_bl0("a")`                         = not_bl0("a")                        ,
       `not_bl0(c("", ""))`                   = not_bl0(c("", ""))                  ,
       `not_bl0(chr.mat)`                     = not_bl0(chr.mat)                    ,
       `not_bl0(NA)`                          = not_bl0(NA)                         ,
       `not_dif("", "")`                      = not_dif("", "")                     ,
       `not_dif("word", 7)`                   = not_dif("word", 7)                  ,
       `not_dif(chr.mat, chr.mat)`            = not_dif(chr.mat, chr.mat)           ,
       `not_dif(NA, NA)`                      = not_dif(NA, NA)                     ,
       `not_dif0("", "")`                     = not_dif0("", "")                    ,
       `not_dif0("word", 7)`                  = not_dif0("word", 7)                 ,
       `not_dif0(chr.mat, chr.mat)`           = not_dif0(chr.mat, chr.mat)          ,
       `not_dif0(NA, NA)`                     = not_dif0(NA, NA)                    ,
       `not_eq("", "")`                       = not_eq("", "")                      ,
       `not_eq("word", 7)`                    = not_eq("word", 7)                   ,
       `not_eq(chr.mat, chr.mat)`             = not_eq(chr.mat, chr.mat)            ,
       `not_eq(NA, NA)`                       = not_eq(NA, NA)                      ,
       `not_eq0("", "")`                      = not_eq0("", "")                     ,
       `not_eq0("word", 7)`                   = not_eq0("word", 7)                  ,
       `not_eq0(chr.mat, chr.mat)`            = not_eq0(chr.mat, chr.mat)           ,
       `not_eq0(NA, NA)`                      = not_eq0(NA, NA)                     ,
       `not_err(non.existent.variable)`       = not_err(non.existent.variable)      ,
       `not_err(pi)`                          = not_err(pi)                         ,
       `not_f(c(TRUE, FALSE))`                = not_f(c(TRUE, FALSE))               ,
       `not_f(chr.mat)`                       = not_f(chr.mat)                      ,
       `not_f(NA)`                            = not_f(NA)                           ,
       `not_f(TRUE)`                          = not_f(TRUE)                         ,
       `not_f(TRUE)`                          = not_f(TRUE)                         ,
       `not_f0(c(TRUE, FALSE))`               = not_f0(c(TRUE, FALSE))              ,
       `not_f0(chr.mat)`                      = not_f0(chr.mat)                     ,
       `not_f0(FALSE)`                        = not_f0(FALSE)                       ,
       `not_f0(NA)`                           = not_f0(NA)                          ,
       `not_f0(TRUE)`                         = not_f0(TRUE)                        ,
       `not_ge("a", "b")`                     = not_ge("a", "b")                    ,
       `not_ge("b", "a")`                     = not_ge("b", "a")                    ,
       `not_ge(1, 1)`                         = not_ge(1, 1)                        ,
       `not_ge(chr.mat, chr.mat)`             = not_ge(chr.mat, chr.mat)            ,
       `not_ge0("a", "b")`                    = not_ge0("a", "b")                   ,
       `not_ge0("b", "a")`                    = not_ge0("b", "a")                   ,
       `not_ge0(1, 1)`                        = not_ge0(1, 1)                       ,
       `not_ge0(chr.mat, chr.mat)`            = not_ge0(chr.mat, chr.mat)           ,
       `not_gt("a", "b")`                     = not_gt("a", "b")                    ,
       `not_gt("b", "a")`                     = not_gt("b", "a")                    ,
       `not_gt(1, 1)`                         = not_gt(1, 1)                        ,
       `not_gt(chr.mat, chr.mat)`             = not_gt(chr.mat, chr.mat)            ,
       `not_gt0("a", "b")`                    = not_gt0("a", "b")                   ,
       `not_gt0("b", "a")`                    = not_gt0("b", "a")                   ,
       `not_gt0(1, 1)`                        = not_gt0(1, 1)                       ,
       `not_gt0(chr.mat, chr.mat)`            = not_gt0(chr.mat, chr.mat)           ,
       `not_in(1, "", "a", 1:2)`              = not_in(1, "", "a", 1:2)             ,
       `not_in(1, "a", letters)`              = not_in(1, "a", letters)             ,
       `not_in(NULL, blank, combo)`           = not_in(NULL, blank, combo)          ,
       `not_in0(1, "", "a", 1:2)`             = not_in0(1, "", "a", 1:2)            ,
       `not_in0(1, "a", letters)`             = not_in0(1, "a", letters)            ,
       `not_in0(NULL, blank, combo)`          = not_in0(NULL, blank, combo)         ,
       `not_le("a", "b")`                     = not_le("a", "b")                    ,
       `not_le("b", "a")`                     = not_le("b", "a")                    ,
       `not_le(1, 1)`                         = not_le(1, 1)                        ,
       `not_le(chr.mat, chr.mat)`             = not_le(chr.mat, chr.mat)            ,
       `not_le0("a", "b")`                    = not_le0("a", "b")                   ,
       `not_le0("b", "a")`                    = not_le0("b", "a")                   ,
       `not_le0(1, 1)`                        = not_le0(1, 1)                       ,
       `not_le0(chr.mat, chr.mat)`            = not_le0(chr.mat, chr.mat)           ,
       `not_lg0(c(TRUE, FALSE))`              = not_lg0(c(TRUE, FALSE))             ,
       `not_lg0(chr.mat)`                     = not_lg0(chr.mat)                    ,
       `not_lg0(FALSE)`                       = not_lg0(FALSE)                      ,
       `not_lg0(NA)`                          = not_lg0(NA)                         ,
       `not_lg0(TRUE)`                        = not_lg0(TRUE)                       ,
       `not_lt("a", "b")`                     = not_lt("a", "b")                    ,
       `not_lt("b", "a")`                     = not_lt("b", "a")                    ,
       `not_lt(1, 1)`                         = not_lt(1, 1)                        ,
       `not_lt(chr.mat, chr.mat)`             = not_lt(chr.mat, chr.mat)            ,
       `not_lt0("a", "b")`                    = not_lt0("a", "b")                   ,
       `not_lt0("b", "a")`                    = not_lt0("b", "a")                   ,
       `not_lt0(1, 1)`                        = not_lt0(1, 1)                       ,
       `not_lt0(chr.mat, chr.mat)`            = not_lt0(chr.mat, chr.mat)           ,
       `not_mf(1, "", "a", 1:2)`              = not_mf(1, "", "a", 1:2)             ,
       `not_mf(1, "a", letters)`              = not_mf(1, "a", letters)             ,
       `not_mf(NULL, blank, combo)`           = not_mf(NULL, blank, combo)          ,
       `not_mf0(1, "", "a", 1:2)`             = not_mf0(1, "", "a", 1:2)            ,
       `not_mf0(1, "a", letters)`             = not_mf0(1, "a", letters)            ,
       `not_mf0(NULL, blank, combo)`          = not_mf0(NULL, blank, combo)         ,
       `not_na0(1)`                           = not_na0(1)                          ,
       `not_na0(c(NA, NA))`                   = not_na0(c(NA, NA))                  ,
       `not_na0(chr.mat)`                     = not_na0(chr.mat)                    ,
       `not_na0(NA)`                          = not_na0(NA)                         ,
       `not_nav(c(NA, NA)), not_nav(chr.mat)` = not_nav(c(NA, NA)), not_nav(chr.mat),
       `not_nav(NA), not_nav(1)`              = not_nav(NA), not_nav(1)             ,
       `not_ok0(1)`                           = not_ok0(1)                          ,
       `not_ok0(c(NA, NA))`                   = not_ok0(c(NA, NA))                  ,
       `not_ok0(chr.mat)`                     = not_ok0(chr.mat)                    ,
       `not_ok0(NA)`                          = not_ok0(NA)                         ,
       `not_okv(c(NA, NA)), not_okv(chr.mat)` = not_okv(c(NA, NA)), not_okv(chr.mat),
       `not_okv(NA), not_okv(1)`              = not_okv(NA), not_okv(1)             ,
       `not_seq(1, letters)`                  = not_seq(1, letters)                 ,
       `not_seq(1, letters)`                  = not_seq(1, letters)                 ,
       `not_seq(1:3, c(1, 2, 3, 2, 1))`       = not_seq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_seq(1:3, c(1, 2, 3, 2, 1))`       = not_seq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_seq(1:3, c(1, 2, 3))`             = not_seq(1:3, c(1, 2, 3))            ,
       `not_seq(1:3, c(1, 2, 3))`             = not_seq(1:3, c(1, 2, 3))            ,
       `not_t(c(TRUE, FALSE))`                = not_t(c(TRUE, FALSE))               ,
       `not_t(chr.mat)`                       = not_t(chr.mat)                      ,
       `not_t(NA)`                            = not_t(NA)                           ,
       `not_t(TRUE)`                          = not_t(TRUE)                         ,
       `not_t(TRUE)`                          = not_t(TRUE)                         ,
       `not_t0(c(TRUE, FALSE))`               = not_t0(c(TRUE, FALSE))              ,
       `not_t0(chr.mat)`                      = not_t0(chr.mat)                     ,
       `not_t0(FALSE)`                        = not_t0(FALSE)                       ,
       `not_t0(NA)`                           = not_t0(NA)                          ,
       `not_t0(TRUE)`                         = not_t0(TRUE)                        ,
       `not_tf(c(TRUE, FALSE))`               = not_tf(c(TRUE, FALSE))              ,
       `not_tf(chr.mat)`                      = not_tf(chr.mat)                     ,
       `not_tf(NA)`                           = not_tf(NA)                          ,
       `not_tf(TRUE)`                         = not_tf(TRUE)                        ,
       `not_tf(TRUE)`                         = not_tf(TRUE)                        ,
       `not_tf0(c(TRUE, FALSE))`              = not_tf0(c(TRUE, FALSE))             ,
       `not_tf0(chr.mat)`                     = not_tf0(chr.mat)                    ,
       `not_tf0(FALSE)`                       = not_tf0(FALSE)                      ,
       `not_tf0(NA)`                          = not_tf0(NA)                         ,
       `not_tf0(TRUE)`                        = not_tf0(TRUE)                       ,
       `not_veq(1, letters)`                  = not_veq(1, letters)                 ,
       `not_veq(1, letters)`                  = not_veq(1, letters)                 ,
       `not_veq(1:3, c(1, 2, 3, 2, 1))`       = not_veq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_veq(1:3, c(1, 2, 3, 2, 1))`       = not_veq(1:3, c(1, 2, 3, 2, 1))      ,
       `not_veq(1:3, c(1, 2, 3))`             = not_veq(1:3, c(1, 2, 3))            ,
       `not_veq(1:3, c(1, 2, 3))`             = not_veq(1:3, c(1, 2, 3))            ,
       `n_t(c(list(blank), combo))`           = n_t(c(list(blank), combo))          ,
       `n_tf(c(list(blank), combo))`          = n_tf(c(list(blank), combo))         ,
       `NULL \%.in.\% abc`                      = NULL \%.in\% abc                      ,
       `NULL \%.mf.\% abc`                      = NULL \%.mf.\% abc                     ,
       `one_bl(c(blank, letters))`            = one_bl(c(blank, letters))           ,
       `one_dif("a", c(blank, NA, letters))`  = one_dif("a", c(blank, NA, letters)) ,
       `one_eq(NA, c(blank, NA, letters))`    = one_eq(NA, c(blank, NA, letters))   ,
       `one_f(c(list(blank), combo))`         = one_f(c(list(blank), combo))        ,
       `one_ge("a", c(blank, NA, letters))`   = one_ge("a", c(blank, NA, letters))  ,
       `one_gt("a", c(blank, NA, letters))`   = one_gt("a", c(blank, NA, letters))  ,
       `one_in(NULL, blank, combo)`           = one_in(NULL, blank, combo)          ,
       `one_le("a", c(blank, NA, letters))`   = one_le("a", c(blank, NA, letters))  ,
       `one_lg(c(NA, TRUE, FALSE))`           = one_lg(c(NA, TRUE, FALSE))          ,
       `one_lt("a", c(blank, NA, letters))`   = one_lt("a", c(blank, NA, letters))  ,
       `one_mf(NULL, blank, combo)`           = one_mf(NULL, blank, combo)          ,
       `one_nav(c(blank, NA, letters))`       = one_nav(c(blank, NA, letters))      ,
       `one_nav(chr.mat)`                     = one_nav(chr.mat)                    ,
       `one_okv(c(blank, NA, letters))`       = one_okv(c(blank, NA, letters))      ,
       `one_okv(chr.mat)`                     = one_okv(chr.mat)                    ,
       `one_t(c(list(blank), combo))`         = one_t(c(list(blank), combo))        ,
       `one_tf(c(list(blank), combo))`        = one_tf(c(list(blank), combo))       ,
       `some_bl(c(blank, letters))`           = some_bl(c(blank, letters))          ,
       `some_dif("a", c(blank, NA, letters))` = some_dif("a", c(blank, NA, letters)),
       `some_eq(NA, c(blank, NA, letters))`   = some_eq(NA, c(blank, NA, letters))  ,
       `some_f(c(list(blank), combo))`        = some_f(c(list(blank), combo))       ,
       `some_ge("a", c(blank, NA, letters))`  = some_ge("a", c(blank, NA, letters)) ,
       `some_gt("a", c(blank, NA, letters))`  = some_gt("a", c(blank, NA, letters)) ,
       `some_in(NULL, blank, combo)`          = some_in(NULL, blank, combo)         ,
       `some_le("a", c(blank, NA, letters))`  = some_le("a", c(blank, NA, letters)) ,
       `some_lg(c(NA, TRUE, FALSE))`          = some_lg(c(NA, TRUE, FALSE))         ,
       `some_lt("a", c(blank, NA, letters))`  = some_lt("a", c(blank, NA, letters)) ,
       `some_mf(NULL, blank, combo)`          = some_mf(NULL, blank, combo)         ,
       `some_nav(c(blank, NA, letters))`      = some_nav(c(blank, NA, letters))     ,
       `some_nav(chr.mat)`                    = some_nav(chr.mat)                   ,
       `some_okv(c(blank, NA, letters))`      = some_okv(c(blank, NA, letters))     ,
       `some_okv(chr.mat)`                    = some_okv(chr.mat)                   ,
       `some_t(c(list(blank), combo))`        = some_t(c(list(blank), combo))       ,
       `some_tf(c(list(blank), combo))`       = some_tf(c(list(blank), combo))      ,
       `TRUE \%.and.\% 42`                      = TRUE \%.and.\% 42                     ,
       `TRUE \%.and.\% TRUE`                    = TRUE \%.and.\% TRUE                   ,
       `TRUE \%.nor.\% 42`                      = TRUE \%.nor.\% 42                     ,
       `TRUE \%.nor.\% TRUE`                    = TRUE \%.nor.\% TRUE                   ,
       `TRUE \%.xor.\% 42`                      = TRUE \%.xor.\% 42                     ,
       `TRUE \%.xor.\% TRUE`                    = TRUE \%.xor.\% TRUE                   ,
       `TRUE \%.or.\% 42`                       = TRUE \%.or.\% 42                      ,
       `TRUE \%.or.\% TRUE`                     = TRUE \%.or.\% TRUE                    ,
       `two_bl(c(blank, letters))`            = two_bl(c(blank, letters))           ,
       `two_dif("a", c(blank, NA, letters))`  = two_dif("a", c(blank, NA, letters)) ,
       `two_eq(NA, c(blank, NA, letters))`    = two_eq(NA, c(blank, NA, letters))   ,
       `two_f(c(list(blank), combo))`         = two_f(c(list(blank), combo))        ,
       `two_ge("a", c(blank, NA, letters))`   = two_ge("a", c(blank, NA, letters))  ,
       `two_gt("a", c(blank, NA, letters))`   = two_gt("a", c(blank, NA, letters))  ,
       `two_in(NULL, blank, combo)`           = two_in(NULL, blank, combo)          ,
       `two_le("a", c(blank, NA, letters))`   = two_le("a", c(blank, NA, letters))  ,
       `two_lg(c(NA, TRUE, FALSE))`           = two_lg(c(NA, TRUE, FALSE))          ,
       `two_lt("a", c(blank, NA, letters))`   = two_lt("a", c(blank, NA, letters))  ,
       `two_mf(NULL, blank, combo)`           = two_mf(NULL, blank, combo)          ,
       `two_nav(c(blank, NA, letters))`       = two_nav(c(blank, NA, letters))      ,
       `two_nav(chr.mat)`                     = two_nav(chr.mat)                    ,
       `two_okv(c(blank, NA, letters))`       = two_okv(c(blank, NA, letters))      ,
       `two_okv(chr.mat)`                     = two_okv(chr.mat)                    ,
       `two_t(c(list(blank), combo))`         = two_t(c(list(blank), combo))        ,
       `two_tf(c(list(blank), combo))`        = two_tf(c(list(blank), combo))       )
}
egfailsafe()
}
\seealso{
Other extensions: 
\code{\link{N}()},
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}()},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}

Other logicals: 
\code{\link{meets}()}

Other errs: 
\code{\link{checker}}
}
\concept{errs}
\concept{extensions}
\concept{logicals}
