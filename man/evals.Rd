% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evals.R
\name{evals}
\alias{evals}
\alias{not}
\alias{and}
\alias{or}
\alias{nor}
\alias{one}
\alias{TEST}
\alias{ANY}
\alias{ALL}
\alias{NOR}
\alias{ONE}
\alias{TWO}
\alias{tests}
\alias{w}
\alias{nors}
\alias{anys}
\alias{alls}
\alias{ones}
\alias{twos}
\alias{is_in}
\alias{not_in}
\alias{has}
\alias{lacks}
\title{Enhancements of \code{base} logical functions}
\usage{
not(x, na = "err")

and(x, y, na = "err")

or(x, y, na = "err")

nor(x, y, na = "err")

one(x, y, na = "err")

TEST(x, na = FALSE, err = NA)

ANY(..., err = NA)

ALL(..., err = NA)

NOR(..., err = NA)

ONE(..., err = NA)

TWO(..., err = NA)

tests(..., na = F, a = F, not = F, across = NA, within = NA)

w(..., not = F, na = F, a = F)

nors(..., na = F, a = F, across = T, within = F)

anys(..., na = F, a = F, across = T, within = F)

alls(..., na = F, a = F, across = T, within = F)

ones(..., na = F, a = F, across = T, within = F)

twos(..., na = F, a = F, across = T, within = F)

is_in(x, y, not = F, na = F, agg = NA)

not_in(x, y, na = F, agg = NA)

has(x, y, na = T, agg = NA)

lacks(x, y, na = T, agg = NA)
}
\arguments{
\item{x}{An \link[=atm_lgl]{atomic logical object} for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object.}

\item{na}{A non-\code{NA} logical scalar indicating what value should replace \code{NA} values.}

\item{y}{An atomic logical object. for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object \link[=compatible]{compatible} with \code{x}.}

\item{err}{A non-\code{NA} logical scalar. \code{err = TRUE} indicates \code{TRUE} should be substituted for non-logical values, \code{err = FALSE} indicates \code{FALSE} should be substituted for non-logical values, \code{err = NA} indicates an error should be thrown if a non-logical value is encountered.}

\item{...}{An arbitrary number of \link[=lgl_vec]{logical vecs} to be processed.}

\item{a}{A non-\code{NA} logical scalar indicating whether to atomize \code{...} before processing. This creates a single atomic vector of all atomic elements contained in all \code{...} arguments and effectively changes the behavior of \code{or} to \code{any}, \code{and} to \code{all}, and \code{not} to \code{!any}.}

\item{not}{A non-\code{NA} logical scalar indicating whether to negate values in arguments supplied in \code{...} before processing.}

\item{across, within}{\link[=cmp_chr_scl]{Character scalars}. \code{NA} indicates not summarizing across or within \code{...} arguments. Values in \code{c('nor', 'one', 'any', 'two', 'all')} indicate zero, exactly one, any, two or more, or all values are \code{TRUE} when looking across corresponding elements of \code{...} arguments vs. within each \code{...} argument.}

\item{agg}{A \link[=cmp_chr_scl]{complete character scalar} in \code{c('nor', 'one', 'any', 'two', 'all')}**: used to specify, respectively, that 0, 1, any, 2 or more, and all arguments must be \code{TRUE}.}
}
\description{
The following are extensions of base logical functions:
\itemize{
\item \strong{\code{TEST(x, ...)}}: an extended analog of \code{isTRUE(x)}.
\item \strong{\code{not(x, ...)}}: is an extended analog of \code{!x}.
\item \strong{\code{or(x, y, ...)}}: is an extended analog of \code{x | y}.
\item \strong{\code{and(x, y, ...)}}: is an extended analog of \code{x & y}.
\item \strong{\code{nor(x, y, ...)}}: is an extended analog of \code{!(x | y)}.
\item \strong{\code{one(x, y, ...)}}: is an extended analog of \code{xor(x, y)}.
\item \strong{\code{has(x, y, ...)}}: is an extended analog of \code{y \%in\% x}.
\item \strong{\code{lacks(x, y, ...)}}: is an extended analog of \code{!(y \%in\% x)}.
\item \strong{\code{is_in(x, y, ...)}}: is an extended analog of \code{x \%in\% y}.
\item \strong{\code{not_in(x, y, ...)}}: is an extended analog of \code{!(x \%in\% y)}.
}
This next set of functions evaluate an arbitrary number of \code{...} arguments expected to be logical scalars:\itemize{
\item \strong{\code{ANY(.)}}: evaluates whether any \code{...} argument is \code{TRUE}.
\item \strong{\code{ALL(.)}}: evaluates whether all \code{...} arguments are \code{TRUE}.
\item \strong{\code{NOR(.)}}: evaluates whether \code{0} \code{...} arguments are \code{TRUE}.
\item \strong{\code{ONE(.)}}: evaluates whether exactly \code{1} \code{...} argument is \code{TRUE}.
\item \strong{\code{TWO(.)}}: evaluates whether \verb{2+} \code{...} arguments are \code{TRUE}.
}
The remainder of functions in this family sweep across or within \code{...} arguments, as specified by the arguments \code{across} and \code{within}:
\itemize{
\item \strong{\code{w(.)}}: numerically indexes \code{TRUE} values in each sweep (a sweeping version of \code{base::which}).
\item \strong{\code{nors(.)}}: evaluates each sweep for 0 \code{TRUE} values.
\item \strong{\code{anys(.)}}: evaluates each sweep for any \code{TRUE} values.
\item \strong{\code{alls(.)}}: evaluates each sweep for only \code{TRUE} values.
\item \strong{\code{ones(.)}}: evaluates each sweep for exactly \code{1} \code{TRUE} value.
\item \strong{\code{twos(.)}}: evaluates each sweep for \verb{2+} \code{TRUE} values.
\item \strong{\code{tests(.)}}: logically indexes \code{TRUE} values in each sweep.
}
}
\seealso{
Other logicals: 
\code{\link{binary_failsafe}},
\code{\link{is_failsafe}},
\code{\link{meets}()}
}
\concept{logicals}
