% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evals.R
\encoding{UTF-8}
\name{evals}
\alias{evals}
\alias{not}
\alias{and}
\alias{or}
\alias{nor}
\alias{one}
\alias{TEST}
\alias{ANY}
\alias{ALL}
\alias{NOR}
\alias{ONE}
\alias{TWO}
\alias{tests}
\alias{nors}
\alias{anys}
\alias{alls}
\alias{ones}
\alias{twos}
\alias{isin}
\alias{is_in}
\alias{isout}
\alias{is_out}
\alias{not_in}
\alias{notin}
\alias{has}
\alias{lacks}
\title{Enhancements of \code{base} logical functions}
\usage{
not(x, na = "err")

and(x, y, na = "err")

or(x, y, na = "err")

nor(x, y, na = "err")

one(x, y, na = "err")

TEST(x, na = FALSE, err = NA)

ANY(..., err = NA)

ALL(..., err = NA)

NOR(..., err = NA)

ONE(..., err = NA)

TWO(..., err = NA)

tests(..., a = FALSE, na = FALSE, not = FALSE, agg = NA, sweep = NA)

nors(..., a = FALSE, na = FALSE, sweep = "across")

anys(..., a = FALSE, na = FALSE, sweep = "across")

alls(..., a = FALSE, na = FALSE, sweep = "across")

ones(..., a = FALSE, na = FALSE, sweep = "across")

twos(..., a = FALSE, na = FALSE, sweep = "across")

isin(x, y, na = FALSE, agg = NA, not = FALSE)

is_in(x, y, na = FALSE, agg = NA, not = FALSE)

isout(x, y, na = FALSE, agg = NA)

is_out(x, y, na = FALSE, agg = NA)

not_in(x, y, na = FALSE, agg = NA)

notin(x, y, na = FALSE, agg = NA)

has(x, y, na = TRUE, agg = NA)

lacks(x, y, na = TRUE, agg = NA)
}
\arguments{
\item{x}{An \link[=atm_lgl]{atomic logical object} for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object.}

\item{na}{A non-\code{NA} logical scalar indicating what value should replace \code{NA} values.}

\item{y}{An atomic logical object. for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object \link[=compatible]{compatible} with \code{x}.}

\item{err}{A non-\code{NA} logical scalar. \code{err = TRUE} indicates \code{TRUE} should be substituted for non-logical values, \code{err = FALSE} indicates \code{FALSE} should be substituted for non-logical values, \code{err = NA} indicates an error should be thrown if a non-logical value is encountered.}

\item{...}{An arbitrary number of \link[=lgl_vec]{logical vecs} to be processed.}

\item{a}{A non-\code{NA} logical scalar indicating whether to atomize \code{...} before processing. This creates a single atomic vector of all atomic elements contained in all \code{...} arguments and effectively changes the behavior of \code{or} to \code{any}, \code{and} to \code{all}, and \code{not} to \code{!any}.}

\item{not}{A non-\code{NA} logical scalar indicating whether to negate values in arguments supplied in \code{...} before processing.}

\item{agg}{A \link[=cmp_chr_scl]{complete character scalar} in \code{c('nor', 'one', 'any', 'two', 'all')} used to specify, respectively, that 0, 1, any, 2 or more, and all values must be \code{TRUE}.}

\item{sweep}{\link[=cmp_chr_scl]{Character scalar}. \code{NA}, \code{across}, \code{within}, and \code{both} indicate no sweeping, sweeping corresponding elements across arguments, sweeping within argument, and sweeping across and within all arguments, respectively.}
}
\description{
The following are extensions of base logical functions:
\tabular{rl}{
  \strong{Function usage} \tab   \strong{Extends}
\cr \code{not_in(x, y, ...)} \tab   \code{!(x \%in\% y)}
\cr \code{is_out(x, y, ...)} \tab   \code{!(x \%in\% y)}
\cr  \code{isout(x, y, ...)} \tab   \code{!(x \%in\% y)}
\cr  \code{notin(x, y, ...)} \tab   \code{!(x \%in\% y)}
\cr  \code{lacks(x, y, ...)} \tab   \code{!(y \%in\% x)}
\cr  \code{is_in(x, y, ...)} \tab   \code{x \%in\% y}
\cr   \code{isin(x, y, ...)} \tab   \code{x \%in\% y}
\cr    \code{has(x, y, ...)} \tab   \code{y \%in\% x}
\cr    \code{nor(x, y, ...)} \tab   \code{!(x | y)}
\cr    \code{one(x, y, ...)} \tab   \code{xor(x, y)}
\cr    \code{and(x, y, ...)} \tab   \code{x & y}
\cr     \code{or(x, y, ...)} \tab   \code{x | y}
\cr      \code{TEST(x, ...)} \tab   \code{isTRUE(x)}
\cr       \code{not(x, ...)} \tab   \code{!x}
}
The next set of functions evaluate an arbitrary number of \code{...} arguments expected to be logical scalars for whether:
\tabular{rl}{
  \code{ANY} \tab   Any \code{...} argument is scalar \code{TRUE}.
\cr \code{ALL} \tab   All \code{...} argument are scalar \code{TRUE}.
\cr \code{NOR} \tab   \verb{0 ...} arguments are scalar \code{TRUE}.
\cr \code{ONE} \tab   \verb{1 ...} argument is scalar \code{TRUE}.
\cr \code{TWO} \tab   \verb{2+ ...} arguments are scalar \code{TRUE}.
}
The remainder of functions in this family sweep across or within \code{...} arguments, as specified by the arguments \code{across} and \code{within}:
\tabular{rl}{
  \code{tests} \tab   Logically indexes \code{TRUE} values.
\cr    \code{w} \tab   Numerically indexes \code{TRUE} values.
\cr \code{anys} \tab   Checks for any \code{TRUE} values.
\cr \code{alls} \tab   Checks for only \code{TRUE} values.
\cr \code{nors} \tab   Checks for \verb{0 TRUE} values.
\cr \code{ones} \tab   Checks for exactly \verb{1 TRUE} value.
\cr \code{twos} \tab   Checks for \code{2+ TRUE} values.
}
}
\examples{
s1. <- TRUE
s2. <- TRUE
s3. <- FALSE
v1. <- sample(c(TRUE, FALSE), 5, replace = TRUE)
v2. <- sample(c(TRUE, FALSE), 5, replace = TRUE)
v3. <- sample(c(TRUE, FALSE), 5, replace = TRUE)

v1.
v2.
v3.

not(v3.)
or(v2., v3.)
and(v2., v3.)
nor(v2., v3.)
one(v2., v3.)

TEST(s1.)
TEST(NA, na = FALSE)
TEST("seven", err = FALSE)

ANY(s1., s2., s3.)
ALL(s1., s2., s3.)
NOR(s1., s2., s3.)
ONE(s1., s2., s3.)
TWO(s1., s2., s3.)

tests(v1.)
tests(v1., v2., v3., sweep = "across", agg = "any")
tests(v1., v2., v3., sweep = "within", agg = "nor")
tests(v1., v2., v3., sweep = "both", agg = "two")

ones(v1., v2., v3., sweep = "across")
twos(v1., v2., v3., sweep = "within")
nors(v1., v2., v3., sweep = "both")
anys(v1., v2., v3., sweep = "within")
alls(v1., v2., v3., sweep = "across")

is_in("a", letters)
is_in(c("a", "b", "c"), letters, agg = "all")

not_in(c("a", "b", "1"), letters, agg = "two")

has(letters, "1")
has(letters, "a")

lacks(letters, "1")
lacks(letters, "a")
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{envir_vals}},
\code{\link{failsafe_binaries}},
\code{\link{failsafe_is}},
\code{\link{failsafe}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{n_is}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{stats0}},
\code{\link{swap}()}

Other logicals: 
\code{\link{failsafe_binaries}},
\code{\link{failsafe_is}},
\code{\link{meets}()}
}
\concept{extensions}
\concept{logicals}
