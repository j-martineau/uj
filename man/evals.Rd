% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evals.R
\encoding{UTF-8}
\name{evals}
\alias{evals}
\alias{not}
\alias{and}
\alias{or}
\alias{nor}
\alias{one}
\alias{TEST}
\alias{ANY}
\alias{ALL}
\alias{NOR}
\alias{ONE}
\alias{TWO}
\alias{tests}
\alias{nors}
\alias{anys}
\alias{alls}
\alias{ones}
\alias{twos}
\alias{isin}
\alias{ismf}
\alias{has}
\alias{lacks}
\title{Enhancements of \code{base} logical functions}
\usage{
not(x, na = "err")

and(x, y, na = "err")

or(x, y, na = "err")

nor(x, y, na = "err")

one(x, y, na = "err")

TEST(x, na = FALSE, err = NA)

ANY(..., err = NA)

ALL(..., err = NA)

NOR(x, y)

ONE(..., err = NA)

TWO(..., err = NA)

tests(..., a = FALSE, nas = FALSE, not = FALSE, agg = NA, sweep = NA)

nors(..., a = FALSE, na = FALSE, sweep = "across")

anys(..., a = FALSE, na = FALSE, sweep = "across")

alls(..., a = FALSE, na = FALSE, sweep = "across")

ones(..., a = FALSE, na = FALSE, sweep = "across")

twos(..., a = FALSE, na = FALSE, sweep = "across")

isin(x, y, na = FALSE, agg = NA, not = FALSE)

ismf(x, y, na = FALSE, agg = NA)

has(x, y, na = TRUE, agg = NA)

lacks(x, y, na = TRUE, agg = NA)
}
\arguments{
\item{x}{An \link[=atm_lgl]{atomic logical object} for all functions other than \code{isin}, \code{ismf}, \code{has}, and \code{lacks}. Otherwise, an atomic object.}

\item{na}{\code{TRUE} or \code{FALSE} indicating what value should replace \code{NA} values.}

\item{y}{An atomic logical object. for all functions other than \code{isin}, \code{ismf}, \code{has}, and \code{lacks}. Otherwise, an atomic object \link[=compatible]{compatible} with \code{x}.}

\item{err}{\code{TRUE} or \code{FALSE}. \code{err = TRUE} indicates \code{TRUE} should be substituted for non-logical values, \code{err = FALSE} indicates \code{FALSE} should be substituted for non-logical values, \code{err = NA} indicates an error should be thrown if a non-logical value is encountered.}

\item{...}{An arbitrary number of \link[=lgl_vec]{logical vecs} to be processed.}

\item{a}{\code{TRUE} or \code{FALSE} indicating whether to atomize \code{...} before processing. This creates a single atomic vector of all atomic elements contained in all \code{...} arguments and effectively changes the behavior of \code{or} to \code{any}, \code{and} to \code{all}, and \code{not} to \code{!any}.}

\item{not}{\code{TRUE} or \code{FALSE} indicating whether to negate values in arguments supplied in \code{...} before processing.}

\item{agg}{A \link[=cmp_chr_scl]{complete character scalar} in \code{c('nor', 'one', 'any', 'two', 'all')} used to specify, respectively, that 0, 1, any, 2 or more, and all values must be \code{TRUE}.}

\item{sweep}{\link[=cmp_chr_scl]{Character scalar}. \code{NA}, \code{across}, \code{within}, and \code{both} indicate no sweeping, sweeping corresponding elements across arguments, sweeping within argument, and sweeping across and within all arguments, respectively.}
}
\description{
Enhancements of \code{base} logical functions
}
\details{
The left-hand column of the following table gives a function call from this family and the right column shows how they extend of base logical functions:
\tabular{ll}{  \code{lacks(x, y, ...)}    \tab \code{!(y \%in\% x)} \cr
  \code{ismf(x, y, ...)}     \tab \code{!(x \%in\% y)} \cr
  \code{isin(x, y, ...)}     \tab \code{x \%in\% y}    \cr
  \code{has(x, y, ...)}      \tab \code{y \%in\% x}    \cr   \tab   \cr
  \code{one(x, y, ...)}      \tab \code{xor(x, y)}   \cr
  \code{nor(x, y, ...)}      \tab \code{!(x | y)}    \cr
  \code{and(x, y, ...)}      \tab \code{x & y}       \cr
  \code{or(x, y, ...)}       \tab \code{x | y}       \cr   \tab   \cr
  \code{TEST(x, ...)}        \tab \code{isTRUE(x)}   \cr   \tab   \cr
  \code{not(x, ...)}         \tab \code{!x}                         }
\cr\cr The next set of functions evaluate an arbitrary number of \code{...} arguments expected to be logical scalars for whether:
\tabular{ll}{  \code{ANY}   \tab Any \code{...} arg is scalar \code{TRUE}.   \cr
  \code{ALL}   \tab All \code{...} args are scalar \code{TRUE}. \cr
  \code{NOR}   \tab \verb{0 ...} args are scalar \code{TRUE}.   \cr
  \code{ONE}   \tab \verb{1 ...} arg is scalar \code{TRUE}.     \cr
  \code{TWO}   \tab \code{2+ ...} args are scalar \code{TRUE}.    }
\cr\cr The remainder of functions in this family sweep across or within \code{...} arguments, as specified by the arguments \code{across} and \code{within}:
\tabular{ll}{  \code{tests}   \tab Logically indexes \code{TRUE} values.   \cr   \tab   \cr
  \code{ones}    \tab Checks for exactly \verb{1 TRUE} value. \cr
  \code{alls}    \tab Checks for only \code{TRUE} values.     \cr
  \code{anys}    \tab Checks for any \code{TRUE} values.      \cr
  \code{twos}    \tab Checks for \code{2+ TRUE} values.       \cr
  \code{nors}    \tab Checks for \verb{0 TRUE} values.        \cr   \tab   \cr
  \code{w}       \tab Numerically indexes \code{TRUE} values.   }
}
\examples{
egS1 <- TRUE
egS2 <- TRUE
egS3 <- FALSE
egV1 <- sample(c(TRUE, FALSE), 5, replace = TRUE)
egV2 <- sample(c(TRUE, FALSE), 5, replace = TRUE)
egV3 <- sample(c(TRUE, FALSE), 5, replace = TRUE)

egV1
egV2
egV3

not(egV3)
or(egV2, egV3)
and(egV2, egV3)
nor(egV2, egV3)
one(egV2, egV3)

TEST(egS1)
TEST(NA, na = FALSE)
TEST("seven", err = FALSE)

ANY(egS1, egS2, egS3)
ALL(egS1, egS2, egS3)
NOR(egS1, egS2, egS3)
ONE(egS1, egS2, egS3)
TWO(egS1, egS2, egS3)

tests(egV1)
tests(egV1, egV2, egV3, sweep = "across", agg = "any")
tests(egV1, egV2, egV3, sweep = "within", agg = "nor")
tests(egV1, egV2, egV3, sweep = "both", agg = "two")

ones(egV1, egV2, egV3, sweep = "across")
twos(egV1, egV2, egV3, sweep = "within")
nors(egV1, egV2, egV3, sweep = "both")
anys(egV1, egV2, egV3, sweep = "within")
alls(egV1, egV2, egV3, sweep = "across")

isIN("a", letters)
isIN(c("a", "b", "c"), letters, agg = "all")

isMF(c("a", "b", "1"), letters, agg = "two")

has(letters, "1")
has(letters, "a")

lacks(letters, "1")
lacks(letters, "a")
}
\seealso{
Other extensions: 
\code{\link{atomize}()},
\code{\link{case}()},
\code{\link{cb}()},
\code{\link{comparable}()},
\code{\link{compatible}()},
\code{\link{declare}},
\code{\link{dups}()},
\code{\link{failsafe}()},
\code{\link{fork}()},
\code{\link{is_unique}()},
\code{\link{naming}},
\code{\link{na}()},
\code{\link{nis}()},
\code{\link{paths}},
\code{\link{purge}()},
\code{\link{rd}},
\code{\link{r}()},
\code{\link{sets}()},
\code{\link{sum0}()},
\code{\link{swap}()},
\code{\link{value_exists}()}

Other logicals: 
\code{\link{failsafe}()},
\code{\link{meets}()}
}
\concept{extensions}
\concept{logicals}
