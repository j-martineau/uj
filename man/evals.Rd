% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evals..R
\name{evals}
\alias{evals}
\alias{not}
\alias{and}
\alias{or}
\alias{nor}
\alias{one}
\alias{TEST}
\alias{ANY}
\alias{ALL}
\alias{NOR}
\alias{ONE}
\alias{TWO}
\alias{tests}
\alias{nors}
\alias{anys}
\alias{alls}
\alias{ones}
\alias{twos}
\alias{isin}
\alias{is_in}
\alias{isout}
\alias{is_out}
\alias{not_in}
\alias{notin}
\alias{has}
\alias{lacks}
\title{Enhancements of \code{base} logical functions}
\usage{
not(x, na = "err")

and(x, y, na = "err")

or(x, y, na = "err")

nor(x, y, na = "err")

one(x, y, na = "err")

TEST(x, na = FALSE, err = NA)

ANY(..., err = NA)

ALL(..., err = NA)

NOR(..., err = NA)

ONE(..., err = NA)

TWO(..., err = NA)

tests(..., a = FALSE, na = FALSE, not = FALSE, agg = NA, sweep = NA)

nors(..., a = FALSE, na = FALSE, sweep = "across")

anys(..., a = FALSE, na = FALSE, sweep = "across")

alls(..., a = FALSE, na = FALSE, sweep = "across")

ones(..., a = FALSE, na = FALSE, sweep = "across")

twos(..., a = FALSE, na = FALSE, sweep = "across")

isin(x, y, na = FALSE, agg = NA, not = FALSE)

is_in(x, y, na = FALSE, agg = NA, not = FALSE)

isout(x, y, na = FALSE, agg = NA)

is_out(x, y, na = FALSE, agg = NA)

not_in(x, y, na = FALSE, agg = NA)

notin(x, y, na = FALSE, agg = NA)

has(x, y, na = TRUE, agg = NA)

lacks(x, y, na = TRUE, agg = NA)
}
\arguments{
\item{x}{An \link[=atm_lgl]{atomic logical object} for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object.}

\item{na}{A non-\code{NA} logical scalar indicating what value should replace \code{NA} values.}

\item{y}{An atomic logical object. for all functions other than \code{is_in}, \code{not_in}, \code{has}, and \code{lacks}. Otherwise, an atomic object \link[=compatible]{compatible} with \code{x}.}

\item{err}{A non-\code{NA} logical scalar. \code{err = TRUE} indicates \code{TRUE} should be substituted for non-logical values, \code{err = FALSE} indicates \code{FALSE} should be substituted for non-logical values, \code{err = NA} indicates an error should be thrown if a non-logical value is encountered.}

\item{...}{An arbitrary number of \link[=lgl_vec]{logical vecs} to be processed.}

\item{a}{A non-\code{NA} logical scalar indicating whether to atomize \code{...} before processing. This creates a single atomic vector of all atomic elements contained in all \code{...} arguments and effectively changes the behavior of \code{or} to \code{any}, \code{and} to \code{all}, and \code{not} to \code{!any}.}

\item{not}{A non-\code{NA} logical scalar indicating whether to negate values in arguments supplied in \code{...} before processing.}

\item{agg}{A \link[=cmp_chr_scl]{complete character scalar} in \code{c('nor', 'one', 'any', 'two', 'all')} used to specify, respectively, that 0, 1, any, 2 or more, and all values must be \code{TRUE}.}

\item{sweep}{\link[=cmp_chr_scl]{Character scalar}. \code{NA}, \code{across}, \code{within}, and \code{both} indicate no sweeping, sweeping corresponding elements across arguments, sweeping within argument, and sweeping across and within all arguments, respectively.}
}
\description{
The following are extensions of base logical functions:
\tabular{rl}{
\code{TEST(x, ...)}   \tab Extension of  \code{isTRUE(x)}.
\cr          \code{not(x, ...)}   \tab Extension of  \code{!x}.
\cr        \code{or(x, y, ...)}   \tab Extension of  \code{x | y}.
\cr       \code{and(x, y, ...)}   \tab Extension of  \code{x & y}.
\cr       \code{nor(x, y, ...)}   \tab Extension of  \code{!(x | y)}.
\cr       \code{one(x, y, ...)}   \tab Extension of  \code{xor(x, y)}.
\cr                          \tab  
\cr      \code{isin(x, y, ...)}   \tab Extension of
\cr     \code{is_in(x, y, ...)}   \tab ... \code{x \%in\% y}. 
\cr                          \tab  
\cr     \code{isout(x, y, ...)}   \tab Extension of
\cr     \code{notin(x, y, ...)}   \tab ... \code{!(x \%in\% y)}.
\cr    \code{is_out(x, y, ...)}   \tab  
\cr    \code{not_in(x, y, ...)}   \tab  
\cr                          \tab  
\cr       \code{has(x, y, ...)}   \tab Extension of  \code{y \%in\% x}.
\cr     \code{lacks(x, y, ...)}   \tab Extension of  \code{!(y \%in\% x)}.
}
The next set of functions evaluate an arbitrary number of \code{...} arguments expected to be logical scalars for whether:
\tabular{rl}{
   \code{ANY(.)}   \tab Any \code{...} argument is scalar \code{TRUE}.
\cr \code{ALL(.)}   \tab All \code{...} arguments are scalar \code{TRUE}.
\cr \code{NOR(.)}   \tab \code{0} \code{...} arguments are scalar \code{TRUE}.
\cr \code{ONE(.)}   \tab \code{1} \code{...} argument is scalar \code{TRUE}.
\cr \code{TWO(.)}   \tab \verb{2+} \code{...} arguments are scalar \code{TRUE}.
}
The remainder of functions in this family sweep across or within \code{...} arguments, as specified by the arguments \code{across} and \code{within}:
\tabular{rl}{
   \code{tests(.)}   \tab Logically indexes \code{TRUE} values in each sweep.
\cr             \tab  
\cr    \code{w(.)}   \tab Numerically indexes \code{TRUE} values in each sweep (a swept \code{\link[base]{which}}).
\cr             \tab  
\cr \code{nors(.)}   \tab Evaluates each sweep for \code{0} \code{TRUE} values.
\cr             \tab  
\cr \code{anys(.)}   \tab Evaluates each sweep for any \code{TRUE} values.
\cr             \tab  
\cr \code{alls(.)}   \tab Evaluates each sweep for only \code{TRUE} values.
\cr             \tab  
\cr \code{ones(.)}   \tab Evaluates each sweep for exactly \code{1} \code{TRUE} value.
\cr             \tab  
\cr \code{twos(.)}   \tab Evaluates each sweep for \verb{2+} \code{TRUE} values.
}
}
\examples{
s1. <- TRUE
s2. <- TRUE
s3. <- FALSE
v1. <- sample(c(TRUE, FALSE), 5, replace = TRUE)
v2. <- sample(c(TRUE, FALSE), 5, replace = TRUE)
v3. <- sample(c(TRUE, FALSE), 5, replace = TRUE)

v1.
v2.
v3.

not(v3.)
or(v2., v3.)
and(v2., v3.)
nor(v2., v3.)
one(v2., v3.)

TEST(s1.)
TEST(NA, na = FALSE)
TEST("seven", err = FALSE)

ANY(s1., s2., s3.)
ALL(s1., s2., s3.)
NOR(s1., s2., s3.)
ONE(s1., s2., s3.)
TWO(s1., s2., s3.)

tests(v1.)
tests(v1., v2., v3., sweep = "across", agg = "any")
tests(v1., v2., v3., sweep = "within", agg = "nor")
tests(v1., v2., v3., sweep = "both", agg = "two")

ones(v1., v2., v3., sweep = "across")
twos(v1., v2., v3., sweep = "within")
nors(v1., v2., v3., sweep = "both")
anys(v1., v2., v3., sweep = "within")
alls(v1., v2., v3., sweep = "across")

is_in("a", letters)
is_in(c("a", "b", "c"), letters, agg = "all")

not_in(c("a", "b", "1"), letters, agg = "two")

has(letters, "1")
has(letters, "a")

lacks(letters, "1")
lacks(letters, "a")
}
\seealso{
Other logicals: 
\code{\link{failsafe_binaries}},
\code{\link{failsafe_is}},
\code{\link{meets}()}
}
\concept{logicals}
