% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/makestr.R
\encoding{UTF-8}
\name{makestr}
\alias{makestr}
\alias{geq}
\alias{geq0}
\alias{gcat}
\alias{gelt}
\alias{gfun}
\alias{glst}
\alias{gform}
\alias{gtick}
\alias{gwrap}
\alias{gbrace}
\alias{gcolon}
\alias{gparen}
\alias{gquote}
\alias{gquote2}
\alias{gbracket}
\alias{pcat}
\alias{peq}
\alias{peq0}
\alias{pelt}
\alias{pfun}
\alias{plst}
\alias{pform}
\alias{ptick}
\alias{pwrap}
\alias{pbrace}
\alias{pcolon}
\alias{pparen}
\alias{pquote}
\alias{pquote2}
\alias{pbracket}
\title{Specialized string building functions}
\usage{
geq(x, ...)

geq0(x, ...)

gcat(...)

gelt(x, ...)

gfun(x, ...)

glst(...)

gform(x, ...)

gtick(...)

gwrap(l, r, ...)

gbrace(...)

gcolon(...)

gparen(...)

gquote(...)

gquote2(...)

gbracket(...)

pcat(...)

peq(x, ...)

peq0(x, ...)

pelt(x, ...)

pfun(x, ...)

plst(...)

pform(x, ...)

ptick(...)

pwrap(l, r, ...)

pbrace(...)

pcolon(...)

pparen(...)

pquote(...)

pquote2(...)

pbracket(...)
}
\arguments{
\item{x}{An object containing atomic values (atomized before processing).}

\item{...}{An arbitrary number of objects to be atomized into a single atomic vector.}

\item{l, r}{\link[=cmp_chr_scl]{Complete character scalars} giving left and right side enclosures for \code{...} after \link[=a]{atomization}.}
}
\value{
A character scalar or vector
}
\description{
Build strings where function names are composed of a single-letter prefix and a longer suffix. Prefixes and their meanings are
\tabular{rl}{
  \code{g}   \tab Glue/collapse \code{...} args
\cr \code{p}   \tab Paste across corresponding element of \code{...}.
}
Suffixes and their meanings are
\tabular{rl}{
  \code{bracket}   \tab Enclose in square brackets
\cr \code{quote2}   \tab Enclose in double quotes
\cr  \code{quote}   \tab Enclose in single quotes
\cr  \code{paren}   \tab Enclose in parentheses
\cr  \code{brace}   \tab Enclose in braces
\cr   \code{tick}   \tab Enclose in backticks
\cr   \code{wrap}   \tab Enclose left and right
\cr            \tab  
\cr  \code{colon}   \tab Delimit with colons
\cr    \code{lst}   \tab Delimit with comma + space
\cr            \tab  
\cr   \code{form}   \tab Formula statement
\cr    \code{elt}   \tab Element extraction statement
\cr    \code{fun}   \tab Function call statement
\cr    \code{cat}   \tab Vector concatenation statement
\cr    \code{eq0}   \tab Unpadded equality statement
\cr     \code{eq}   \tab Space-padded equality statement
}
Each prefix is joined with each suffix to create a unique function. The action indicated by the prefix happens first, followed by the action indicated in the suffix. How each function works is illustrated in the details.
}
\examples{
geq(c('x', 'y', 'z'), 0, 1, 2)
peq(c('x', 'y', 'z'), 0, 1, 2)

geq0(c('x', 'y', 'z'), 0, 1, 2)
peq0(c('x', 'y', 'z'), 0, 1, 2)

gcat(c('x', 'y', 'z'), 0, 1, 2)
pcat(c('x', 'y', 'z'), 0, 1, 2)

gelt(c('x', 'y', 'z'), 0, 1, 2)
pelt(c('x', 'y', 'z'), 0, 1, 2)

gfun(c('x', 'y', 'z'), 0, 1, 2)
pfun(c('x', 'y', 'z'), 0, 1, 2)

gform(c('x', 'y', 'z'), 0, 1, 2)
pform(c('x', 'y', 'z'), 0, 1, 2)

glst(c('x', 'y', 'z'), 0, 1, 2)
plst(c('x', 'y', 'z'), 0, 1, 2)

gtick(c('x', 'y', 'z'), 0, 1, 2)
ptick(c('x', 'y', 'z'), 0, 1, 2)

gbrace(c('x', 'y', 'z'), 0, 1, 2)
pbrace(c('x', 'y', 'z'), 0, 1, 2)

gcolon(c('x', 'y', 'z'), 0, 1, 2)
pcolon(c('x', 'y', 'z'), 0, 1, 2)

gparen(c('x', 'y', 'z'), 0, 1, 2)
pparen(c('x', 'y', 'z'), 0, 1, 2)

gquote(c('x', 'y', 'z'), 0, 1, 2)
pquote(c('x', 'y', 'z'), 0, 1, 2)

gquote2(c('x', 'y', 'z'), 0, 1, 2)
pquote2(c('x', 'y', 'z'), 0, 1, 2)

gbracket(c('x', 'y', 'z'), 0, 1, 2)
pbracket(c('x', 'y', 'z'), 0, 1, 2)

gwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)
pwrap(c('l', 'L', 'l'), 'r', 0, 1, 2)
}
\seealso{
Other strings: 
\code{\link{blank}()},
\code{\link{chn}()},
\code{\link{delim}},
\code{\link{fsub}()},
\code{\link{gr}},
\code{\link{ipat}()},
\code{\link{markdown}},
\code{\link{max_nch}()},
\code{\link{ox}()},
\code{\link{pgrid}()},
\code{\link{revstr}()},
\code{\link{spaces}()},
\code{\link{ss}()},
\code{\link{tocase}()},
\code{\link{weave}()}
}
\concept{strings}
